<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Guardião da Etérea - Protótipo v4.7 (Controles de Rastro)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.3/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-glow@3.2.0/dist/filter-glow.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(138, 43, 226, 0.04) 0%, 
                rgba(0, 191, 255, 0.02) 30%, 
                rgba(75, 0, 130, 0.03) 60%, 
                rgba(0, 0, 0, 0.98) 100%), 
                #000000;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        canvas.game-canvas {
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }
        canvas.game-canvas.is-visible {
            opacity: 1;
        }
        #developer-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(138, 43, 226, 0.04) 0%, 
                rgba(0, 191, 255, 0.02) 30%, 
                rgba(75, 0, 130, 0.03) 60%, 
                rgba(0, 0, 0, 0.98) 100%), 
                #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 400;
            cursor: pointer;
            opacity: 1;
            transition: opacity 1s ease-in-out;
        }
        #developer-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        #developer-logo {
            max-width: 90%;
            max-height: 90%;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        #developer-logo.fade-in {
            opacity: 1;
        }
        #welcome-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(138, 43, 226, 0.04) 0%, 
                rgba(0, 191, 255, 0.02) 30%, 
                rgba(75, 0, 130, 0.03) 60%, 
                rgba(0, 0, 0, 0.98) 100%), 
                #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            cursor: default;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }
        #welcome-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        #welcome-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        #welcome-overlay.fade-out-slow {
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
        }
        #welcome-logo {
            max-width: 80%;
            max-height: 80%;
            opacity: 0;
            transition: opacity 3s ease-in-out;
        }
        #welcome-logo.fade-in {
            opacity: 1;
        }
        #play-button-container {
            position: absolute;
            bottom: 15%;
            opacity: 0;
            transition: opacity 1s ease-in-out 1.5s; /* Fade in after logo */
        }
        #welcome-overlay.show #play-button-container {
            opacity: 1;
        }
        #play-button {
            background: none;
            border: none;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(24px, 4vw, 48px); /* Responsive font size */
            cursor: pointer;
            padding: 20px;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8), 0 0 16px rgba(197, 138, 255, 0.7);
            transition: text-shadow 0.3s ease;
        }
        #play-button:hover {
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #c58aff, 0 0 40px #c58aff;
        }
        #play-button span {
            display: inline-block;
            animation: bounce 1.8s infinite ease-in-out;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-25px); }
            60% { transform: translateY(-12px); }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        #core-status {
            position: absolute;
            bottom: 20px;
            text-align: center;
            width: 100%;
            font-size: 1.5em;
        }
        #danger-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 90;
            box-shadow: inset 0 0 150px 50px rgba(255, 0, 0, 0.35);
        }
        #danger-overlay.active {
            animation: pulse-danger 2s infinite ease-in-out;
        }
        @keyframes pulse-danger {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }
        #danger-overlay.wave-alert {
            animation: danger-wave 0.45s steps(2, jump-none) infinite;
            box-shadow: inset 0 0 220px 70px rgba(255, 60, 60, 0.55);
        }
        @keyframes danger-wave {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.95; }
        }

        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 150;
            display: none;
        }
        body.mobile-debug #debug-info {
            display: block;
        }
        #mobile-pause-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(20, 20, 40, 0.8);
            border: 2px solid #4a4a8a;
            border-radius: 15px;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 160;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s 0.3s;
            backdrop-filter: blur(5px);
        }
        body.ui-on #mobile-pause-button {
            opacity: 1;
            visibility: visible;
        }
        #mobile-pause-button:hover {
            background-color: rgba(40, 40, 60, 0.9);
            border-color: #6a6aff;
        }
        #pause-icon {
            width: 20px;
            height: 20px;
            position: relative;
        }
        #pause-icon::before,
        #pause-icon::after {
            content: '';
            position: absolute;
            background-color: #c58aff;
            width: 4px;
            height: 16px;
            border-radius: 2px;
        }
        #pause-icon::before {
            left: 4px;
        }
        #pause-icon::after {
            right: 4px;
        }
        #controls-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(20, 20, 40, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #4a4a8a;
            color: white;
            z-index: 200;
            pointer-events: auto;
            width: 280px;
            backdrop-filter: blur(5px);
        } 

        #ui-container, #controls-container {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0s 0.5s;
            pointer-events: none; /* Prevent interaction when hidden */
        }
        
        /* Show score/combo only when UI is active and game is not over */
        body.ui-on #ui-container {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
            pointer-events: none; /* The container itself shouldn't block clicks */
        }

        /* Show controls only when explicitly toggled on during active gameplay */
        body.ui-on.controls-on #controls-container {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition-delay: 0s;
        }
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #controls-container h3 {
            margin: 0;
            text-align: center;
            font-size: 1.1em;
            color: #c58aff;
        }
        #copy-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ddd;
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #copy-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .volume-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            width: 80%;
        }
        .volume-control label {
            margin-right: 10px;
        }
        .volume-control input[type="range"] {
            width: 100%;
        }
        .value-input {
            font-weight: bold;
            color: #eadaff;
            background-color: rgba(0,0,0,0.3);
            padding: 3px 8px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            border: 1px solid rgba(255,255,255,0.1);
            width: 70px;
            text-align: right;
            -moz-appearance: textfield; /* Firefox */
        }
        .value-input:hover {
            cursor: ew-resize;
        }
        .value-input::-webkit-outer-spin-button,
        .value-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0; /* Safari and Chrome */
        }
        label {
            font-size: 0.9em;
        }
        /* Accordion Styles */
        details {
            border-bottom: 1px solid rgba(138, 138, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        details:last-of-type {
            border-bottom: none;
            padding-bottom: 0;
        }
        summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            padding: 5px 0;
            color: #b39ddb;
            font-size: 1em;
        }
        summary::-webkit-details-marker {
            display: none; /* Chrome */
        }
        summary::before {
            content: '+';
            margin-right: 10px;
            font-weight: bold;
        }
        details[open] > summary::before {
            content: '−';
        }
        details .control-group-content {
            padding-top: 10px;
        }
        #score, #combo {
            padding: 20px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        #score, #combo, #core-status {
            display: none; /* Hide HUD elements by default */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            text-align: center; z-index: 100; pointer-events: auto; transition: opacity 0.3s ease;
        }
        .hidden { opacity: 0; pointer-events: none; }
        .overlay h1 { font-size: 3em; margin-bottom: 10px; }
        .overlay p { font-size: 1.2em; margin-bottom: 20px; }
        .overlay button {
            padding: 15px 30px; font-size: 1.2em; cursor: pointer; background-color: #4a4a8a;
            border: 2px solid #8a8aff; color: white; border-radius: 10px; margin-top: 20px;
            transition: background-color 0.2s, transform 0.2s;
        }
        .overlay button:hover { background-color: #6a6aff; transform: scale(1.05); }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #8c6aff; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        body.intro-active #ui-container,
        body.intro-active #controls-container {
            display: none !important;
        }
        .overlay-logo {
            width: 200px;
            margin-bottom: 20px;
        }
        #final-score-details {
            margin: 20px 0;
            text-align: left;
        }
        #final-score-details p {
            margin: 5px 0;
            font-size: 1.2em;
        }
        #rating-container {
            margin-top: 20px;
        }
        .stars {
            font-size: 2em;
            cursor: pointer;
        }
        .star {
            color: #c58aff;
            transition: color 0.2s;
        }
        .star:hover, .star.filled {
            color: #ffff00;
        }
        #rating-thanks {
            margin-top: 10px;
            color: #d1c4e9;
            transition: opacity 0.3s;
        }
        #joystick-container {
            position: absolute;
            bottom: 80px;
            left: 30px;
            width: 150px;
            height: 150px;
            z-index: 150;
            opacity: 0.5;
            display: none; /* Hidden by default */
        }
        #joystick-base, #joystick-handle { border-radius: 50%; }
        #joystick-base { position: relative; width: 100%; height: 100%; background: rgba(80, 80, 120, 0.4); border: 2px solid rgba(150, 150, 200, 0.3); }
        #joystick-handle { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background: rgba(150, 150, 200, 0.6); transform: translate(-50%, -50%); border: 2px solid rgba(200, 200, 255, 0.5);
        }
    </style>
    <script src="js/sound-engine.js"></script>
</head>
<body>
    <div id="developer-overlay">
        <img id="developer-logo" src="developer.png" alt="Developer Logo">
    </div>
    <div id="welcome-overlay">
        <img id="welcome-logo" src="eonwisp.png" alt="Eonwisp Logo">
        <div id="play-button-container">
            <button id="play-button">
                <span style="animation-delay: 0.0s;">P</span>
                <span style="animation-delay: 0.1s;">L</span>
                <span style="animation-delay: 0.2s;">A</span>
                <span style="animation-delay: 0.3s;">Y</span>
            </button>
        </div>
    </div>
    <div id="danger-overlay" class="hidden"></div> 

    <div id="permission-overlay" class="overlay hidden">
        <h1>Guardião da Etérea</h1>
        <p>Este jogo utiliza o acelerômetro do seu dispositivo.<br>No PC, o mouse será capturado para melhor controle.</p>
        <button id="permission-button">Iniciar Jogo</button>
    </div>

    <div id="pause-overlay" class="overlay hidden">
        <img src="eonwisp.png" class="overlay-logo" alt="Eonwisp">
        <h1>Jogo Pausado</h1>
        <div class="volume-control">
            <label for="volume-slider">Volume</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1">
        </div>
        <button id="resume-button">Continuar</button>
        <button id="pause-return-home-button">Return Home</button>

        <!-- Mobile-only controls, visible inside pause menu -->
        <div id="mobile-controls-container" style="display: none; margin-top: 20px; background-color: rgba(10, 10, 20, 0.5); padding: 15px; border-radius: 10px; border-top: 1px solid #4a4a8a; width: 90%; max-width: 320px;">
            <details open>
                <summary style="color: #c58aff; font-size: 1.1em;">Calibração Móvel</summary>
                <div class="control-group-content">
                    <div class="control-item" style="margin-bottom: 20px;">
                        <label for="control-mode-toggle">Modo de Controle</label>
                        <button id="control-mode-toggle" style="background: rgba(255,255,255,0.1); border: 1px solid #8a8aff; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Acelerômetro</button>
                    </div>

                    <div class="control-item">
                        <label for="accelerometer-multiplier-value">Sensibilidade</label>
                        <input type="number" id="accelerometer-multiplier-value" class="value-input" step="0.1" value="2">
                    </div>
                    <div class="control-item" style="flex-direction: column; align-items: stretch; margin-top: 15px;">
                        <input type="range" id="accelerometer-multiplier-slider" min="0" max="10" step="0.1" value="2" style="width: 100%;">
                    </div>
                    <div class="control-item" style="margin-top: 20px;">
                        <label for="mobile-impulse-value">Impulso Base</label>
                        <input type="number" id="mobile-impulse-value" class="value-input" step="0.1" value="0.5">
                    </div>
                    <div class="control-item" style="flex-direction: column; align-items: stretch; margin-top: 15px;">
                        <input type="range" id="mobile-impulse-slider" min="0.01" max="2.0" step="0.01" value="0.5" style="width: 100%;">
                    </div>
                </div>
            </details>
            <details>
                <summary style="color: #c58aff; font-size: 1.1em;">Controles Avançados</summary>
                <div class="control-group-content">
                    <div class="control-item">
                        <label for="accelerometer-deadzone-value">Zona Morta</label>
                        <input type="number" id="accelerometer-deadzone-value" class="value-input" step="0.1" value="0.2">
                    </div>
                    <div class="control-item" style="flex-direction: column; align-items: stretch; margin-top: 15px;">
                        <input type="range" id="accelerometer-deadzone-slider" min="0" max="2" step="0.1" value="0.2" style="width: 100%;">
                    </div>
                    <div class="control-item" style="margin-top: 15px; justify-content: flex-start;">
                        <input type="checkbox" id="invert-x-axis" style="margin-right: 10px; width: 20px; height: 20px;">
                        <label for="invert-x-axis">Inverter Eixo X</label>
                    </div>
                    <div class="control-item" style="justify-content: flex-start;">
                        <input type="checkbox" id="invert-y-axis" style="margin-right: 10px; width: 20px; height: 20px;" checked>
                        <label for="invert-y-axis">Inverter Eixo Y</label>
                    </div>
                </div>
            </details>
        </div>
    </div>

    <div id="game-over-overlay" class="overlay hidden">
        <img src="eonwisp.png" class="overlay-logo" alt="Eonwisp">
        <h1>Fim de Jogo</h1>
        <div id="final-score-details">
            <p>Kills: <span id="final-kills">0</span></p>
            <p>Max Combo: <span id="final-max-combo">0</span></p>
            <p>Backshots: <span id="final-backshots">0</span></p>
            <p>Critical Hits: <span id="final-critical-hits">0</span></p>
        </div>
        <div id="rating-container">
            <p>Rate your experience:</p>
            <div class="stars">
                <span class="star" data-value="1">☆</span><span class="star" data-value="2">☆</span><span class="star" data-value="3">☆</span><span class="star" data-value="4">☆</span><span class="star" data-value="5">☆</span>
            </div>
            <p id="rating-thanks" class="hidden">Thank you for your feedback!</p>
        </div>
        <button id="play-again-button">Jogar Novamente</button>
        <button id="return-home-button">Return Home</button>
    </div>

    <div id="controls-container">
        <div class="controls-header">
            <h3>Controles de Física</h3>
            <button id="copy-button">Copiar</button>
        </div>
        <details>
            <summary>Movimento</summary>
            <div class="control-group-content">
                <div class="control-item"> <label for="impulse-value">Impulso (Mouse)</label> <input type="number" id="impulse-value" class="value-input" step="0.05" value="0.225"> </div>
                <div class="control-item"> <label for="orbital-impulse-value">Impulso em Órbita</label> <input type="number" id="orbital-impulse-value" class="value-input" step="0.01" value="0.135"> </div>
                <div class="control-item"> <label for="damping-value">Amortecimento</label> <input type="number" id="damping-value" class="value-input" step="0.005" value="0.800"> </div>
                <div class="control-item"> <label for="core-brake-value">Freio no Núcleo</label> <input type="number" id="core-brake-value" class="value-input" step="0.05" value="0.925"> </div>
            </div>
        </details>
        <details>
            <summary>Corda</summary>
            <div class="control-group-content">
                <div class="control-item"> <label for="max-length-value">Tamanho Máx.</label> <input type="number" id="max-length-value" class="value-input" step="10" value="190"> </div>
                <div class="control-item"> <label for="gravity-value">Atração Gravitacional</label> <input type="number" id="gravity-value" class="value-input" step="0.05" value="1.42"> </div>
                <div class="control-item"> <label for="retraction-value">Força de Retração</label> <input type="number" id="retraction-value" class="value-input" step="0.05" value="4.04"> </div>
                <div class="control-item"> <label for="overshoot-value">Elasticidade (%)</label> <input type="number" id="overshoot-value" class="value-input" step="0.01" value="0.976"> </div>
                <div class="control-item"> <label for="snap-back-value">Força Elástica</label> <input type="number" id="snap-back-value" class="value-input" step="0.01" value="0.575"> </div>
                <div class="control-item"> <label for="stiffness-value">Rigidez (Stiffness)</label> <input type="number" id="stiffness-value" class="value-input" step="0.001" value="0.0085"> </div>
            </div>
        </details>
        <details>
            <summary>Combate</summary>
             <div class="control-group-content">
                 <div class="control-item"> <label for="enemy-health-value">Vida Padrão (Inimigo)</label> <input type="number" id="enemy-health-value" class="value-input" step="1" value="1"> </div>
                 <div class="control-item"> <label for="critical-speed-value">Vel. Crítica Mín.</label> <input type="number" id="critical-speed-value" class="value-input" step="0.5" value="4.3"> </div>
                 <div class="control-item"> <label for="hit-vibration-value">Vibração (Impacto)</label> <input type="number" id="hit-vibration-value" class="value-input" step="0.01" value="0.795"> </div>
                 <div class="control-item"> <label for="crit-vibration-value">Multiplicador Vib. Crítica</label> <input type="number" id="crit-vibration-value" class="value-input" step="0.1" value="1"> </div>
            </div>
        </details>
        <details>
            <summary>Aparência</summary>
            <div class="control-group-content">
                 <div class="control-item"> <label for="min-thickness-value">Espessura Mín.</label> <input type="number" id="min-thickness-value" class="value-input" step="0.5" value="4.6"> </div>
                 <div class="control-item"> <label for="max-thickness-value">Espessura Máx.</label> <input type="number" id="max-thickness-value" class="value-input" step="0.5" value="24.3"> </div>
                 <div class="control-item"> <label for="stretch-y-value">Alongamento Vel. (Y)</label> <input type="number" id="stretch-y-value" class="value-input" step="0.01" value="0.544"> </div>
                 <div class="control-item"> <label for="squash-x-value">Achatar Vel. (X)</label> <input type="number" id="squash-x-value" class="value-input" step="0.01" value="1.346"> </div>
                 <div class="control-item"> <label for="rotation-threshold-value">Vel. Mín. Rotação</label> <input type="number" id="rotation-threshold-value" class="value-input" step="0.1" value="8.1"> </div>
            </div>
        </details>
        <details open>
             <summary>Efeitos</summary>
             <div class="control-group-content">
                <div class="control-item"> <label for="slow-mo-strength-value">Força do Slow-Mo</label> <input type="number" id="slow-mo-strength-value" class="value-input" step="0.01" value="0.04"> </div>
                <div class="control-item"> <label for="slow-mo-duration-value">Duração do Slow-Mo</label> <input type="number" id="slow-mo-duration-value" class="value-input" step="1" value="40"> </div>
                <div class="control-item"> <label for="camera-zoom-value">Zoom da Câmera</label> <input type="number" id="camera-zoom-value" class="value-input" step="0.05" value="1.02"> </div>
                <div class="control-item"> <label for="splash-amount-value">Qtd. Partículas (Splash)</label> <input type="number" id="splash-amount-value" class="value-input" step="1" value="65"> </div>
                <div class="control-item"> <label for="trail-duration-value">Duração do Rastro</label> <input type="number" id="trail-duration-value" class="value-input" step="1" value="24"> </div>
                <div class="control-item"> <label for="trail-size-value">Tamanho do Rastro</label> <input type="number" id="trail-size-value" class="value-input" step="0.5" value="7.1"> </div>
            </div>
        </details>
    </div>

    <div id="loading-overlay" class="overlay hidden">
        <div class="loader"></div>
        <p style="margin-top: 20px;">Carregando...</p>
    </div>

    <div id="ui-container">
        <div id="score">Pontuação: 0</div>
        <div id="combo">Combo: x0</div>
        <div id="core-status">Nucleo: 30 / 190</div>
    </div>

    <div id="mobile-pause-button">
        <div id="pause-icon"></div>
    </div>

    <div id="debug-info">
        AX: 0.00<br>
        AY: 0.00<br>
        MX: 0.00<br>
        MY: 0.00
    </div>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-handle"></div>
        </div>
    </div>

    <audio id="background-music" loop preload="auto">
        <source src="eonwisp.mp3" type="audio/mpeg">
    </audio>

    <script>
        window.onload = function() {
            document.body.classList.add('intro-active');
            const app = new PIXI.Application({
                width: window.innerWidth,
                height: window.innerHeight,
                antialias: true,
                transparent: false,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                backgroundColor: 0x0a0a1a,
            });
            document.body.appendChild(app.view);
            app.view.style.position = 'absolute';
            app.view.classList.add('game-canvas');

            const developerOverlay = document.getElementById('developer-overlay');
            const developerLogo = document.getElementById('developer-logo');
            const welcomeOverlay = document.getElementById('welcome-overlay');
            const welcomeLogo = document.getElementById('welcome-logo');
            const dangerOverlay = document.getElementById('danger-overlay');
            const scoreText = document.getElementById('score');
            const comboText = document.getElementById('combo');
            const coreStatusText = document.getElementById('core-status');
            const permissionOverlay = document.getElementById('permission-overlay');
            const permissionButton = document.getElementById('permission-button');
            const pauseOverlay = document.getElementById('pause-overlay');
            const resumeButton = document.getElementById('resume-button');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const playAgainButton = document.getElementById('play-again-button');
            const volumeSlider = document.getElementById('volume-slider');
            const controlsContainer = document.getElementById('controls-container');

            let soundModule = null;
            const AM_SCALE_FREQUENCIES = [
                110, 123.47, 130.81, 146.83, 164.81, 174.61, 196, 220,
                246.94, 261.63, 293.66, 329.63, 349.23, 392, 440, 493.88,
                523.25, 587.33, 659.25, 698.46, 783.99, 880
            ];
            let comboNoteIndex = 0;

            function nearestAmFrequency(target) {
                let closest = AM_SCALE_FREQUENCIES[0];
                let smallestDiff = Math.abs(target - closest);
                for (let i = 1; i < AM_SCALE_FREQUENCIES.length; i++) {
                    const candidate = AM_SCALE_FREQUENCIES[i];
                    const diff = Math.abs(target - candidate);
                    if (diff < smallestDiff) {
                        closest = candidate;
                        smallestDiff = diff;
                    }
                }
                return closest;
            }

            function getComboNoteFrequency(comboCount, isCritical) {
                if (comboCount <= 1) {
                    comboNoteIndex = 0;
                } else {
                    comboNoteIndex = (comboNoteIndex + 1) % AM_SCALE_FREQUENCIES.length;
                }

                let noteIndex = comboNoteIndex;

                const sizeOffset = Math.floor(Math.max(0, activeEffects.sizeMultiplier - 1) * 2);
                if (sizeOffset > 0) {
                    noteIndex = Math.max(0, noteIndex - sizeOffset);
                }

                if (isCritical) {
                    noteIndex = Math.min(AM_SCALE_FREQUENCIES.length - 1, noteIndex + 2);
                }

                return AM_SCALE_FREQUENCIES[noteIndex];
            }

            try {
                soundModule = new EonwispSoundModule({
                    bpm: 96,
                    beatsPerBar: 4,
                    masterVolume: parseFloat(volumeSlider.value),
                });
                globalThis.__EONWISP_SOUND__ = soundModule;
            } catch (error) {
                console.warn('Audio engine unavailable:', error);
            }

            let developerLogoShown = false;
            let gameLogoShown = false;
            let experienceStarted = false;
            let developerClickTime = 0;
            let themeLayerLoaded = false;
            let pendingThemeStart = false;

            function setupAudio() {
                if (!soundModule) {
                    console.warn('Audio engine not available - sound disabled');
                    return;
                }

                const initialValue = parseFloat(volumeSlider.value);
                if (!Number.isNaN(initialValue)) {
                    soundModule.setMasterVolume(initialValue, { time: 0 });
                }

                // More aggressive unlock - attach to multiple user interaction events
                soundModule.attachUnlockOn(document.body);
                soundModule.attachUnlockOn(window, ['pointerdown', 'keydown', 'touchstart']);

                // Attempt to load music layer with retry logic
                function loadMusicLayer(retryCount = 0) {
                    soundModule.registerMusicLayer('eonwisp.mp3', {
                        loop: true,
                        gain: 0.85,
                        fadeTime: 1.5,
                        bpm: 96,
                        beatsPerBar: 4
                    }).then(() => {
                        console.log('Theme music loaded successfully');
                        themeLayerLoaded = true;
                        if (pendingThemeStart) {
                            pendingThemeStart = false;
                            playThemeMusic();
                        }
                        console.log('Music should be starting now...');
                    }).catch(error => {
                        console.warn('Theme layer failed to load (attempt ' + (retryCount + 1) + '):', error);
                        if (retryCount < 2) {
                            console.log('Retrying music load in 1 second...');
                            setTimeout(() => loadMusicLayer(retryCount + 1), 1000);
                        } else {
                            console.warn('Audio failed to load after 3 attempts');
                        }
                    });
                }

                // Function to actually play the theme with fade-in from 10% to 90% volume over 2 seconds
                function playThemeMusic() {
                    if (!soundModule || !themeLayerLoaded) {
                        console.warn('Cannot play theme: sound module or theme not ready');
                        return;
                    }
                    try {
                        // Start music at 10% volume (0.1 * 0.85 = 0.085)
                        soundModule.playMusicLayer('eonwisp.mp3', { 
                            startAtNextBar: false, 
                            fadeTime: 0.1, // Quick fade in to start
                            targetGain: 0.1 // Start at 10% of the intended volume
                        });
                        
                        // Fade to 90% volume over 2 seconds
                        setTimeout(() => {
                            if (soundModule && themeLayerLoaded) {
                                soundModule.setLayerMix('eonwisp.mp3', 0.9, { fadeTime: 2.0 });
                            }
                        }, 100); // Small delay to ensure music has started
                        
                        console.log('Theme music playing with fade-in');
                    } catch (error) {
                        console.error('Error playing theme music:', error);
                    }
                }

                loadMusicLayer();
            }

            function playEnemyImpactSFX(isCritical, comboCount) {
                if (!soundModule) return;

                const targetFrequency = getComboNoteFrequency(comboCount, isCritical);

                soundModule.createOneShot({
                    type: isCritical ? 'sawtooth' : 'triangle',
                    frequency: targetFrequency,
                    attack: 0.01,
                    release: 0.35,
                    duration: 0.45,
                    volume: 0.22,
                });
            }


            function playCoreDamageSFX() {
                if (!soundModule) return;

                const frequency = nearestAmFrequency(180);

                soundModule.createOneShot({
                    type: 'square',
                    frequency,
                    attack: 0.02,
                    release: 0.6,
                    duration: 0.6,
                    volume: 0.28,
                });
            }


            function startDeveloperLogoSequence() {
                if (developerLogoShown) return;
                developerLogoShown = true;
                
                console.log("🏢 Starting developer logo sequence...");
                
                // Fade in developer logo
                setTimeout(() => {
                    developerLogo.classList.add('fade-in');
                }, 500);
                
                // Auto-advance after 3 seconds if not clicked
                setTimeout(() => {
                    if (!gameLogoShown) {
                        transitionToGameLogo();
                    }
                }, 3500); // 500ms delay + 3000ms hold
            }

            function transitionToGameLogo() {
                if (gameLogoShown) return;
                gameLogoShown = true;
                
                console.log("🎮 Transitioning to game logo...");
                
                // Fade out developer overlay
                developerOverlay.classList.add('fade-out');
                
                // Show and fade in game logo
                setTimeout(() => {
                    welcomeOverlay.classList.add('show');
                    setTimeout(() => {
                        welcomeLogo.classList.add('fade-in');
                        // Only add click handler after game logo is visible
                        setupGameLogoClickHandler();
                    }, 100);
                }, 500);
                
                // Hide developer overlay completely after fade out
                setTimeout(() => {
                    developerOverlay.style.display = 'none';
                }, 1000);
            }

            function beginExperience() {
                document.body.classList.remove('intro-active');
                if (experienceStarted) return;
                experienceStarted = true;
                
                console.log("🚀 Starting game experience...");
                
                // Force audio to play from the beginning, unmuted.
                // This ensures it syncs with the game start animation.
                if (soundModule) {
                    soundModule.unlock().then(() => {
                        if (themeLayerLoaded) {
                            playThemeMusic(); // Use the same function as everywhere else
                        } else {
                            pendingThemeStart = true;
                        }
                    });
                }
                
                // Fallback HTML audio element with fade-in
                const backgroundMusic = document.getElementById('background-music');
                if (backgroundMusic) {
                    // Start at 10% volume and fade to 90% over 2 seconds
                    backgroundMusic.volume = 0.1; // Start at 10%
                    backgroundMusic.play().then(() => {
                        console.log('Background music playing via HTML audio with fade-in');
                        // Fade to 90% volume over 2 seconds
                        let currentVolume = 0.1;
                        const targetVolume = 0.9;
                        const fadeSteps = 60; // 60 steps over 2 seconds (30fps)
                        const volumeIncrement = (targetVolume - currentVolume) / fadeSteps;
                        
                        const fadeInterval = setInterval(() => {
                            currentVolume += volumeIncrement;
                            if (currentVolume >= targetVolume) {
                                currentVolume = targetVolume;
                                clearInterval(fadeInterval);
                            }
                            backgroundMusic.volume = currentVolume;
                        }, 2000 / fadeSteps); // 2000ms / 60 steps
                    }).catch(error => {
                        console.warn('HTML audio failed to play:', error);
                    });
                }
                
                // Use slower fade-out for game logo
                welcomeOverlay.classList.add('fade-out-slow');
                requestDeviceMotionPermission();
                document.body.classList.add('ui-on');
                
                // Add extra 1 second delay before game view fade-in for cleaner appearance
                setTimeout(() => {
                    app.view.classList.add('is-visible');
                }, 3000); // 2s fade-out + 1s extra delay
                
                const overlayFadeDuration = 2000;
                setTimeout(() => {
                    welcomeOverlay.style.display = 'none';
                }, overlayFadeDuration);
            }

            // Developer logo click handler - skip to game logo after minimum 0.5s
            developerOverlay.addEventListener('click', () => {
                if (!developerLogoShown || gameLogoShown) return;
                
                developerClickTime = Date.now();
                const timeSinceStart = developerClickTime - (performance.timing.navigationStart || 0);
                
                // Ensure minimum 0.5s has passed before allowing skip
                if (timeSinceStart >= 500) {
                    transitionToGameLogo();
                } else {
                    setTimeout(() => {
                        transitionToGameLogo();
                    }, 500 - timeSinceStart);
                }
            });

            // Game logo click handler - only add listener after game logo is shown
            function setupGameLogoClickHandler() {
                const playButton = document.getElementById('play-button');
                if (playButton) {
                    playButton.addEventListener('click', () => {
                        // FORCE PLAY THE MUSIC FIRST
                        const backgroundMusic = document.getElementById('background-music');
                        if (backgroundMusic) {
                            backgroundMusic.volume = 0.85;
                            backgroundMusic.play().then(() => {
                                console.log('✅ Music is now playing!');
                            }).catch(error => {
                                console.error('❌ Failed to play music:', error);
                            });
                        }
                        beginExperience();
                    }, { once: true });
                }
                // Remove listener from the whole overlay to require a specific button press
                welcomeOverlay.removeEventListener('click', beginExperience);
            }

            setupAudio();
            startDeveloperLogoSequence();

            volumeSlider.addEventListener('input', (e) => {
                if (!soundModule) return;
                const value = parseFloat(e.target.value);
                if (!Number.isNaN(value)) {
                    soundModule.setMasterVolume(value);
                }
            });

            // --- CONTROLES DE FÍSICA ---
            let dynamicStiffness = 0.0085, dynamicDamping = 0.800, dynamicImpulseMultiplier = 0.225, dynamicGravityPull = 1.42, dynamicOrbitalImpulse = 0.135, dynamicRetractionForce = 4.04;
            let dynamicMaxLength = 190;
            let dynamicOvershoot = 0.976, dynamicSnapBackStrength = 0.575, dynamicCoreBrake = 0.925;
            let dynamicMinThickness = 4.6, dynamicMaxThickness = 24.3;
            let dynamicStretchScaleY = 0.544, dynamicSquashScaleX = 1.346, dynamicHitVibration = 0.795, dynamicRotationThreshold = 8.1;
            let dynamicEnemyHealth = 1, dynamicCriticalSpeed = 4.3, dynamicCritVibrationMultiplier = 1;
            let dynamicSlowMoStrength = 0.04, dynamicSlowMoDuration = 40, dynamicCameraZoom = 1.02, dynamicSplashAmount = 65;
            let dynamicTrailDuration = 24, dynamicTrailSize = 7.1;
            let mobileAccelerometerMultiplier = 2.0; // Start with a more sensible default
            let mobileDeadzone = 0.2, invertX = false, invertY = true;
            let mobileControlMode = 'joystick'; // 'accelerometer' or 'joystick'
            
            // Joystick state
            let joystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, handle: null, base: null, radius: 0 };
            function updateCoreStatus() {
                if (!coreStatusText) return;
                const reach = Math.max(1, dynamicMaxLength);
                const radius = Math.max(0, currentCoreRadius);
                const ratio = (radius / reach) * 100;
                const percentage = Math.round(Math.max(0, Math.min(999, ratio)));
                coreStatusText.textContent = `Nucleo: ${Math.round(radius)} / ${Math.round(reach)} (${percentage}%)`;
            }


            function setupDraggableInput(inputId, variableSetter, precision, sensitivity) {
                const input = document.getElementById(inputId);
                input.addEventListener('change', (e) => { let value = parseFloat(e.target.value); if (isNaN(value)) { value = 0; } variableSetter(value); e.target.value = value.toFixed(precision); });
                let isDragging = false, startX = 0, startValue = 0;
                input.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX; startValue = parseFloat(input.value); document.body.style.cursor = 'ew-resize'; input.style.pointerEvents = 'none'; e.preventDefault(); });
                window.addEventListener('mousemove', (e) => { if (!isDragging) return; const deltaX = e.clientX - startX; const newValue = startValue + (deltaX * sensitivity); input.value = newValue.toFixed(precision); variableSetter(newValue); });
                window.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; document.body.style.cursor = 'default'; input.style.pointerEvents = 'auto'; } });
            }

            setupDraggableInput('stiffness-value', (v) => dynamicStiffness = v, 3, 0.0001);
            setupDraggableInput('damping-value', (v) => dynamicDamping = v, 3, 0.001);
            setupDraggableInput('impulse-value', (v) => dynamicImpulseMultiplier = v, 1, 0.005);
            setupDraggableInput('gravity-value', (v) => dynamicGravityPull = v, 2, 0.01);
            setupDraggableInput('orbital-impulse-value', (v) => dynamicOrbitalImpulse = v, 2, 0.001);
            setupDraggableInput('retraction-value', (v) => dynamicRetractionForce = v, 2, 0.02);
            setupDraggableInput('max-length-value', (v) => { dynamicMaxLength = v; updateCoreStatus(); }, 0, 1);
            setupDraggableInput('overshoot-value', (v) => dynamicOvershoot = v, 2, 0.001);
            setupDraggableInput('snap-back-value', (v) => dynamicSnapBackStrength = v, 2, 0.005);
            setupDraggableInput('core-brake-value', (v) => dynamicCoreBrake = v, 2, 0.001);
            setupDraggableInput('min-thickness-value', (v) => dynamicMinThickness = v, 1, 0.1);
            setupDraggableInput('max-thickness-value', (v) => dynamicMaxThickness = v, 1, 0.1);
            setupDraggableInput('stretch-y-value', (v) => dynamicStretchScaleY = v, 2, 0.002);
            setupDraggableInput('squash-x-value', (v) => dynamicSquashScaleX = v, 2, 0.002);
            setupDraggableInput('hit-vibration-value', (v) => dynamicHitVibration = v, 2, 0.005);
            setupDraggableInput('rotation-threshold-value', (v) => dynamicRotationThreshold = v, 1, 0.1);
            setupDraggableInput('enemy-health-value', (v) => dynamicEnemyHealth = v, 0, 0.1);
            setupDraggableInput('critical-speed-value', (v) => dynamicCriticalSpeed = v, 1, 0.1);
            setupDraggableInput('crit-vibration-value', (v) => dynamicCritVibrationMultiplier = v, 1, 0.05);
            setupDraggableInput('slow-mo-strength-value', (v) => dynamicSlowMoStrength = v, 2, 0.01);
            setupDraggableInput('slow-mo-duration-value', (v) => dynamicSlowMoDuration = v, 0, 1);
            setupDraggableInput('camera-zoom-value', (v) => dynamicCameraZoom = v, 2, 0.01);
            setupDraggableInput('splash-amount-value', (v) => dynamicSplashAmount = v, 0, 1);
            setupDraggableInput('trail-duration-value', (v) => dynamicTrailDuration = v, 0, 1);
            setupDraggableInput('trail-size-value', (v) => dynamicTrailSize = v, 1, 0.1);

            // --- MOBILE CONTROLS SETUP ---
            const mobileControlsContainer = document.getElementById('mobile-controls-container');
            const accelMultiplierInput = document.getElementById('accelerometer-multiplier-value');
            const accelMultiplierSlider = document.getElementById('accelerometer-multiplier-slider');
            const mobileImpulseInput = document.getElementById('mobile-impulse-value');
            const mobileImpulseSlider = document.getElementById('mobile-impulse-slider');
            const deadzoneInput = document.getElementById('accelerometer-deadzone-value');
            const deadzoneSlider = document.getElementById('accelerometer-deadzone-slider');
            const invertXCheckbox = document.getElementById('invert-x-axis');
            const invertYCheckbox = document.getElementById('invert-y-axis');
            const controlModeToggle = document.getElementById('control-mode-toggle');
controlModeToggle.textContent = (mobileControlMode === 'joystick') ? 'Joystick' : 'Acelerômetro';

            function setAccelMultiplier(value) {
                mobileAccelerometerMultiplier = value;
                accelMultiplierInput.value = value.toFixed(1);
                accelMultiplierSlider.value = value;
            }
            accelMultiplierInput.addEventListener('change', (e) => setAccelMultiplier(parseFloat(e.target.value)));
            accelMultiplierSlider.addEventListener('input', (e) => setAccelMultiplier(parseFloat(e.target.value)));

            function setMobileImpulse(value) {
                dynamicImpulseMultiplier = value;
                mobileImpulseInput.value = value.toFixed(2);
                mobileImpulseSlider.value = value;
                document.getElementById('impulse-value').value = value.toFixed(2); // Sync with desktop controls
            }
            mobileImpulseInput.addEventListener('change', (e) => setMobileImpulse(parseFloat(e.target.value)));
            mobileImpulseSlider.addEventListener('input', (e) => setMobileImpulse(parseFloat(e.target.value)));

            function setDeadzone(value) {
                mobileDeadzone = value;
                deadzoneInput.value = value.toFixed(1);
                deadzoneSlider.value = value;
            }
            deadzoneInput.addEventListener('change', (e) => setDeadzone(parseFloat(e.target.value)));
            deadzoneSlider.addEventListener('input', (e) => setDeadzone(parseFloat(e.target.value)));

            invertXCheckbox.addEventListener('change', (e) => invertX = e.target.checked);
            invertYCheckbox.addEventListener('change', (e) => invertY = e.target.checked);
            
            controlModeToggle.addEventListener('click', () => {
                if (mobileControlMode === 'accelerometer') {
                    mobileControlMode = 'joystick';
                    controlModeToggle.textContent = 'Joystick';
                } else {
                    mobileControlMode = 'accelerometer';
                    controlModeToggle.textContent = 'Acelerômetro';
                }
            });

            function setupJoystick() {
                // For swipe controls, listen on the canvas instead of joystick container
                // The joystick is invisible, so we use swipe gestures anywhere on screen
                app.view.addEventListener('touchstart', (e) => {
                    if (mobileControlMode !== 'joystick') return;
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    joystick.active = true;
                    joystick.startX = touch.clientX;
                    joystick.startY = touch.clientY;
                    joystick.currentX = touch.clientX;
                    joystick.currentY = touch.clientY;
                }, { passive: false });

                window.addEventListener('touchmove', (e) => {
                    if (!joystick.active || mobileControlMode !== 'joystick') return;
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    joystick.currentX = touch.clientX;
                    joystick.currentY = touch.clientY;
                }, { passive: false });

window.addEventListener('touchend', (e) => {
    if (!joystick.active || mobileControlMode !== 'joystick') return;
    joystick.active = false;
    // Clear residual motion on touch end
    motion.mx = 0;
    motion.my = 0;
});

// Handle touch cancel to avoid "stuck" input
window.addEventListener('touchcancel', (e) => {
    if (mobileControlMode !== 'joystick') return;
    joystick.active = false;
    motion.mx = 0;
    motion.my = 0;
}, { passive: true });
            }

            document.getElementById('copy-button').addEventListener('click', () => {
                const allValues = {
                    dynamicStiffness, dynamicDamping, dynamicImpulseMultiplier, dynamicGravityPull, dynamicOrbitalImpulse, dynamicRetractionForce,
                    dynamicMaxLength, dynamicOvershoot, dynamicSnapBackStrength, dynamicCoreBrake, dynamicMinThickness, dynamicMaxThickness,
                    dynamicStretchScaleY, dynamicSquashScaleX, dynamicHitVibration, dynamicRotationThreshold, dynamicEnemyHealth, dynamicCriticalSpeed,
                    dynamicCritVibrationMultiplier, dynamicSlowMoStrength, dynamicSlowMoDuration, dynamicCameraZoom, dynamicSplashAmount,
                    dynamicTrailDuration, dynamicTrailSize
                };
                const text = Object.entries(allValues).map(([key, value]) => `${key.replace('dynamic', '')}: ${value}`).join('\n');
                navigator.clipboard.writeText(text).then(() => {
                    const btn = document.getElementById('copy-button');
                    btn.textContent = 'Copiado!';
                    setTimeout(() => btn.textContent = 'Copiar', 1500);
                });
            });
            // --- FIM DOS CONTROLES DE FÍSICA ---

            let score = 0, kills = 0, currentCombo = 0, maxComboInGame = 0, backshots = 0, criticalHits = 0, isMobile = false, isPaused = false, isGameOver = false;
            let playerState = 'at_core', isReturning = false, coreHitTimer = 0, currentCoreRadius = 30, isDangerState = false;
            let center = { x: app.screen.width / 2, y: app.screen.height / 2 };
            let vibrationTimer = 0, slowMoTimer = 0, slowMoTarget = null, coreHealingTimer = 0;
            let powerUps = [];
            let activeEffects = { 
                doubleSize: 0, 
                sizeMultiplier: 1,
                scalePowerups: [], // Array to track individual scale powerups
                mirror: {
                    isActive: false,
                    timer: 0,
                    duration: 0
                },
                healing: []
            };
            let criticalMassTimer = 0, isInCriticalMass = false;

            updateCoreStatus();

            const powerUpTypes = {
                doubleSize: {
                    spawnTimer: (1 + Math.random() * 9) * 60,
                    spawnInterval: () => (1 + Math.random() * 9) * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xFFFF00).drawPolygon([-10, 0, 0, -15, 10, 0, 0, 15]).endFill();
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 2, color: 0xFFFF00 })];
                        return gfx;
                    },
                    effect: () => {
                        // Add a new scale powerup with 3-second duration and 20% size increase
                        const newPowerup = {
                            sizeIncrease: 0.2, // 20% size increase
                            duration: 3 * 60, // 3 seconds at 60fps
                            easeOutDuration: 0.4 * 60, // 0.4 seconds ease out at 60fps
                            isEasing: false
                        };
                        activeEffects.scalePowerups.push(newPowerup);
                        
                        // Recalculate total size multiplier
                        activeEffects.sizeMultiplier = 1;
                        activeEffects.scalePowerups.forEach(powerup => {
                            activeEffects.sizeMultiplier += powerup.sizeIncrease;
                        });
                    },
                    color: 0xFFFF00
                },
                ropeSize: {
                    spawnTimer: 15 * 60,
                    spawnInterval: () => 15 * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.lineStyle(5, 0xFF00FF, 1).moveTo(-12, 0).lineTo(12, 0).moveTo(0, -12).lineTo(0, 12);
                        gfx.lineStyle(2, 0x8A2BE2, 1).moveTo(-10, 0).lineTo(10, 0).moveTo(0, -10).lineTo(0, 10);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.5, color: 0xFF00FF })];
                        return gfx;
                    },
                    effect: () => {
                        dynamicMaxLength *= 1.10;
                        document.getElementById('max-length-value').value = dynamicMaxLength.toFixed(0);
                        updateCoreStatus();
                    },
                    color: 0xFF00FF
                },
                mirror: {
                    spawnTimer: 28 * 60,
                    spawnInterval: () => 30 * 60 + Math.random() * 12 * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.lineStyle(2, 0x7dfbff, 0.9).drawCircle(0, 0, 12);
                        gfx.beginFill(0x7dfbff, 0.25).drawCircle(0, 0, 8).endFill();
                        gfx.lineStyle(3, 0xffffff, 0.6).moveTo(-8, 0).lineTo(8, 0);
                        gfx.moveTo(0, -8).lineTo(0, 8);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.6, color: 0x7dfbff })];
                        return gfx;
                    },
                    effect: () => {
                        activateMirror(12 * 60);
                        createSplash(player.x, player.y, 0x7dfbff, 50);
                    },
                    color: 0x7dfbff
                }
            };

            const trailGfx = new PIXI.Graphics();
            const particlesGfx = new PIXI.Graphics();
            const healingItemsContainer = new PIXI.Container();
            const powerUpsContainer = new PIXI.Container();
            const enemyProjectilesGfx = new PIXI.Graphics();
            app.stage.addChild(trailGfx);
            app.stage.addChild(particlesGfx);
            app.stage.addChild(healingItemsContainer);
            app.stage.addChild(powerUpsContainer);
            app.stage.addChild(enemyProjectilesGfx);

            const CORE_BASE_COLOR = 0xaaaaff;
            const DART_NEAR_COLOR = 0xff6bff;
            const DART_FAR_COLOR = 0x3f1ca4;

            // Core components
            const core = new PIXI.Graphics();
            const coreCracks = new PIXI.Graphics();
            core.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 2, color: CORE_BASE_COLOR })];
            core.position.set(center.x, center.y);
            coreCracks.position.set(center.x, center.y);
            coreCracks.alpha = 1;
            app.stage.addChild(core);
            app.stage.addChild(coreCracks);
            
            const player = new PIXI.Graphics().beginFill(DART_NEAR_COLOR).moveTo(20, 0).lineTo(0, -15).lineTo(-10, 0).lineTo(0, 15).closePath().endFill();
            player.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.5, color: DART_NEAR_COLOR })];
            player.position.set(center.x, center.y);
            player.vx = 0; player.vy = 0;

            const mirrorPlayer = new PIXI.Graphics().beginFill(0x7dfbff).moveTo(20, 0).lineTo(0, -15).lineTo(-10, 0).lineTo(0, 15).closePath().endFill();
            mirrorPlayer.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.2, color: 0x7dfbff })];
            mirrorPlayer.position.set(center.x, center.y);
            mirrorPlayer.alpha = 0.85;
            mirrorPlayer.visible = false;

            const tether = new PIXI.Graphics();
            const mirrorTether = new PIXI.Graphics();
            mirrorTether.visible = false;
            app.stage.addChild(tether);
            app.stage.addChild(mirrorTether);
            app.stage.addChild(player);
            app.stage.addChild(mirrorPlayer);

            let enemies = [];
            let enemyProjectiles = [];
            let healingItems = [];
            let enemySpawnTimer = 0;
            let healingSpawnTimer = 900 + Math.random() * 600;
            let dangerWaveState = 'cooldown';
            let dangerWaveTimer = 900 + Math.random() * 600;
            let dangerWaveWarningTimer = 0;
            let dangerWaveActiveTimer = 0;
            let dangerWaveQueue = [];
            const motion = { ax: 0, ay: 0, mx: 0, my: 0 };
            // Accelerometer history for whip detection
            const accelHistory = { x: [], y: [], timestamp: [] };
            const HISTORY_SIZE = 5;
            const WHIP_THRESHOLD = 15; // Minimum acceleration change to trigger whip
            const WHIP_COOLDOWN = 30; // Frames between whip detections
            let lastWhipFrame = 0;
            let trailPoints = [];
            let particles = [];
            let previousPlayerPosition = { x: center.x, y: center.y };
            let mirrorPosition = { x: center.x, y: center.y };
            let previousMirrorPosition = { x: center.x, y: center.y };

            const enemyTypes = {
                red: {
                    color: 0xff4a4a,
                    glowColor: 0xff4a4a,
                    radius: 10,
                    getHealth: () => Math.max(1, dynamicEnemyHealth),
                    getCoreDamage: () => dynamicMaxLength * 0.10,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xff4a4a).drawCircle(0, 0, 10).endFill();
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1, color: 0xff4a4a })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.speed = 2.4;
                    },
                    update(enemy, delta) {
                        const dx = core.x - enemy.gfx.x;
                        const dy = core.y - enemy.gfx.y;
                        const distance = Math.hypot(dx, dy) || 1;
                        enemy.gfx.x += (dx / distance) * enemy.speed * delta;
                        enemy.gfx.y += (dy / distance) * enemy.speed * delta;
                    },
                },
                orange: {
                    color: 0xffa64d,
                    glowColor: 0xffa64d,
                    radius: 16,
                    getHealth: () => Math.max(2, dynamicEnemyHealth * 3),
                    getCoreDamage: () => dynamicMaxLength * 0.14,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xffa64d).drawCircle(0, 0, 16).endFill();
                        gfx.lineStyle(3, 0xffd37a, 0.6).drawCircle(0, 0, 12);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.4, color: 0xffa64d })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.speed = 1.35;
                    },
                    update(enemy, delta) {
                        const dx = core.x - enemy.gfx.x;
                        const dy = core.y - enemy.gfx.y;
                        const distance = Math.hypot(dx, dy) || 1;
                        enemy.gfx.x += (dx / distance) * enemy.speed * delta;
                        enemy.gfx.y += (dy / distance) * enemy.speed * delta;
                    },
                },
                pink: {
                    color: 0xff7bd8,
                    glowColor: 0xff7bd8,
                    radius: 12,
                    getHealth: () => Math.max(2, dynamicEnemyHealth * 1.8),
                    getCoreDamage: () => dynamicMaxLength * 0.12,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xff7bd8, 0.85).drawCircle(0, 0, 12).endFill();
                        gfx.lineStyle(2, 0xffffff, 0.9).drawCircle(0, 0, 8);
                        gfx.moveTo(-4, 0).lineTo(4, 0);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 14, outerStrength: 1.2, color: 0xff7bd8 })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.data = {
                            angle: enemy.spawnAngle,
                            radius: enemy.spawnRadius,
                            inwardSpeed: 0.8,
                            angularSpeed: 0.045,
                            shootTimer: 90,
                            projectileCooldown: 120,
                        };
                    },
                    update(enemy, delta) {
                        const data = enemy.data;
                        if (!data) return;
                        data.radius = Math.max(currentCoreRadius + 40, data.radius - data.inwardSpeed * delta);
                        data.angle += data.angularSpeed * delta;
                        enemy.gfx.x = core.x + Math.cos(data.angle) * data.radius;
                        enemy.gfx.y = core.y + Math.sin(data.angle) * data.radius;
                        enemy.gfx.rotation = data.angle;
                        data.shootTimer -= delta;
                        if (data.shootTimer <= 0) {
                            createPinkArcProjectiles(enemy);
                            data.shootTimer = data.projectileCooldown;
                        }
                    },
                    onDeath(enemy) {
                        enemyProjectiles = enemyProjectiles.filter(projectile => {
                            if (projectile.ownerType !== 'pink') return true;
                            const px = projectile.x !== undefined ? projectile.x : core.x + Math.cos(projectile.angle || 0) * projectile.radius;
                            const py = projectile.y !== undefined ? projectile.y : core.y + Math.sin(projectile.angle || 0) * projectile.radius;
                            return Math.hypot(px - enemy.gfx.x, py - enemy.gfx.y) > 140;
                        });
                    },
                },
                green: {
                    color: 0x7dff88,
                    glowColor: 0x7dff88,
                    radius: 11,
                    getHealth: () => Math.max(2, dynamicEnemyHealth * 2.2),
                    getCoreDamage: (enemy) => enemy.state === 'dash' ? dynamicMaxLength * 0.22 : dynamicMaxLength * 0.16,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0x7dff88).moveTo(0, -14).lineTo(9, 10).lineTo(0, 6).lineTo(-9, 10).closePath();
                        gfx.endFill();
                        gfx.lineStyle(2, 0xc8ffd5, 0.8).moveTo(0, -14).lineTo(0, 6);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.3, color: 0x7dff88 })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.state = 'approach';
                        enemy.speed = 4.2;
                        enemy.data = {
                            chargeTimer: 120,
                            windupTint: 0xb8ffbf,
                            dashTint: 0xffffff,
                            pulseTime: 0,
                            dashSpeed: 13,
                            approachTargetRadius: Math.max(currentCoreRadius + 80, dynamicMaxLength * 0.45),
                        };
                    },
                    update(enemy, delta) {
                        const data = enemy.data;
                        const dx = core.x - enemy.gfx.x;
                        const dy = core.y - enemy.gfx.y;
                        const distance = Math.hypot(dx, dy) || 1;
                        
                        if (enemy.state === 'approach') {
                            enemy.visualBaseTint = enemy.baseColor;
                            enemy.gfx.scale.set(1, 1);
                            if (distance > data.approachTargetRadius) {
                                enemy.gfx.x += (dx / distance) * enemy.speed * delta;
                                enemy.gfx.y += (dy / distance) * enemy.speed * delta;
                            } else {
                                enemy.state = 'charge';
                                data.chargeTimer = 120;
                                data.pulseTime = 0;
                                data.blinkTimer = 0;
                                data.squashTimer = 0;
                            }
                        } else if (enemy.state === 'charge') {
                            data.chargeTimer -= delta;
                            data.blinkTimer += delta;
                            data.squashTimer += delta;
                            
                            // Blinking effect - faster as we approach dash
                            const blinkSpeed = 0.15 + (1 - data.chargeTimer / 120) * 0.25; // Speed up over time
                            const blinkPhase = Math.sin(data.blinkTimer * blinkSpeed);
                            const isBlinking = blinkPhase > 0.3; // Visible most of the time, brief blinks
                            
                            if (isBlinking) {
                                enemy.visualBaseTint = 0xffffff; // Bright white blink
                                enemy.gfx.filters[0].color = 0xffffff;
                                enemy.gfx.filters[0].outerStrength = 2.5;
                            } else {
                                enemy.visualBaseTint = data.windupTint;
                                enemy.gfx.filters[0].color = 0x7dff88;
                                enemy.gfx.filters[0].outerStrength = 1.3;
                            }
                            
                            // Elasticity - squash and stretch animation
                            const squashProgress = data.squashTimer / 120; // 0 to 1 over charge time
                            const elasticPhase = Math.sin(squashProgress * Math.PI * 3) * (1 - squashProgress); // Dampening oscillation
                            
                            // Squash effect (compress horizontally, stretch vertically)
                            const squashAmount = 0.3 * elasticPhase;
                            const scaleX = 1 - squashAmount;
                            const scaleY = 1 + squashAmount * 0.5;
                            
                            // Final stretch before dash
                            if (data.chargeTimer <= 30) {
                                const stretchProgress = (30 - data.chargeTimer) / 30;
                                const stretchX = 1 + stretchProgress * 0.4; // Stretch forward
                                const stretchY = 1 - stretchProgress * 0.2; // Compress vertically
                                enemy.gfx.scale.set(scaleX * stretchX, scaleY * stretchY);
                            } else {
                                enemy.gfx.scale.set(scaleX, scaleY);
                            }
                            
                            if (data.chargeTimer <= 0) {
                                enemy.state = 'dash';
                                enemy.gfx.scale.set(1.2, 1.2);
                                // Reset glow for dash
                                enemy.gfx.filters[0].color = 0x7dff88;
                                enemy.gfx.filters[0].outerStrength = 1.3;
                            }
                        }
                        
                        if (enemy.state === 'dash') {
                            enemy.visualBaseTint = data.dashTint;
                            enemy.gfx.x += (dx / distance) * data.dashSpeed * delta;
                            enemy.gfx.y += (dy / distance) * data.dashSpeed * delta;
                        }
                        
                        enemy.gfx.rotation = Math.atan2(dy, dx) + Math.PI / 2;
                    },
                },
            };

            function chooseEnemyType() {
                const weights = [
                    { type: 'red', weight: 6 },
                    { type: 'orange', weight: 2 + Math.min(3, kills / 15) },
                    { type: 'pink', weight: 1 + Math.min(3, score / 800) },
                    { type: 'green', weight: 0.8 + Math.min(2.5, currentCombo / 8) },
                ];
                const total = weights.reduce((sum, entry) => sum + entry.weight, 0);
                let roll = Math.random() * total;
                for (const entry of weights) {
                    roll -= entry.weight;
                    if (roll <= 0) {
                        return entry.type;
                    }
                }
                return 'red';
            }

            const MAX_PINK_PROJECTILES = 42;

            function createPinkArcProjectiles(enemy) {
                const existing = enemyProjectiles.filter(p => p.ownerType === 'pink').length;
                if (existing > MAX_PINK_PROJECTILES) {
                    return;
                }
                const data = enemy.data || {};
                const baseRadius = Math.max(currentCoreRadius + 40, data.radius - 15);
                const count = 8;
                const arcSpread = Math.PI / 4.5; // Tighter arc spread for closer projectiles
                const startAngle = (data.angle || 0) - arcSpread / 2;
                for (let i = 0; i < count; i++) {
                    const t = count === 1 ? 0.5 : i / (count - 1);
                    const angle = startAngle + arcSpread * t;
                    
                    // Calculate frequency based on projectile size (smaller = higher pitch)
                    const projectileSize = 3 + Math.random() * 2; // Size between 3-5
                    const baseFreq = 400;
                    const sizeMultiplier = (6 - projectileSize) / 3; // Smaller size = higher multiplier
                    const frequency = baseFreq + (sizeMultiplier * 200); // Higher pitch for smaller
                    
                    enemyProjectiles.push({
                        type: 'pink',
                        ownerType: 'pink',
                        radius: baseRadius,
                        angle,
                        angularVelocity: 0.025 + Math.random() * 0.02,
                        shrinkRate: 0.04,
                        lifetime: 200,
                        color: 0xffa6ff,
                        size: projectileSize,
                        destructible: true,
                        soundFreq: frequency,
                        health: 1,
                    });
                }
            }

            const dangerWavePatterns = [
                {
                    name: 'Crimson Swarm',
                    entries: [
                        { type: 'red', count: 10, interval: 3 }
                    ]
                },
                {
                    name: 'Amber Giants',
                    entries: [
                        { type: 'orange', count: 8, interval: 6 }
                    ]
                },
                {
                    name: 'Emerald Charge',
                    entries: [
                        { type: 'green', count: 5, interval: 8 }
                    ]
                },
                {
                    name: 'Spiral Pressure',
                    entries: [
                        { type: 'pink', count: 4, interval: 10 },
                        { type: 'red', count: 6, interval: 4, initialDelay: 18 }
                    ]
                }
            ];


            
            function handleDeviceMotion(event) {
                const accel = event.acceleration;
                if (!accel) return;

                const currentTime = Date.now();
                const currentAccel = { x: accel.x || 0, y: accel.y || 0 };

                // Add to history for whip detection
                accelHistory.x.push(currentAccel.x);
                accelHistory.y.push(currentAccel.y);
                accelHistory.timestamp.push(currentTime);

                // Keep history size manageable
                if (accelHistory.x.length > HISTORY_SIZE) {
                    accelHistory.x.shift();
                    accelHistory.y.shift();
                    accelHistory.timestamp.shift();
                }

                // Detect whip gesture if we have enough history
                if (accelHistory.x.length >= 3) {
                    const recentX = accelHistory.x.slice(-3);
                    const recentY = accelHistory.y.slice(-3);
                    const recentTime = accelHistory.timestamp.slice(-3);

                    // Calculate acceleration changes (derivatives)
                    const deltaX1 = recentX[1] - recentX[0];
                    const deltaX2 = recentX[2] - recentX[1];
                    const deltaY1 = recentY[1] - recentY[0];
                    const deltaY2 = recentY[2] - recentY[1];

                    // Calculate magnitude of change (how sudden the movement is)
                    const changeMagnitude = Math.sqrt(
                        Math.pow((deltaX2 - deltaX1), 2) +
                        Math.pow((deltaY2 - deltaY1), 2)
                    );

                    // If we detect a significant whip gesture and we're in cooldown period
                    if (changeMagnitude > WHIP_THRESHOLD && (currentTime - lastWhipFrame) > WHIP_COOLDOWN) {
                        // Calculate the direction of the whip
                        const whipDirection = {
                            x: deltaX2 - deltaX1,
                            y: deltaY2 - deltaY1
                        };

                        // Normalize the direction vector
                        const whipLength = Math.sqrt(whipDirection.x * whipDirection.x + whipDirection.y * whipDirection.y);
                        if (whipLength > 0) {
                            const normalizedDirection = {
                                x: whipDirection.x / whipLength,
                                y: whipDirection.y / whipLength
                            };

                            // Apply the direction to motion with the accelerometer multiplier
                            motion.ax = normalizedDirection.x;
                            motion.ay = normalizedDirection.y;
                            lastWhipFrame = currentTime;
                        }
                    } else {
                        // No significant whip detected, use raw acceleration for subtle movements
                        motion.ax = currentAccel.x;
                        motion.ay = currentAccel.y;
                    }
                } else {
                    // Not enough history yet, use raw values
                    motion.ax = currentAccel.x;
                    motion.ay = currentAccel.y;
                }
            }
            function handleMouseMove(event) { motion.mx = event.movementX; motion.my = event.movementY; }

            function spawnPowerUp(type) {
                const powerUpData = powerUpTypes[type];
                if (!powerUpData) return;
    
                const gfx = powerUpData.createGfx();
    
                // --- New Trajectory Logic ---
                // 1. Proximity is at least the rope length.
                const semiMinor = dynamicMaxLength + (20 + Math.random() * 80) * 0.10; // Closest point of the arc, now 30% closer again.
    
                // 2. The arc is wide, ensuring it passes through the screen.
                const screenHypot = Math.hypot(app.screen.width, app.screen.height);
                const semiMajor = semiMinor + screenHypot / 2 + Math.random() * 200; // Farthest point of the arc.
    
                // 3. The orbit is rotated randomly.
                const rotation = Math.random() * Math.PI * 1.2;
    
                // 4. Determine a starting angle 'theta' that places the power-up off-screen.
                // We find the angle where the ellipse intersects a bounding box larger than the screen.
                const offscreenRadius = screenHypot / 2 + 50; // A radius safely outside the screen.
                const cosR = Math.cos(rotation);
                const sinR = Math.sin(rotation);
                // Simplified intersection check: find theta where ellipse radius is > offscreenRadius.
                // We can approximate this by starting far out on the major axis.
                const startTheta = Math.random() < 0.5 ? Math.PI : 0; // Start at one of the two far ends of the ellipse.
    
                const orbit = {
                    semiMajor,
                    semiMinor,
                    theta: startTheta,
                    direction: Math.random() < 0.5 ? -1 : 1,
                    angularSpeed: (0.012 + Math.random() * 0.006) * 0.4, // Slowed down by 30%, then another 20%
                    rotation,
                    cosR: cosR,
                    sinR: sinR,
                };
    
                // Set initial position based on the calculated off-screen start point.
                const localX = orbit.semiMajor * Math.cos(orbit.theta);
                const localY = orbit.semiMinor * Math.sin(orbit.theta);
                gfx.x = core.x + (localX * orbit.cosR - localY * orbit.sinR);
                gfx.y = core.y + (localX * orbit.sinR + localY * orbit.cosR);
    
                const powerUp = { gfx, type, data: powerUpData, orbit };
                powerUpsContainer.addChild(gfx);
                powerUps.push(powerUp);

                powerUpData.spawnTimer = powerUpData.spawnInterval();
            }


            function updatePowerUps(delta) {
                // Spawn new power-ups
                for (const type in powerUpTypes) {
                    const puType = powerUpTypes[type];
                    if (puType.spawnTimer > 0) {
                        puType.spawnTimer -= delta;
                    } else {
                        spawnPowerUp(type);
                    }
                }

                // Update existing power-ups along an elongated orbit that guarantees a reachable point
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    const orbit = powerUp.orbit;
                    if (!orbit) continue;

                    orbit.theta += orbit.direction * orbit.angularSpeed * delta;
                    if (orbit.theta > Math.PI * 2) {
                        orbit.theta -= Math.PI * 2;
                    } else if (orbit.theta < 0) {
                        orbit.theta += Math.PI * 2;
                    }

                    const cosTheta = Math.cos(orbit.theta);
                    const sinTheta = Math.sin(orbit.theta);
                    const localX = orbit.semiMajor * cosTheta;
                    const localY = orbit.semiMinor * sinTheta;
                    const rotatedX = localX * orbit.cosR - localY * orbit.sinR;
                    const rotatedY = localX * orbit.sinR + localY * orbit.cosR;

                    const originX = core.x;
                    const originY = core.y;
                    powerUp.gfx.x = originX + rotatedX;
                    powerUp.gfx.y = originY + rotatedY;

                    // Pulsing alpha effect to signal availability
                    powerUp.gfx.alpha = 0.7 + Math.sin(Date.now() / 300) * 0.3;

                    if (Math.hypot(player.x - powerUp.gfx.x, player.y - powerUp.gfx.y) < 30) {
                        powerUp.data.effect();
                        powerUpsContainer.removeChild(powerUp.gfx);
                        powerUps.splice(i, 1);
                        createSplash(player.x, player.y, powerUp.data.color, 40);
                        continue;
                    }

                    const distFromCore = Math.hypot(rotatedX, rotatedY);
                    const maxRadius = Math.max(orbit.semiMajor + 60, Math.max(app.screen.width, app.screen.height));
                    if (distFromCore > maxRadius) {
                        powerUpsContainer.removeChild(powerUp.gfx);
                        powerUps.splice(i, 1);
                    }
                }
            }



            function activateMirror(durationFrames) {
                const mirrorEffect = activeEffects.mirror;
                if (!mirrorEffect) return;

                const duration = Math.max(0, durationFrames);
                if (mirrorEffect.isActive) {
                    mirrorEffect.timer = Math.max(mirrorEffect.timer, duration);
                } else {
                    mirrorEffect.timer = duration;
                }
                mirrorEffect.duration = Math.max(mirrorEffect.timer, duration);
                mirrorEffect.isActive = true;

                mirrorPosition.x = core.x * 2 - player.x;
                mirrorPosition.y = core.y * 2 - player.y;
                previousMirrorPosition.x = mirrorPosition.x;
                previousMirrorPosition.y = mirrorPosition.y;

                mirrorPlayer.visible = true;
                mirrorTether.visible = true;
                mirrorPlayer.alpha = 0.85;
            }

            function updateMirrorEffect(delta) {
                const mirrorEffect = activeEffects.mirror;
                if (!mirrorEffect || !mirrorEffect.isActive) {
                    return;
                }

                mirrorEffect.timer -= delta;
                if (mirrorEffect.timer <= 0) {
                    mirrorEffect.isActive = false;
                    mirrorEffect.timer = 0;
                    mirrorPlayer.visible = false;
                    mirrorTether.visible = false;
                    mirrorPlayer.alpha = 0.85;
                    mirrorTether.clear();
                    mirrorPosition.x = center.x;
                    mirrorPosition.y = center.y;
                    previousMirrorPosition.x = center.x;
                    previousMirrorPosition.y = center.y;
                } else if (mirrorEffect.duration > 0) {
                    const remaining = Math.max(0, mirrorEffect.timer / mirrorEffect.duration);
                    mirrorPlayer.alpha = 0.6 + remaining * 0.25;
                }
            }

            function startGame(isMobileDetected) {
                isMobile = !!isMobileDetected;
                if (isMobile) {
                    document.body.classList.add('mobile-debug');
                    app.ticker.start();
                } else {
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                }
            }

            function requestDeviceMotionPermission() {
                const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
                const canOrient = ('ondeviceorientation' in window) || (typeof DeviceOrientationEvent !== 'undefined');
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission()
                        .then(state => {
                            if (state === 'granted') {
                                window.addEventListener('devicemotion', handleDeviceMotion);
                                startGame(true);
                            } else {
                                startGame(false);
                            }
                        })
                        .catch(() => startGame(false));
                } else if (hasTouch && canOrient) {
                    window.addEventListener('devicemotion', handleDeviceMotion);
                    startGame(true);
                } else {
                    startGame(false);
                }
            }
            permissionButton.addEventListener('click', () => { 
                permissionOverlay.classList.add('hidden'); 
                beginExperience();
            });


            function pauseGame() { 
                isPaused = true; 
                app.ticker.stop(); 
                pauseOverlay.classList.remove('hidden'); 
                if (isMobile) {
                    mobileControlsContainer.style.display = 'block';
                }
            }
            function resumeGame() { 
                if (!isMobile) { 
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                } else { 
                    isPaused = false; 
                    app.ticker.start(); 
                    pauseOverlay.classList.add('hidden'); 
                    mobileControlsContainer.style.display = 'none';
                } 
            } 
            
            document.addEventListener('pointerlockchange', () => {
                if(document.pointerLockElement === app.view){
                    document.addEventListener('mousemove', handleMouseMove, false); app.ticker.start(); isPaused = false; pauseOverlay.classList.add('hidden');
                } else { 
                    document.removeEventListener('mousemove', handleMouseMove, false); if(isGameOver || !experienceStarted) return; pauseGame();
                }
            }, false);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !isPaused && document.pointerLockElement === app.view) {
                    document.exitPointerLock();
                }
                if (e.key && e.key.toLowerCase() === 'u') {
                    // Only allow toggling if the game is running and not over
                    if (experienceStarted && !isGameOver) {
                        document.body.classList.toggle('controls-on');
                    }
                }
            });

            // Mobile pause button
            const mobilePauseButton = document.getElementById('mobile-pause-button');
            if (mobilePauseButton) {
                mobilePauseButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isGameOver && experienceStarted) {
                        if (isPaused) {
                            resumeGame();
                        } else {
                            pauseGame();
                        }
                    }
                });
            }
            resumeButton.addEventListener('click', resumeGame);
            resumeButton.addEventListener('touchstart', (e) => { e.preventDefault(); resumeGame(); });
            playAgainButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('touchstart', (e) => { e.preventDefault(); resetGame(); });
            document.getElementById('pause-return-home-button').addEventListener('click', returnToHome);
            document.getElementById('pause-return-home-button').addEventListener('touchstart', (e) => { e.preventDefault(); returnToHome(); });

            const returnHomeButton = document.getElementById('return-home-button');
            returnHomeButton.addEventListener('click', returnToHome);
            returnHomeButton.addEventListener('touchstart', (e) => { e.preventDefault(); returnToHome(); });

            function returnToHome() {
                document.exitPointerLock();
                experienceStarted = false; // Allow game to start again
                gameOverOverlay.classList.add('hidden');
                pauseOverlay.classList.add('hidden');
                resetState();
                experienceStarted = false; // Allow game to start again
                welcomeOverlay.style.display = 'flex';
                welcomeOverlay.classList.remove('fade-out-slow');
                welcomeOverlay.classList.add('show');
                document.body.classList.add('intro-active');
                document.body.classList.remove('ui-on');
                mobileControlsContainer.style.display = 'none';
                setupGameLogoClickHandler();
            }

            const stars = document.querySelectorAll('.star');
            let currentRating = 0;

            function setStars(rating) {
                stars.forEach(s => {
                    const value = parseInt(s.dataset.value);
                    if (value <= rating) {
                        s.innerHTML = '★';
                        s.classList.add('filled');
                    } else {
                        s.innerHTML = '☆';
                        s.classList.remove('filled');
                    }
                });
            }

            stars.forEach(star => {
                star.addEventListener('mouseover', () => {
                    const value = parseInt(star.dataset.value);
                    stars.forEach(s => {
                        const sValue = parseInt(s.dataset.value);
                        if (sValue <= value) {
                            s.innerHTML = '★';
                            s.classList.add('filled');
                        } else {
                            s.innerHTML = '☆';
                            s.classList.remove('filled');
                        }
                    });
                });

                star.addEventListener('mouseout', () => {
                    setStars(currentRating);
                });

                star.addEventListener('click', () => {
                    currentRating = parseInt(star.dataset.value);
                    setStars(currentRating);
                    document.getElementById('rating-thanks').classList.remove('hidden');
                });
            });

            function endGame() {
                isGameOver = true;
                app.ticker.stop();

                // Hide game elements immediately
                tether.visible = false; // Hide tether on game over screen
                player.visible = false; // Hide player dart
                core.visible = false; // Hide core
                coreCracks.visible = false; // Hide core cracks

                // Update final stats
                document.getElementById('final-kills').textContent = kills;
                document.getElementById('final-max-combo').textContent = maxComboInGame;
                document.getElementById('final-backshots').textContent = backshots;
                document.getElementById('final-critical-hits').textContent = criticalHits;

                // Show game over overlay
                gameOverOverlay.classList.remove('hidden');
                document.body.classList.remove('ui-on'); // Hide in-game UI
                document.body.classList.remove('controls-on'); // Hide controls just in case

                // Wait 2 seconds before releasing mouse control to let game over screen fade in
                setTimeout(() => {
                    if(document.pointerLockElement === app.view) {
                        document.exitPointerLock();
                    }
                }, 2000);
            }

            function resetState() {
                score = 0; kills = 0; currentCombo = 0; maxComboInGame = 0; backshots = 0; criticalHits = 0; isPaused = false; isGameOver = false;  coreHitTimer = 0; currentCoreRadius = 30; isDangerState = false;
                comboNoteIndex = 0;
                playerState = 'at_core'; isReturning = false;
                player.tint = 0xFFFFFF;
                scoreText.textContent = `Pontuação: ${score}`;
                comboText.textContent = `Combo: x${currentCombo}`;

                // Reset critical mass state
                criticalMassTimer = 0;
                isInCriticalMass = false;
                
                // Reset screen effects
                app.view.style.filter = '';
                dangerOverlay.style.boxShadow = '';

                dangerOverlay.classList.add('hidden');
                core.filters[0].color = CORE_BASE_COLOR;
                core.filters[0].outerStrength = 2;
                dangerOverlay.classList.remove('active');
                
                // Redraw core at original size
                core.clear();
                core.beginFill(CORE_BASE_COLOR).drawCircle(0, 0, currentCoreRadius).endFill();
                core.width = core.height = currentCoreRadius * 2;
                updateCoreStatus();
                core.tint = CORE_BASE_COLOR;
                coreCracks.clear();

                enemies.forEach(e => app.stage.removeChild(e.gfx)); enemies.length = 0;
                powerUps.forEach(p => powerUpsContainer.removeChild(p.gfx)); powerUps.length = 0;
                healingItems.forEach(item => healingItemsContainer.removeChild(item.gfx)); healingItems.length = 0;
                activeEffects.doubleSize = 0;
                activeEffects.sizeMultiplier = 1; // Reset size multiplier
                activeEffects.scalePowerups = []; // Reset scale powerups array
                activeEffects.mirror.isActive = false;
                activeEffects.mirror.timer = 0;
                activeEffects.mirror.duration = 0;
                activeEffects.healing = [];
                mirrorPlayer.visible = false;
                mirrorTether.visible = false;
                mirrorTether.clear();
                mirrorPosition.x = center.x;
                mirrorPosition.y = center.y;
                previousMirrorPosition.x = center.x;
                previousMirrorPosition.y = center.y;
                mirrorPlayer.alpha = 0.85;
                coreHealingTimer = 0;
                trailPoints = []; particles = [];
                player.x = center.x; player.y = center.y; player.vx = 0; player.vy = 0;
                tether.visible = true;
                coreCracks.visible = true;
                player.visible = true;
                core.visible = true;
                healingSpawnTimer = 900 + Math.random() * 600;
                dangerWaveState = 'cooldown';
                dangerWaveTimer = 900 + Math.random() * 600;
                dangerWaveWarningTimer = 0;
                dangerWaveActiveTimer = 0;
                dangerWaveQueue = [];
                setDangerOverlayWave(false);
core.tint = CORE_BASE_COLOR;
                player.rotation = 0; player.scale.set(1);
                app.stage.scale.set(1); app.stage.position.set(0,0); app.stage.pivot.set(0,0);
                slowMoTarget = null; slowMoTimer = 0; app.ticker.speed = 1.0;
                gameOverOverlay.classList.add('hidden');
                document.getElementById('rating-thanks').classList.add('hidden');
                currentRating = 0;
                setStars(0);
            }

            function resetGame() {
                // Wait for the overlay to fully hide before starting the game to prevent immediate pause.
                // The overlay has a 0.3s transition.
                setTimeout(() => {
                    resetState();
                    document.body.classList.add('ui-on'); // Show UI for new game
                    if(!isMobile) {
                        // Request pointer lock only after the overlay is gone.
                        app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                    } else {
                        app.ticker.start();
                    }
                }, 350); // A little more than the transition duration
                if (gameOverOverlay) {
                    gameOverOverlay.classList.add('hidden');
                }
            }

            function updatePlayer() {
                if (vibrationTimer > 0) vibrationTimer--;

                // On mobile, replace mouse input with accelerometer input
                if (isMobile && !isPaused) {
                    if (mobileControlMode === 'accelerometer') {
                        let finalAccelX = motion.ax;
                        let finalAccelY = motion.ay;

                        // Apply deadzone by checking if the absolute value is less than the deadzone threshold
                        if (Math.abs(finalAccelX) < mobileDeadzone) finalAccelX = 0;
                        if (Math.abs(finalAccelY) < mobileDeadzone) finalAccelY = 0;

                        // Apply inversion from checkboxes
                        if (invertX) finalAccelX *= -1;
                        if (invertY) finalAccelY *= -1;

                        motion.mx = finalAccelX * mobileAccelerometerMultiplier;
                        motion.my = finalAccelY * mobileAccelerometerMultiplier;

                        motion.ax = 0; motion.ay = 0; // Reset accelerometer input after use
} else if (mobileControlMode === 'joystick' && joystick.active) {
    // Direction-only joystick: swipe direction = impulse direction
    const DEADZONE_PX = 12; // ignore tiny jitters
    const dx = joystick.currentX - joystick.startX;
    const dy = joystick.currentY - joystick.startY;
    const dist = Math.hypot(dx, dy);

    if (dist <= DEADZONE_PX) {
        motion.mx = 0;
        motion.my = 0;
    } else {
        const nx = dx / dist;
        const ny = dy / dist;
        // Magnitude is provided solely by dynamicImpulseMultiplier downstream
        motion.mx = nx;
        motion.my = ny;
    }
} else {
    motion.mx = 0;
    motion.my = 0;
}

                     // Set impulse from mobile slider if on mobile
                    const mobileImpulseValue = parseFloat(document.getElementById('mobile-impulse-value').value);
                    if (!isNaN(mobileImpulseValue)) {
                        dynamicImpulseMultiplier = mobileImpulseValue;
                    }
                    motion.ax = 0; motion.ay = 0; // Reset accelerometer input after use
                }

                // Use the same impulse logic for both mobile and desktop
                let impulse = (playerState === 'at_core') ? dynamicImpulseMultiplier : dynamicOrbitalImpulse;
                player.vx += motion.mx * impulse;
                player.vy += motion.my * impulse;
                motion.mx = 0; motion.my = 0;
                
                let dx = player.x - core.x, dy = player.y - core.y, dist = Math.hypot(dx, dy);
                const radialVelocity = (player.vx * dx + player.vy * dy) / (dist || 1);
                if (!isReturning && radialVelocity < 0 && dist > 50) { isReturning = true; }
                if (dist > 1) {
                    const angle = Math.atan2(dy, dx);
                    const springForce = dist * dynamicStiffness;
                    let totalReturnForce = springForce + dynamicGravityPull;
                    if (isReturning) { totalReturnForce += dynamicRetractionForce; }
                    player.vx -= Math.cos(angle) * totalReturnForce;
                    player.vy -= Math.sin(angle) * totalReturnForce;
                }
                
                player.vx *= dynamicDamping; player.vy *= dynamicDamping;
                player.x += player.vx; player.y += player.vy;

                dx = player.x - core.x; dy = player.y - core.y; dist = Math.hypot(dx, dy);
                const absoluteMaxLength = dynamicMaxLength * dynamicOvershoot;

                if (dist > dynamicMaxLength) {
                    const overshootAmount = dist - dynamicMaxLength;
                    const snapBackForce = overshootAmount * dynamicSnapBackStrength;
                    const angle = Math.atan2(dy, dx);
                    player.vx -= Math.cos(angle) * snapBackForce;
                    player.vy -= Math.sin(angle) * snapBackForce;
                }
                if (dist > absoluteMaxLength) {
                    const angle = Math.atan2(dy, dx);
                    player.x = core.x + Math.cos(angle) * absoluteMaxLength;
                    player.y = core.y + Math.sin(angle) * absoluteMaxLength;
                    const ux = dx / dist; const uy = dy / dist;
                    const velAlongRope = player.vx * ux + player.vy * uy;
                    if (velAlongRope > 0) { player.vx -= velAlongRope * ux; player.vy -= velAlongRope * uy; }
                }

                // Lógica de Estado e Aparência
                const speed = Math.hypot(player.vx, player.vy);
                if (dist > 1 && speed > dynamicRotationThreshold) { 
                    player.rotation = Math.atan2(dy, dx);
                }

                const MAX_VISUAL_SPEED = 15;
                const normalizedSpeed = Math.min(1.0, speed / MAX_VISUAL_SPEED);
                let scaleX = 1 - (1 - dynamicSquashScaleX) * normalizedSpeed;
                let scaleY = 1 + (dynamicStretchScaleY - 1) * normalizedSpeed;

                // Apply cumulative size multiplier
                if (activeEffects.sizeMultiplier > 1) {
                    scaleX *= activeEffects.sizeMultiplier;
                    scaleY *= activeEffects.sizeMultiplier;
                }

                if (vibrationTimer > 0) {
                    const vibrationAmount = (dynamicHitVibration / 15) * vibrationTimer;
                    scaleX += (Math.random() - 0.5) * vibrationAmount;
                    scaleY += (Math.random() - 0.5) * vibrationAmount;
                }
                player.scale.set(scaleX, scaleY);
                
                const vitality = Math.max(0, 1.0 - (dist / dynamicMaxLength));
                player.tint = lerpColor(DART_FAR_COLOR, DART_NEAR_COLOR, vitality);

                if (activeEffects.mirror.isActive) {
                    mirrorPosition.x = core.x * 2 - player.x;
                    mirrorPosition.y = core.y * 2 - player.y;
                    mirrorPlayer.visible = true;
                    mirrorPlayer.position.set(mirrorPosition.x, mirrorPosition.y);
                    mirrorPlayer.rotation = (player.rotation || 0) + Math.PI;
                    mirrorPlayer.scale.set(scaleX, scaleY);
                    mirrorPlayer.tint = player.tint;
                } else {
                    mirrorPlayer.visible = false;
                }

                if (playerState === 'launched') {
                     trailPoints.push({ x: player.x, y: player.y, lifetime: dynamicTrailDuration, tint: player.tint });
                     if (activeEffects.mirror.isActive) {
                        trailPoints.push({ x: mirrorPosition.x, y: mirrorPosition.y, lifetime: dynamicTrailDuration, tint: mirrorPlayer.tint });
                     }
                }

                if (playerState === 'launched' && dist < currentCoreRadius) {
                    playerState = 'at_core'; currentCombo = 0; isReturning = false;
                    comboNoteIndex = 0;
                    comboText.textContent = `Combo: x${currentCombo}`;
                    player.rotation = 0;
                } else if (playerState === 'at_core' && dist > (core.width / 2) + 5) {
                    playerState = 'launched'; isReturning = false; 
                }
                if (playerState === 'at_core') {
                    player.vx *= dynamicCoreBrake; player.vy *= dynamicCoreBrake;
                }

                // Update core visual state
                if (coreHitTimer > 0) {
                    coreHitTimer--;
                    const flash = Math.sin(coreHitTimer * 0.8) > 0; // Faster flash
                    core.tint = flash ? 0xff8888 : (isDangerState ? 0xff0000 : CORE_BASE_COLOR);
                } else {
                    core.tint = isDangerState ? 0xff0000 : CORE_BASE_COLOR;
                }

                // Update core danger state
                const wasInDanger = isDangerState;
                const isWarningState = currentCoreRadius > dynamicMaxLength * 0.9;
                isDangerState = currentCoreRadius > dynamicMaxLength; // Full danger state
                const isWaveActive = isDangerWaveOngoing();

                // Handle warning state (vignette) and wave alerts
                if ((isWarningState && !isDangerState) || isWaveActive) {
                    dangerOverlay.classList.remove('hidden');
                    if (!dangerOverlay.classList.contains('active')) dangerOverlay.classList.add('active');
                } else if (!isWarningState && !isWaveActive) {
                    dangerOverlay.classList.add('hidden');
                    dangerOverlay.classList.remove('active');
                }

                // Handle full danger state (shaking, red core)
                if (isDangerState) {
                    dangerOverlay.classList.remove('hidden'); 
                    if (!dangerOverlay.classList.contains('active')) dangerOverlay.classList.add('active');

                    core.filters[0].color = 0xff0000;
                    core.filters[0].outerStrength = 4; // More intense glow
                    if (coreHitTimer <= 0) core.tint = 0xff0000; // If not flashing, be red
                    // Add shake
                    core.position.set(center.x + (Math.random() - 0.5) * 4, center.y + (Math.random() - 0.5) * 4);
                    coreCracks.position.copyFrom(core.position);
                } else if (wasInDanger && !isDangerState && !isWaveActive && !isWarningState) { // Exited danger state
                    core.filters[0].color = CORE_BASE_COLOR;
                    core.filters[0].outerStrength = 2;
                    core.position.set(center.x, center.y); // Stop shaking
                    coreCracks.position.copyFrom(core.position);
                }

                if (!isDangerState) {
                    if (coreHealingTimer > 0) {
                        coreHealingTimer--;
                        core.filters[0].color = 0x9ff0ff;
                        core.filters[0].outerStrength = 3;
                        if (coreHitTimer <= 0) {
                            core.tint = 0x9de6ff;
                        }
                    } else if (!isWarningState && !isWaveActive && coreHitTimer <= 0) {
                        core.filters[0].color = CORE_BASE_COLOR;
                        core.filters[0].outerStrength = 2;
                        core.tint = CORE_BASE_COLOR;
                    }
                } else {
                    coreHealingTimer = 0;
                }
            }
            
            function lerpColor(start, end, t) {
                const sr = (start >> 16) & 0xff, sg = (start >> 8) & 0xff, sb = start & 0xff;
                const er = (end >> 16) & 0xff, eg = (end >> 8) & 0xff, eb = end & 0xff;
                const r = Math.round(sr + (er - sr) * t);
                const g = Math.round(sg + (eg - sg) * t);
                const b = Math.round(sb + (eb - sb) * t);
                return (r << 16) | (g << 8) | b;
            }

            function easeInOutCubic(x) { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }

            function drawTetherGraphics(gfx, targetX, targetY, endColorOverride) {
                gfx.clear();
                const dx = targetX - core.x;
                const dy = targetY - core.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 1) return;
                const normalizedDist = Math.min(1.0, dist / dynamicMaxLength);
                const easedDist = easeInOutCubic(normalizedDist);
                const thickness = dynamicMinThickness + (1 - easedDist) * (dynamicMaxThickness - dynamicMinThickness);
                const segments = 24;
                const startColor = CORE_BASE_COLOR;
                const endColor = endColorOverride !== undefined ? endColorOverride : DART_FAR_COLOR;
                for (let i = 0; i < segments; i++) {
                    const t1 = i / segments;
                    const t2 = (i + 1) / segments;
                    const color = lerpColor(startColor, endColor, t2);
                    const alpha = 0.35 + 0.45 * t2;
                    const x1 = core.x + dx * t1;
                    const y1 = core.y + dy * t1;
                    const x2 = core.x + dx * t2;
                    const y2 = core.y + dy * t2;
                    gfx.lineStyle(thickness, color, alpha).moveTo(x1, y1).lineTo(x2, y2);
                }
            }

            function updateTether() {
                drawTetherGraphics(tether, player.x, player.y);
                if (activeEffects.mirror.isActive) {
                    drawTetherGraphics(mirrorTether, mirrorPosition.x, mirrorPosition.y, 0x7dfbff);
                    mirrorTether.visible = true;
                } else {
                    mirrorTether.visible = false;
                    mirrorTether.clear();
                }
            }

            function updateTrail() {
                trailGfx.clear();
                for (let i = trailPoints.length - 1; i >= 0; i--) {
                    let point = trailPoints[i];
                    point.lifetime--;
                    const alpha = Math.max(0, point.lifetime / dynamicTrailDuration);
                    const scale = Math.max(0, point.lifetime / dynamicTrailDuration);
                    trailGfx.beginFill(point.tint, alpha * 0.5).drawCircle(point.x, point.y, dynamicTrailSize * scale).endFill();
                    if (point.lifetime <= 0) { trailPoints.splice(i, 1); }
                }
            }

            function createSplash(x, y, color, amount) {
                for (let i = 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 4;
                    particles.push({
                        x, y, color,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        lifetime: 20 + Math.random() * 20,
                        alpha: 1.0,
                    });
                }
            }

            function updateParticles() {
                particlesGfx.clear();
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx; p.y += p.vy;
                    p.vx *= 0.95; p.vy *= 0.95;
                    p.lifetime--;
                    p.alpha = Math.max(0, p.lifetime / 40);

                    particlesGfx.beginFill(p.color, p.alpha).drawCircle(p.x, p.y, 2).endFill();
                    if (p.lifetime <= 0) { particles.splice(i, 1); }
                }
            }
            
            function updateSlowMotion() {
                if (slowMoTimer > 0) {
                    slowMoTimer--;
                    const halfDuration = dynamicSlowMoDuration / 2;
                    const progress = Math.abs(slowMoTimer - halfDuration) / halfDuration;
                    const easedProgress = easeInOutCubic(1 - progress);

                    app.ticker.speed = 1.0 - (1.0 - dynamicSlowMoStrength) * easedProgress;
                    
                    const targetScale = 1 + (dynamicCameraZoom - 1) * easedProgress;
                    app.stage.scale.set(targetScale);
                    
                    let pivotX, pivotY;

                    if (slowMoTimer > halfDuration) {
                        // Phase 1: Go from center to target
                        const attackProgress = 1 - ((slowMoTimer - halfDuration) / halfDuration);
                        const easedAttackProgress = easeInOutCubic(attackProgress);
                        pivotX = center.x + (slowMoTarget.x - center.x) * easedAttackProgress;
                        pivotY = center.y + (slowMoTarget.y - center.y) * easedAttackProgress;
                    } else {
                        // Phase 2: Return from target to center
                        const returnProgress = 1 - (slowMoTimer / halfDuration);
                        const easedReturnProgress = easeInOutCubic(returnProgress);
                        pivotX = slowMoTarget.x + (center.x - slowMoTarget.x) * easedReturnProgress;
                        pivotY = slowMoTarget.y + (center.y - slowMoTarget.y) * easedReturnProgress;
                    }
                    
                    app.stage.pivot.set(pivotX, pivotY);
                    app.stage.position.set(center.x, center.y);

                } else if (app.ticker.speed !== 1.0) {
                    app.ticker.speed = 1.0;
                    app.stage.scale.set(1.0);
                    app.stage.pivot.set(0,0);
                    app.stage.position.set(0,0);
                    slowMoTarget = null;
                }
            }

            function spawnEnemy(forcedType) {
                const typeKey = forcedType || chooseEnemyType();
                const config = enemyTypes[typeKey] || enemyTypes.red;
                const gfx = config.createGfx ? config.createGfx() : new PIXI.Graphics().beginFill(config.color || 0xff4a4a).drawCircle(0, 0, config.radius || 10).endFill();
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(app.screen.width, app.screen.height) / 2 + 70;
                gfx.position.set(center.x + Math.cos(angle) * radius, center.y + Math.sin(angle) * radius);

                const baseHealth = Math.max(1, config.getHealth ? config.getHealth() : dynamicEnemyHealth);
                const enemy = {
                    type: typeKey,
                    gfx,
                    health: baseHealth,
                    maxHealth: baseHealth,
                    hitTimer: 0,
                    baseColor: config.color || 0xff4a4a,
                    visualBaseTint: config.color || 0xff4a4a,
                    collisionRadius: config.radius || 10,
                    spawnAngle: angle,
                    spawnRadius: radius,
                    state: 'default',
                    data: {},
                };

                if (!gfx.filters || gfx.filters.length === 0) {
                    const glowColor = config.glowColor || config.color || 0xff4a4a;
                    gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.1, color: glowColor })];
                }

                if (config.onSpawn) {
                    config.onSpawn(enemy);
                }

                app.stage.addChild(gfx);
                enemies.push(enemy);
            }



            function checkTrailCollision(enemy, currentPos, previousPos, hitRadius) {
                // Check collision along the trail between previous and current position
                const dx = currentPos.x - previousPos.x;
                const dy = currentPos.y - previousPos.y;
                const length = Math.hypot(dx, dy);
                
                if (length < 0.1) {
                    // If movement is minimal, just check current position
                    return Math.hypot(currentPos.x - enemy.gfx.x, currentPos.y - enemy.gfx.y) < hitRadius;
                }
                
                // Normalize the movement vector
                const stepX = dx / length;
                const stepY = dy / length;
                
                // Check multiple points along the trail
                const steps = Math.ceil(length / 10); // Check every 10 pixels along the trail
                for (let step = 0; step <= steps; step++) {
                    const t = step / steps;
                    const trailX = previousPos.x + dx * t;
                    const trailY = previousPos.y + dy * t;
                    
                    const distToEnemy = Math.hypot(trailX - enemy.gfx.x, trailY - enemy.gfx.y);
                    if (distToEnemy < hitRadius) {
                        return true;
                    }
                }
                
                return false;
            }

            function updateEnemies(delta) {
                delta = delta || 1;
                const speed = Math.hypot(player.vx, player.vy);
                const dist = Math.hypot(player.x - core.x, player.y - core.y);
                const isCritical = dist > dynamicMaxLength * 0.95 && speed > dynamicCriticalSpeed;

                const currentPos = { x: player.x, y: player.y };
                const hitRadius = 20 * activeEffects.sizeMultiplier;

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const config = enemyTypes[enemy.type] || enemyTypes.red;

                    if (config.update) {
                        config.update(enemy, delta);
                    }

                    if (!enemy.visualBaseTint) {
                        enemy.visualBaseTint = enemy.baseColor;
                    }

                    if (enemy.hitTimer > 0) {
                        enemy.hitTimer -= delta;
                        if (enemy.hitTimer < 0) enemy.hitTimer = 0;
                        const flash = Math.sin(enemy.hitTimer * 0.5) > 0;
                        enemy.gfx.tint = flash ? 0xffffff : enemy.visualBaseTint;
                    } else {
                        enemy.gfx.tint = enemy.visualBaseTint;
                    }

                    let hitSource = null;
                    if (enemy.hitTimer === 0) {
                        const hitSources = [
                            { isMirror: false, current: currentPos, previous: previousPlayerPosition }
                        ];
                        if (activeEffects.mirror.isActive) {
                            hitSources.push({
                                isMirror: true,
                                current: mirrorPosition,
                                previous: previousMirrorPosition
                            });
                        }
                        for (const source of hitSources) {
                            if (checkTrailCollision(enemy, source.current, source.previous, hitRadius)) {
                                hitSource = source;
                                break;
                            }
                        }
                    }

                    if (hitSource) {
                        if (isReturning) {
                            backshots++;
                        }
                        if (isCritical) {
                            criticalHits++;
                        }
                        
                        const damageDealt = isCritical ? 2 : 1;
                        const enemyHealthBefore = enemy.health;
                        enemy.health -= damageDealt;
                        enemy.hitTimer = 10;
                        vibrationTimer = isCritical ? 15 * dynamicCritVibrationMultiplier : 15;
                        createSplash(enemy.gfx.x, enemy.gfx.y, enemy.baseColor, dynamicSplashAmount / (isCritical ? 1 : 2));
                        
                        // DART BOUNCING: If enemy survives the hit, bounce the dart back
                        if (enemy.health > 0 && enemyHealthBefore > 0) {
                            // Calculate bounce direction (inverse of current velocity)
                            const bounceMultiplier = 0.8; // Reduce velocity slightly on bounce
                            player.vx *= -bounceMultiplier;
                            player.vy *= -bounceMultiplier;
                            
                            // Force immediate return to core
                            isReturning = true;
                            
                            // Add some visual feedback for the bounce
                            createSplash(hitSource.current.x, hitSource.current.y, 0xFFFF00, 25);
                            
                            // Play bounce sound
                            if (soundModule) {
                                soundModule.createOneShot({
                                    type: 'triangle',
                                    frequency: nearestAmFrequency(300 + Math.random() * 200),
                                    attack: 0.01,
                                    release: 0.2,
                                    duration: 0.25,
                                    volume: 0.15,
                                });
                            }
                        }
                        
                        if (isCritical && slowMoTimer <= 0) {
                            slowMoTimer = dynamicSlowMoDuration;
                            slowMoTarget = { x: enemy.gfx.x, y: enemy.gfx.y };
                        }
                        if (config.onHit) {
                            config.onHit(enemy, { isCritical });
                        }
                        
                        // CRITICAL HIT MECHANIC: Green arrow enemy instant kill during charge state
                        if (enemy.type === 'green' && enemy.state === 'charge') {
                            // Instant kill with critical hit effects
                            enemy.health = 0;
                            criticalHits++; // Count as additional critical hit
                            
                            // Enhanced visual effects for critical kill
                            createSplash(enemy.gfx.x, enemy.gfx.y, 0xFFFFFF, dynamicSplashAmount * 2);
                            createSplash(enemy.gfx.x, enemy.gfx.y, 0x7dff88, dynamicSplashAmount);
                            
                            // Play special critical kill sound
                            if (soundModule) {
                                soundModule.createOneShot({
                                    type: 'sawtooth',
                                    frequency: nearestAmFrequency(600 + Math.random() * 300),
                                    attack: 0.01,
                                    release: 0.4,
                                    duration: 0.5,
                                    volume: 0.25,
                                });
                            }
                            
                            // Force slow motion effect
                            if (slowMoTimer <= 0) {
                                slowMoTimer = dynamicSlowMoDuration * 1.5; // Longer slow mo for critical kill
                                slowMoTarget = { x: enemy.gfx.x, y: enemy.gfx.y };
                            }
                        }
                    }

                    if (enemy.health <= 0) {
                        kills++;
                        createSplash(enemy.gfx.x, enemy.gfx.y, 0xffffff, dynamicSplashAmount * 1.5);
                        playEnemyImpactSFX(isCritical, currentCombo + 1);
                        if (config.onDeath) {
                            config.onDeath(enemy);
                        }
                        app.stage.removeChild(enemy.gfx);
                        enemies.splice(i, 1);
                        currentCombo++;
                        maxComboInGame = Math.max(maxComboInGame, currentCombo);
                        score += 10 * currentCombo;
                        scoreText.textContent = `Pontuação: ${score}`;
                        comboText.textContent = `Combo: x${currentCombo}`;
                        continue;
                    }

                    const distToCore = Math.hypot(core.x - enemy.gfx.x, core.y - enemy.gfx.y);
                    if (distToCore < currentCoreRadius + enemy.collisionRadius) {
                        const damageAmount = config.getCoreDamage ? config.getCoreDamage(enemy) : dynamicMaxLength * 0.10;
                        applyCoreDamage(damageAmount, enemy.gfx.x, enemy.gfx.y, enemy.baseColor);
                        if (config.onCoreHit) {
                            config.onCoreHit(enemy);
                        }
                        app.stage.removeChild(enemy.gfx);
                        enemies.splice(i, 1);
                    }
                }
            }



            function refreshCoreVisual() {
                core.clear();
                core.beginFill(CORE_BASE_COLOR).drawCircle(0, 0, currentCoreRadius).endFill();
                core.width = core.height = currentCoreRadius * 2;
                updateCoreStatus();
            }

            function applyCoreDamage(amount, impactX, impactY, splashColor = 0xffffff) {
                coreHitTimer = 20;
                createSplash(impactX, impactY, splashColor, dynamicSplashAmount);
                playCoreDamageSFX();

                if (slowMoTimer <= 0) {
                    slowMoTimer = dynamicSlowMoDuration / 2;
                    slowMoTarget = { x: core.x, y: core.y };
                }

                currentCoreRadius += amount;
                refreshCoreVisual();
                coreCracks.alpha = Math.min(1, coreCracks.alpha + amount / (dynamicMaxLength * 0.8));

                const impactAngle = Math.atan2(impactY - core.y, impactX - core.x);
                const crackLength = currentCoreRadius * (0.4 + Math.random() * 0.3);
                const startX = Math.cos(impactAngle) * currentCoreRadius;
                const startY = Math.sin(impactAngle) * currentCoreRadius;
                coreCracks.lineStyle(1.5, 0x000000, 0.6)
                    .moveTo(startX, startY)
                    .lineTo(startX - Math.cos(impactAngle) * crackLength, startY - Math.sin(impactAngle) * crackLength);
            }


            function applyCoreHealing(amount) {
                if (amount <= 0) return;
                const previousRadius = currentCoreRadius;
                currentCoreRadius = Math.max(30, currentCoreRadius - amount);
                if (currentCoreRadius === previousRadius) {
                    return;
                }
                refreshCoreVisual();
                coreCracks.alpha = Math.max(0.25, coreCracks.alpha - amount / (dynamicMaxLength * 1.2));
            }

            function spawnHealingItem() {
                const gfx = new PIXI.Graphics();
                gfx.beginFill(0x7dfbff, 0.25).drawCircle(0, 0, 14).endFill();
                gfx.lineStyle(2, 0xdfffff, 0.85).drawCircle(0, 0, 17);
                gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.4, color: 0x7dfbff })];
            
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(app.screen.width, app.screen.height) / 2 + 70;
                gfx.position.set(center.x + Math.cos(angle) * radius, center.y + Math.sin(angle) * radius);
            
                const item = {
                    gfx,
                    speed: 1.4,
                    noisePhase: Math.random() * Math.PI * 2,
                    noiseSpeed: 0.045 + Math.random() * 0.025,
                    noiseAmplitude: 50 + Math.random() * 20
                };
                healingItemsContainer.addChild(gfx);
                healingItems.push(item);
            }
            
            function collectHealingItem(index, item, reachedCore) {
                healingItemsContainer.removeChild(item.gfx);
                healingItems.splice(index, 1);
                const healAmount = reachedCore ? dynamicMaxLength * 0.08 : dynamicMaxLength * 0.12;
                const duration = 240;
                activeEffects.healing.push({
                    amount: healAmount,
                    remaining: healAmount,
                    duration,
                    timer: duration
                });
                coreHealingTimer = Math.max(coreHealingTimer, 90);
                createSplash(item.gfx.x, item.gfx.y, 0x7dfbff, 40);
                if (typeof soundModule !== 'undefined' && soundModule && typeof soundModule.createOneShot === 'function') {
                    soundModule.createOneShot({
                        type: 'sine',
                        frequency: 420,
                        attack: 0.02,
                        release: 0.9,
                        duration: 0.8,
                        volume: 0.3
                    });
                }
            }
            
            function updateHealingItems(delta) {
                if (dangerWaveState === 'cooldown' && healingItems.length === 0) {
                    healingSpawnTimer -= delta;
                    if (healingSpawnTimer <= 0) {
                        spawnHealingItem();
                        healingSpawnTimer = 1200 + Math.random() * 720;
                    }
                }
            
                
for (let i = healingItems.length - 1; i >= 0; i--) {
                    const item = healingItems[i];
                    const dx = core.x - item.gfx.x;
                    const dy = core.y - item.gfx.y;
                    const dist = Math.hypot(dx, dy);
                    const nx = dx / (dist || 1);
                    const ny = dy / (dist || 1);
                    const perpX = -ny;
                    const perpY = nx;
            
                    item.noisePhase += item.noiseSpeed * delta;
                    const sway = Math.sin(item.noisePhase) * item.noiseAmplitude;
            
                    const move = item.speed * delta;
                    item.gfx.x += nx * move + perpX * sway * 0.02 * delta;
                    item.gfx.y += ny * move + perpY * sway * 0.02 * delta;
            
                    const bob = 0.9 + Math.sin(item.noisePhase * 2) * 0.08;
                    item.gfx.scale.set(bob, bob);
            
                    if (Math.hypot(player.x - item.gfx.x, player.y - item.gfx.y) < 28 || dist < currentCoreRadius + 8) {
                        collectHealingItem(i, item, dist < currentCoreRadius + 8);
                        continue;
                    }
            
                    const screenRadius = Math.max(app.screen.width, app.screen.height) * 1.2;
                    if (Math.hypot(item.gfx.x - center.x, item.gfx.y - center.y) > screenRadius) {
                        healingItemsContainer.removeChild(item.gfx);
                        healingItems.splice(i, 1);
                    }
                }
            }
            
            function updateHealingEffects(delta) {
                if (!activeEffects.healing.length) return;
                let totalHeal = 0;
                for (let i = activeEffects.healing.length - 1; i >= 0; i--) {
                    const effect = activeEffects.healing[i];
                    const healRate = effect.amount / effect.duration;
                    const healStep = Math.min(effect.remaining, healRate * delta);
                    effect.remaining -= healStep;
                    effect.timer -= delta;
                    totalHeal += healStep;
                    if (effect.remaining <= 0 || effect.timer <= 0) {
                        activeEffects.healing.splice(i, 1);
                    }
                }
                if (totalHeal > 0) {
                    applyCoreHealing(totalHeal);
                    coreHealingTimer = Math.max(coreHealingTimer, 60);
                }
            }
            
            function updateEnemyProjectiles(delta) {
                if (enemyProjectiles.length === 0) {
                    enemyProjectilesGfx.clear();
                    return;
                }

                delta = delta || 1;
                enemyProjectilesGfx.clear();

                const hitRadius = 18 * activeEffects.sizeMultiplier;
                const segments = [
                    { isMirror: false, current: { x: player.x, y: player.y }, previous: previousPlayerPosition }
                ];
                if (activeEffects.mirror.isActive) {
                    segments.push({
                        isMirror: true,
                        current: mirrorPosition,
                        previous: previousMirrorPosition
                    });
                }
                const tempTarget = { gfx: { x: 0, y: 0 } };

                for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                    const projectile = enemyProjectiles[i];
                    projectile.angle += (projectile.angularVelocity || 0) * delta;
                    projectile.radius = Math.max(currentCoreRadius + 25, projectile.radius - (projectile.shrinkRate || 0) * delta);
                    projectile.lifetime -= delta;

                    const px = core.x + Math.cos(projectile.angle) * projectile.radius;
                    const py = core.y + Math.sin(projectile.angle) * projectile.radius;
                    projectile.x = px;
                    projectile.y = py;

                    enemyProjectilesGfx.beginFill(projectile.color || 0xffffff, 0.9);
                    enemyProjectilesGfx.drawCircle(px, py, projectile.size || 4);
                    enemyProjectilesGfx.endFill();

                    let destroyed = false;
                    tempTarget.gfx.x = px;
                    tempTarget.gfx.y = py;

                    for (const segment of segments) {
                        if (checkTrailCollision(tempTarget, segment.current, segment.previous, hitRadius)) {
                            const splashColor = segment.isMirror ? 0x7dfbff : (projectile.color || 0xffffff);
                            createSplash(px, py, splashColor, 16);

                            // Play destruction sound for pink projectiles
                            if (projectile.destructible && projectile.soundFreq && soundModule) {
                                soundModule.createOneShot({
                                    type: 'triangle',
                                    frequency: nearestAmFrequency(projectile.soundFreq),
                                    attack: 0.01,
                                    release: 0.2,
                                    duration: 0.25,
                                    volume: 0.15,
                                });
                            }
                            
                            destroyed = true;
                            break;
                        }
                    }

                    if (!destroyed) {
                        const distToCore = Math.hypot(core.x - px, core.y - py);
                        if (distToCore < currentCoreRadius + (projectile.size || 4)) {
                            const damage = projectile.coreDamage || dynamicMaxLength * 0.05;
                            applyCoreDamage(damage, px, py, projectile.color || 0xffffff);
                            destroyed = true;
                        }
                    }

                    if (!destroyed && projectile.lifetime <= 0) {
                        destroyed = true;
                    }

                    if (destroyed) {
                        enemyProjectiles.splice(i, 1);
                    }
                }
            }

            function isDangerWaveOngoing() {
                return dangerWaveState === 'warning' || dangerWaveState === 'spawning' || dangerWaveState === 'active';
            }
            
            function chooseDangerWavePattern() {
                const available = dangerWavePatterns.filter(pattern => {
                    if (kills < 8 && pattern.entries.some(entry => entry.type === 'green')) {
                        return false;
                    }
                    if (score < 150 && pattern.entries.some(entry => entry.type === 'pink')) {
                        return false;
                    }
                    return true;
                });
                const pool = available.length ? available : dangerWavePatterns;
                return pool[Math.floor(Math.random() * pool.length)];
            }
            
            function setDangerOverlayWave(isActive) {
                if (isActive) {
                    dangerOverlay.classList.remove('hidden');
                    dangerOverlay.classList.add('active');
                    dangerOverlay.classList.add('wave-alert');
                } else {
                    dangerOverlay.classList.remove('wave-alert');
                }
            }
            
            function startDangerWave(pattern) {
                dangerWaveState = 'warning';
                dangerWaveWarningTimer = 90;
                dangerWaveQueue = pattern.entries.map(entry => ({
                    type: entry.type,
                    remaining: entry.count,
                    interval: entry.interval || 3,
                    timer: entry.initialDelay || 0,
                }));
                setDangerOverlayWave(true);
                if (typeof soundModule !== 'undefined' && soundModule && typeof soundModule.createOneShot === 'function') {
                    soundModule.createOneShot({
                        type: 'sawtooth',
                        frequency: 180,
                        attack: 0.01,
                        release: 0.6,
                        duration: 0.6,
                        volume: 0.45,
                    });
                }
            }
            
            function endDangerWave() {
                dangerWaveState = 'cooldown';
                dangerWaveTimer = 900 + Math.random() * 600;
                dangerWaveWarningTimer = 0;
                dangerWaveActiveTimer = 0;
                dangerWaveQueue = [];
                setDangerOverlayWave(false);
                healingSpawnTimer = Math.min(healingSpawnTimer, 360);
            }
            
            function updateDangerWaves(delta) {
                if (isGameOver) return;
                switch (dangerWaveState) {
                    case 'cooldown':
                        dangerWaveTimer -= delta;
                        if (dangerWaveTimer <= 0 && enemies.length <= 18) {
                            const pattern = chooseDangerWavePattern();
                            startDangerWave(pattern);
                        }
                        break;
                    case 'warning':
                        dangerWaveWarningTimer -= delta;
                        if (dangerWaveWarningTimer <= 0) {
                            dangerWaveState = 'spawning';
                        }
                        break;
                    case 'spawning':
                        let hasRemaining = false;
                        for (const entry of dangerWaveQueue) {
                            if (entry.remaining <= 0) continue;
                            entry.timer -= delta;
                            if (entry.timer <= 0) {
                                spawnEnemy(entry.type);
                                entry.remaining--;
                                entry.timer = entry.interval;
                            }
                            if (entry.remaining > 0) {
                                hasRemaining = true;
                            }
                        }
                        if (!hasRemaining) {
                            dangerWaveState = 'active';
                            dangerWaveActiveTimer = 240;
                        }
                        break;
                    case 'active':
                        dangerWaveActiveTimer -= delta;
                        if (dangerWaveActiveTimer <= 0) {
                            endDangerWave();
                        }
                        break;
                }
            }


            function updateScalePowerups(delta) {
                // Update scale powerups with smooth ease-out transition
                for (let i = activeEffects.scalePowerups.length - 1; i >= 0; i--) {
                    const powerup = activeEffects.scalePowerups[i];
                    
                    if (!powerup.isEasing) {
                        // Normal duration countdown
                        powerup.duration -= delta;
                        
                        if (powerup.duration <= 0) {
                            // Start easing out
                            powerup.isEasing = true;
                            powerup.originalSizeIncrease = powerup.sizeIncrease;
                            powerup.easeTimer = powerup.easeOutDuration;
                        }
                    } else {
                        // Easing out phase
                        powerup.easeTimer -= delta;
                        
                        if (powerup.easeTimer <= 0) {
                            // Remove powerup completely
                            activeEffects.scalePowerups.splice(i, 1);
                        } else {
                            // Smooth ease out using cubic ease
                            const progress = 1 - (powerup.easeTimer / powerup.easeOutDuration);
                            const easedProgress = easeInOutCubic(progress);
                            powerup.sizeIncrease = powerup.originalSizeIncrease * (1 - easedProgress);
                        }
                    }
                }
                
                // Recalculate total size multiplier
                activeEffects.sizeMultiplier = 1;
                activeEffects.scalePowerups.forEach(powerup => {
                    activeEffects.sizeMultiplier += powerup.sizeIncrease;
                });
            }

            function gameLoop(delta) {
                // Update debug info for mobile
                if (isMobile) {
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.innerHTML = `AX: ${motion.ax.toFixed(2)}<br>AY: ${motion.ay.toFixed(2)}<br>MX: ${motion.mx.toFixed(2)}<br>MY: ${motion.my.toFixed(2)}`;
                    }
                }

                updateSlowMotion();
                const effectiveDelta = delta * app.ticker.speed;
                updateScalePowerups(effectiveDelta);
                updatePowerUps(effectiveDelta);
                updateMirrorEffect(effectiveDelta);
                updateHealingEffects(effectiveDelta);

                // Store previous position before updating player
                previousPlayerPosition.x = player.x;
                previousPlayerPosition.y = player.y;
                if (activeEffects.mirror.isActive) {
                    previousMirrorPosition.x = core.x * 2 - player.x;
                    previousMirrorPosition.y = core.y * 2 - player.y;
                } else {
                    previousMirrorPosition.x = mirrorPosition.x;
                    previousMirrorPosition.y = mirrorPosition.y;
                }
                
                updatePlayer(effectiveDelta);
                updateTether(effectiveDelta);
                updateTrail(effectiveDelta);
                updateParticles(effectiveDelta);
                updateHealingItems(effectiveDelta);
                enemySpawnTimer += effectiveDelta;
                if (enemySpawnTimer > 60 && dangerWaveState === 'cooldown') {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
                updateEnemies(effectiveDelta);
                updateEnemyProjectiles(effectiveDelta);
                updateDangerWaves(effectiveDelta);

                // Check for critical mass explosion
                if (currentCoreRadius >= dynamicMaxLength * 1.5 && !isInCriticalMass) {
                    isInCriticalMass = true;
                    criticalMassTimer = 120; // 2 seconds at 60fps
                    
                    // Play critical mass warning sound
                    if (soundModule) {
                        soundModule.createOneShot({
                            type: 'sawtooth',
                            frequency: nearestAmFrequency(200),
                            attack: 0.1,
                            release: 2.0,
                            duration: 2.0,
                            volume: 0.4,
                        });
                    }
                }

                // Update critical mass countdown
                if (isInCriticalMass && criticalMassTimer > 0) {
                    criticalMassTimer--;
                    
                    // Dramatic increase in tension and vibration
                    const tensionLevel = (120 - criticalMassTimer) / 120; // 0 to 1 over 2 seconds
                    
                    // Intense screen shake
                    const shakeIntensity = tensionLevel * 15;
                    core.position.set(
                        center.x + (Math.random() - 0.5) * shakeIntensity,
                        center.y + (Math.random() - 0.5) * shakeIntensity
                    );
                    coreCracks.position.copyFrom(core.position);
                    
                    // Add vibration to player
                    vibrationTimer = Math.max(vibrationTimer, 30);
                    
                    // Intensify danger overlay
                    dangerOverlay.style.boxShadow = `inset 0 0 ${150 + tensionLevel * 200}px ${50 + tensionLevel * 100}px rgba(255, 0, 0, ${0.35 + tensionLevel * 0.4})`;
                    
                    // Screen fade effect as we approach explosion
                    if (criticalMassTimer <= 30) {
                        const fadeLevel = (30 - criticalMassTimer) / 30; // Last 0.5 seconds
                        app.view.style.filter = `brightness(${1 + fadeLevel * 2})`;
                    }
                    
                    // Final explosion
                    if (criticalMassTimer <= 0) {
                        startDeathSequence();
                    }
                }
            }
            app.ticker.add(gameLoop);

            function startDeathSequence() {
                if (isGameOver) return;
                isGameOver = true;
                if(document.pointerLockElement === app.view) document.exitPointerLock();

                // 1. Core explosion
                createSplash(core.x, core.y, 0xFFFFFF, 300); // Large white splash
                core.visible = false;
                coreCracks.visible = false;
                tether.visible = false;

                // 2. Shatter the dart
                player.visible = false;
                for (let i = 0; i < 15; i++) {
                    const angle = (Math.PI * 2 / 15) * i + (Math.random() - 0.5) * 0.2;
                    const speed = 1 + Math.random() * 3;
                    particles.push({
                        x: player.x, y: player.y, color: player.tint,
                        vx: Math.cos(angle) * speed + player.vx * 0.5, // Inherit some momentum
                        vy: Math.sin(angle) * speed + player.vy * 0.5,
                        lifetime: 60 + Math.random() * 60, alpha: 1.0,
                    });
                }

                // 3. Fade in game over screen after a delay
                setTimeout(endGame, 2000);
            }
            
            // Initial core draw
            core.beginFill(CORE_BASE_COLOR).drawCircle(0, 0, currentCoreRadius).endFill();
            core.width = core.height = currentCoreRadius * 2;
            updateCoreStatus();

            setupJoystick();
            app.ticker.stop();

            window.addEventListener('resize', () => {
                app.renderer.resize(window.innerWidth, window.innerHeight);
                center = { x: app.screen.width / 2, y: app.screen.height / 2 };
                core.position.set(center.x, center.y);
                const newMaxLength = 180;
                const maxLengthInput = document.getElementById('max-length-value');
                maxLengthInput.value = newMaxLength;
                dynamicMaxLength = newMaxLength;
                updateCoreStatus();
            });
        }
    </script>
</body>
</html>
