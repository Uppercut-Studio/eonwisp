<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Guardião da Etérea - Protótipo v4.7 (Controles de Rastro)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.3/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-glow@3.2.0/dist/filter-glow.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- Organized CSS Files -->
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/overlays.css">
    <link rel="stylesheet" href="css/ui.css">
    <link rel="stylesheet" href="css/controls.css">
    <link rel="stylesheet" href="css/mobile.css">
    
</style>
    <script src="js/sound-engine.js"></script>
</head>
<body>
    <div id="developer-overlay">
        <img id="developer-logo" src="developer.png" alt="Developer Logo">
    </div>
    <div id="welcome-overlay">
        <img id="welcome-logo" src="eonwisp.png" alt="Eonwisp Logo">
        <div id="play-button-container">
            <button id="play-button">
                <span style="animation-delay: 0.0s;">P</span>
                <span style="animation-delay: 0.1s;">L</span>
                <span style="animation-delay: 0.2s;">A</span>
                <span style="animation-delay: 0.3s;">Y</span>
            </button>
        </div>
    </div>
    <div id="danger-overlay" class="hidden"></div> 

    <div id="permission-overlay" class="overlay hidden">
        <h1>Guardião da Etérea</h1>
        <p>Este jogo utiliza o acelerômetro do seu dispositivo.<br>No PC, o mouse será capturado para melhor controle.</p>
        <button id="permission-button">Iniciar Jogo</button>
    </div>

    <div id="pause-overlay" class="overlay hidden">
        <img src="eonwisp.png" class="overlay-logo" alt="Eonwisp">
        <h1>Jogo Pausado</h1>
        <div class="volume-control">
            <label for="volume-slider">Volume</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1">
        </div>
        <button id="resume-button">Continuar</button>
        <button id="pause-return-home-button">Return Home</button>

        <!-- Mobile-only controls, visible inside pause menu -->
        <div id="mobile-controls-container" style="display: none; margin-top: 20px; background-color: rgba(10, 10, 20, 0.5); padding: 15px; border-radius: 10px; border-top: 1px solid #4a4a8a; width: 90%; max-width: 320px;">
            <details open>
                <summary style="color: #c58aff; font-size: 1.1em;">Calibração Móvel</summary>
                <div class="control-group-content">
                    <div class="control-item" style="margin-bottom: 20px;">
                        <label for="control-mode-toggle">Modo de Controle</label>
                        <button id="control-mode-toggle" style="background: rgba(255,255,255,0.1); border: 1px solid #8a8aff; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Acelerômetro</button>
                    </div>

                    <div class="control-item">
                        <label for="accelerometer-multiplier-value">Sensibilidade</label>
                        <input type="number" id="accelerometer-multiplier-value" class="value-input" step="0.1" value="2">
                    </div>
                    <div class="control-item" style="flex-direction: column; align-items: stretch; margin-top: 15px;">
                        <input type="range" id="accelerometer-multiplier-slider" min="0" max="10" step="0.1" value="2" style="width: 100%;">
                    </div>
                    <div class="control-item" style="margin-top: 20px;">
                        <label for="mobile-impulse-value">Impulso Base</label>
                        <input type="number" id="mobile-impulse-value" class="value-input" step="0.1" value="0.5">
                    </div>
                    <div class="control-item" style="flex-direction: column; align-items: stretch; margin-top: 15px;">
                        <input type="range" id="mobile-impulse-slider" min="0.01" max="2.0" step="0.01" value="0.5" style="width: 100%;">
                    </div>
                </div>
            </details>
            <details>
                <summary style="color: #c58aff; font-size: 1.1em;">Controles Avançados</summary>
                <div class="control-group-content">
                    <div class="control-item">
                        <label for="accelerometer-deadzone-value">Zona Morta</label>
                        <input type="number" id="accelerometer-deadzone-value" class="value-input" step="0.1" value="0.2">
                    </div>
                    <div class="control-item" style="flex-direction: column; align-items: stretch; margin-top: 15px;">
                        <input type="range" id="accelerometer-deadzone-slider" min="0" max="2" step="0.1" value="0.2" style="width: 100%;">
                    </div>
                    <div class="control-item" style="margin-top: 15px; justify-content: flex-start;">
                        <input type="checkbox" id="invert-x-axis" style="margin-right: 10px; width: 20px; height: 20px;">
                        <label for="invert-x-axis">Inverter Eixo X</label>
                    </div>
                    <div class="control-item" style="justify-content: flex-start;">
                        <input type="checkbox" id="invert-y-axis" style="margin-right: 10px; width: 20px; height: 20px;" checked>
                        <label for="invert-y-axis">Inverter Eixo Y</label>
                    </div>
                </div>
            </details>
            <details>
                <summary style="color: #c58aff; font-size: 1.1em;">Debug Info</summary>
                <div class="control-group-content">
                    <div class="control-item" style="flex-direction: column; align-items: flex-start; font-family: monospace; font-size: 12px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px;">
                        <div>Accel X: <span id="debug-ax">0.00</span></div>
                        <div>Accel Y: <span id="debug-ay">0.00</span></div>
                        <div>Motion X: <span id="debug-mx">0.00</span></div>
                        <div>Motion Y: <span id="debug-my">0.00</span></div>
                        <div>Mode: <span id="debug-mode">-</span></div>
                        <div>Touch Active: <span id="debug-touch">false</span></div>
                    </div>
                    <div class="control-item" style="margin-top: 15px;">
                        <button id="test-swipe-button" style="background: rgba(0,255,0,0.2); border: 1px solid #00ff00; color: white; padding: 10px; border-radius: 5px; cursor: pointer;">Test Swipe Launch</button>
                    </div>
                </div>
            </details>
        </div>
    </div>

    <div id="game-over-overlay" class="overlay hidden">
        <img src="eonwisp.png" class="overlay-logo" alt="Eonwisp">
        <h1>Fim de Jogo</h1>
        <div id="final-score-details">
            <p>Kills: <span id="final-kills">0</span></p>
            <p>Max Combo: <span id="final-max-combo">0</span></p>
            <p>Backshots: <span id="final-backshots">0</span></p>
            <p>Critical Hits: <span id="final-critical-hits">0</span></p>
        </div>
        <div id="rating-container">
            <p>Rate your experience:</p>
            <div class="stars">
                <span class="star" data-value="1">☆</span><span class="star" data-value="2">☆</span><span class="star" data-value="3">☆</span><span class="star" data-value="4">☆</span><span class="star" data-value="5">☆</span>
            </div>
            <p id="rating-thanks" class="hidden">Thank you for your feedback!</p>
        </div>
        <button id="play-again-button">Jogar Novamente</button>
        <button id="return-home-button">Return Home</button>
    </div>

    <div id="controls-container">
        <div class="controls-header">
            <h3>Controles de Física</h3>
            <button id="copy-button">Copiar</button>
        </div>
        <details>
            <summary>Movimento</summary>
            <div class="control-group-content">
                <div class="control-item"> <label for="impulse-value">Impulso (Mouse)</label> <input type="number" id="impulse-value" class="value-input" step="0.05" value="0.225"> </div>
                <div class="control-item"> <label for="orbital-impulse-value">Impulso em Órbita</label> <input type="number" id="orbital-impulse-value" class="value-input" step="0.01" value="0.135"> </div>
                <div class="control-item"> <label for="damping-value">Amortecimento</label> <input type="number" id="damping-value" class="value-input" step="0.005" value="0.800"> </div>
                <div class="control-item"> <label for="core-brake-value">Freio no Núcleo</label> <input type="number" id="core-brake-value" class="value-input" step="0.05" value="0.925"> </div>
            </div>
        </details>
        <details>
            <summary>Corda</summary>
            <div class="control-group-content">
                <div class="control-item"> <label for="max-length-value">Tamanho Máx.</label> <input type="number" id="max-length-value" class="value-input" step="10" value="190"> </div>
                <div class="control-item"> <label for="gravity-value">Atração Gravitacional</label> <input type="number" id="gravity-value" class="value-input" step="0.05" value="1.42"> </div>
                <div class="control-item"> <label for="retraction-value">Força de Retração</label> <input type="number" id="retraction-value" class="value-input" step="0.05" value="4.04"> </div>
                <div class="control-item"> <label for="overshoot-value">Elasticidade (%)</label> <input type="number" id="overshoot-value" class="value-input" step="0.01" value="0.976"> </div>
                <div class="control-item"> <label for="snap-back-value">Força Elástica</label> <input type="number" id="snap-back-value" class="value-input" step="0.01" value="0.575"> </div>
                <div class="control-item"> <label for="stiffness-value">Rigidez (Stiffness)</label> <input type="number" id="stiffness-value" class="value-input" step="0.001" value="0.0085"> </div>
            </div>
        </details>
        <details>
            <summary>Combate</summary>
             <div class="control-group-content">
                 <div class="control-item"> <label for="enemy-health-value">Vida Padrão (Inimigo)</label> <input type="number" id="enemy-health-value" class="value-input" step="1" value="1"> </div>
                 <div class="control-item"> <label for="critical-speed-value">Vel. Crítica Mín.</label> <input type="number" id="critical-speed-value" class="value-input" step="0.5" value="4.3"> </div>
                 <div class="control-item"> <label for="hit-vibration-value">Vibração (Impacto)</label> <input type="number" id="hit-vibration-value" class="value-input" step="0.01" value="0.795"> </div>
                 <div class="control-item"> <label for="crit-vibration-value">Multiplicador Vib. Crítica</label> <input type="number" id="crit-vibration-value" class="value-input" step="0.1" value="1"> </div>
            </div>
        </details>
        <details>
            <summary>Aparência</summary>
            <div class="control-group-content">
                 <div class="control-item"> <label for="min-thickness-value">Espessura Mín.</label> <input type="number" id="min-thickness-value" class="value-input" step="0.5" value="4.6"> </div>
                 <div class="control-item"> <label for="max-thickness-value">Espessura Máx.</label> <input type="number" id="max-thickness-value" class="value-input" step="0.5" value="24.3"> </div>
                 <div class="control-item"> <label for="stretch-y-value">Alongamento Vel. (Y)</label> <input type="number" id="stretch-y-value" class="value-input" step="0.01" value="0.544"> </div>
                 <div class="control-item"> <label for="squash-x-value">Achatar Vel. (X)</label> <input type="number" id="squash-x-value" class="value-input" step="0.01" value="1.346"> </div>
                 <div class="control-item"> <label for="rotation-threshold-value">Vel. Mín. Rotação</label> <input type="number" id="rotation-threshold-value" class="value-input" step="0.1" value="8.1"> </div>
            </div>
        </details>
        <details open>
             <summary>Efeitos</summary>
             <div class="control-group-content">
                <div class="control-item"> <label for="slow-mo-strength-value">Força do Slow-Mo</label> <input type="number" id="slow-mo-strength-value" class="value-input" step="0.01" value="0.04"> </div>
                <div class="control-item"> <label for="slow-mo-duration-value">Duração do Slow-Mo</label> <input type="number" id="slow-mo-duration-value" class="value-input" step="1" value="40"> </div>
                <div class="control-item"> <label for="camera-zoom-value">Zoom da Câmera</label> <input type="number" id="camera-zoom-value" class="value-input" step="0.05" value="1.02"> </div>
                <div class="control-item"> <label for="splash-amount-value">Qtd. Partículas (Splash)</label> <input type="number" id="splash-amount-value" class="value-input" step="1" value="65"> </div>
                <div class="control-item"> <label for="trail-duration-value">Duração do Rastro</label> <input type="number" id="trail-duration-value" class="value-input" step="1" value="24"> </div>
                <div class="control-item"> <label for="trail-size-value">Tamanho do Rastro</label> <input type="number" id="trail-size-value" class="value-input" step="0.5" value="7.1"> </div>
            </div>
        </details>
    </div>

    <div id="loading-overlay" class="overlay hidden">
        <div class="loader"></div>
        <p style="margin-top: 20px;">Carregando...</p>
    </div>

    <div id="ui-container">
        <div id="score">Pontuação: 0</div>
        <div id="combo">Combo: x0</div>
        <div id="core-status">Nucleo: 30 / 190</div>
        <div id="level-text" style="display: none; font-size: 3em; text-align: center; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);"></div>
    </div>

    <div id="mobile-pause-button">
        <div id="pause-icon"></div>
    </div>

    <div id="debug-info">
        AX: 0.00<br>
        AY: 0.00<br>
        MX: 0.00<br>
        MY: 0.00
    </div>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-handle"></div>
        </div>
    </div>

    <audio id="background-music" loop preload="auto">
        <source src="eonwisp.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Inline performance optimization system for compatibility
        class SimplePerformanceOptimizer {
            constructor() {
                this.settings = {
                    maxParticles: 100,
                    particleQuality: 1.0,
                    adaptiveQuality: true
                };
                this.isLowPerformance = false;
                this.frameCount = 0;
                this.lastFPS = 60;
                this.fpsHistory = [];
            }
            
            update(deltaTime) {
                this.frameCount++;
                if (this.frameCount % 60 === 0) { // Check every second
                    const currentFPS = 1000 / deltaTime;
                    this.fpsHistory.push(currentFPS);
                    if (this.fpsHistory.length > 10) this.fpsHistory.shift();
                    
                    const avgFPS = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
                    if (avgFPS < 45 && !this.isLowPerformance) {
                        this.isLowPerformance = true;
                        this.settings.maxParticles = 50;
                        this.settings.particleQuality = 0.7;
                        console.log('🎮 Performance: Reducing quality for better FPS');
                    } else if (avgFPS > 55 && this.isLowPerformance) {
                        this.isLowPerformance = false;
                        this.settings.maxParticles = 100;
                        this.settings.particleQuality = 1.0;
                        console.log('🎮 Performance: Restoring quality');
                    }
                }
            }
            
            createOptimizedSplash(x, y, color, amount) {
                const adjustedAmount = Math.floor(amount * this.settings.particleQuality);
                return { x, y, color, amount: adjustedAmount };
            }
            
            cleanup() {
                console.log('🎮 Performance: Resources cleaned up');
            }
        }
        
        window.onload = async function() {
            // Initialize simple performance optimization
            const performanceOptimizer = new SimplePerformanceOptimizer();
            window.performanceOptimizer = performanceOptimizer;
            document.body.classList.add('intro-active');
            const app = new PIXI.Application({
                width: window.innerWidth,
                height: window.innerHeight,
                antialias: true,
                transparent: false,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                backgroundColor: 0x0a0a1a,
            });
            document.body.appendChild(app.view);
            app.view.style.position = 'absolute';
            app.view.classList.add('game-canvas');

            const developerOverlay = document.getElementById('developer-overlay');
            const developerLogo = document.getElementById('developer-logo');
            const welcomeOverlay = document.getElementById('welcome-overlay');
            const welcomeLogo = document.getElementById('welcome-logo');
            const dangerOverlay = document.getElementById('danger-overlay');
            const scoreText = document.getElementById('score');
            const comboText = document.getElementById('combo');
            const coreStatusText = document.getElementById('core-status');
            const permissionOverlay = document.getElementById('permission-overlay');
            const permissionButton = document.getElementById('permission-button');
            const pauseOverlay = document.getElementById('pause-overlay');
            const resumeButton = document.getElementById('resume-button');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const playAgainButton = document.getElementById('play-again-button');
            const volumeSlider = document.getElementById('volume-slider');
            const controlsContainer = document.getElementById('controls-container');

            let soundModule = null;
            const AM_SCALE_FREQUENCIES = [
                110, 123.47, 130.81, 146.83, 164.81, 174.61, 196, 220,
                246.94, 261.63, 293.66, 329.63, 349.23, 392, 440, 493.88,
                523.25, 587.33, 659.25, 698.46, 783.99, 880
            ];
            let comboNoteIndex = 0;

            function nearestAmFrequency(target) {
                let closest = AM_SCALE_FREQUENCIES[0];
                let smallestDiff = Math.abs(target - closest);
                for (let i = 1; i < AM_SCALE_FREQUENCIES.length; i++) {
                    const candidate = AM_SCALE_FREQUENCIES[i];
                    const diff = Math.abs(target - candidate);
                    if (diff < smallestDiff) {
                        closest = candidate;
                        smallestDiff = diff;
                    }
                }
                return closest;
            }

            function getComboNoteFrequency(comboCount, isCritical) {
                if (comboCount <= 1) {
                    comboNoteIndex = 0;
                } else {
                    comboNoteIndex = (comboNoteIndex + 1) % AM_SCALE_FREQUENCIES.length;
                }

                let noteIndex = comboNoteIndex;

                const sizeOffset = Math.floor(Math.max(0, activeEffects.sizeMultiplier - 1) * 2);
                if (sizeOffset > 0) {
                    noteIndex = Math.max(0, noteIndex - sizeOffset);
                }

                if (isCritical) {
                    noteIndex = Math.min(AM_SCALE_FREQUENCIES.length - 1, noteIndex + 2);
                }

                return AM_SCALE_FREQUENCIES[noteIndex];
            }

            try {
                soundModule = new EonwispSoundModule({
                    bpm: 96,
                    beatsPerBar: 4,
                    masterVolume: parseFloat(volumeSlider.value),
                });
                globalThis.__EONWISP_SOUND__ = soundModule;
            } catch (error) {
                console.warn('Audio engine unavailable:', error);
            }

            let developerLogoShown = false;
            let gameLogoShown = false;
            let experienceStarted = false;
            let developerClickTime = 0;
            let themeLayerLoaded = false;
            let pendingThemeStart = false;

            function setupAudio() {
                if (!soundModule) {
                    console.warn('Audio engine not available - sound disabled');
                    return;
                }

                const initialValue = parseFloat(volumeSlider.value);
                if (!Number.isNaN(initialValue)) {
                    soundModule.setMasterVolume(initialValue, { time: 0 });
                }

                // More aggressive unlock - attach to multiple user interaction events
                soundModule.attachUnlockOn(document.body);
                soundModule.attachUnlockOn(window, ['pointerdown', 'keydown', 'touchstart']);

                // Attempt to load music layer with retry logic
                function loadMusicLayer(retryCount = 0) {
                    soundModule.registerMusicLayer('eonwisp.mp3', {
                        loop: true,
                        gain: 0.85,
                        fadeTime: 1.5,
                        bpm: 96,
                        beatsPerBar: 4
                    }).then(() => {
                        console.log('Theme music loaded successfully');
                        themeLayerLoaded = true;
                        if (pendingThemeStart) {
                            pendingThemeStart = false;
                            playThemeMusic();
                        }
                        console.log('Music should be starting now...');
                    }).catch(error => {
                        console.warn('Theme layer failed to load (attempt ' + (retryCount + 1) + '):', error);
                        if (retryCount < 2) {
                            console.log('Retrying music load in 1 second...');
                            setTimeout(() => loadMusicLayer(retryCount + 1), 1000);
                        } else {
                            console.warn('Audio failed to load after 3 attempts');
                        }
                    });
                }

                // Function to actually play the theme with fade-in from 10% to 90% volume over 2 seconds
                function playThemeMusic() {
                    if (!soundModule || !themeLayerLoaded) {
                        console.warn('Cannot play theme: sound module or theme not ready');
                        return;
                    }
                    try {
                        // Start music at 10% volume (0.1 * 0.85 = 0.085)
                        soundModule.playMusicLayer('eonwisp.mp3', {
                            startAtNextBar: false, 
                            fadeTime: 0.1, // Quick fade in to start
                            targetGain: 0.1 // Start at 10% of the intended volume
                        });
                        
                        // Fade to 90% volume over 2 seconds
                        setTimeout(() => {
                            if (soundModule && themeLayerLoaded) {
                                soundModule.setLayerMix('eonwisp.mp3', 0.9, { fadeTime: 2.0 });
                            }
                        }, 100); // Small delay to ensure music has started
                        
                        console.log('Theme music playing with fade-in');
                    } catch (error) {
                        console.error('Error playing theme music:', error);
                    }
                }

                loadMusicLayer();
            }

            function playEnemyImpactSFX(isCritical, comboCount) {
                if (!soundModule) return;

                const targetFrequency = getComboNoteFrequency(comboCount, isCritical);

                soundModule.createOneShot({
                    type: isCritical ? 'sawtooth' : 'triangle',
                    frequency: targetFrequency,
                    attack: 0.01,
                    release: 0.35,
                    duration: 0.45,
                    volume: 0.22,
                });
            }


            function playCoreDamageSFX() {
                if (!soundModule) return;

                const frequency = nearestAmFrequency(180);

                soundModule.createOneShot({
                    type: 'square',
                    frequency,
                    attack: 0.02,
                    release: 0.6,
                    duration: 0.6,
                    volume: 0.28,
                });
            }


            function startDeveloperLogoSequence() {
                if (developerLogoShown) return;
                developerLogoShown = true;
                
                console.log("🏢 Starting developer logo sequence...");
                
                // Fade in developer logo
                setTimeout(() => {
                    developerLogo.classList.add('fade-in');
                }, 500);
                
                // Auto-advance after 3 seconds if not clicked
                setTimeout(() => {
                    if (!gameLogoShown) {
                        transitionToGameLogo();
                    }
                }, 3500); // 500ms delay + 3000ms hold
            }

            function transitionToGameLogo() {
                if (gameLogoShown) return;
                gameLogoShown = true;
                
                console.log("🎮 Transitioning to game logo...");
                
                // Fade out developer overlay
                developerOverlay.classList.add('fade-out');
                
                // Show and fade in game logo
                setTimeout(() => {
                    welcomeOverlay.classList.add('show');
                    setTimeout(() => {
                        welcomeLogo.classList.add('fade-in');
                        // Only add click handler after game logo is visible
                        setupGameLogoClickHandler();
                    }, 100);
                }, 500);
                
                // Hide developer overlay completely after fade out
                setTimeout(() => {
                    developerOverlay.style.display = 'none';
                }, 1000);
            }

            function beginExperience() {
                document.body.classList.remove('intro-active');
                if (experienceStarted) return;
                experienceStarted = true;
                
                console.log("🚀 Starting game experience...");
                
                // Force audio to play from the beginning, unmuted.
                // This ensures it syncs with the game start animation.
                if (soundModule) {
                    soundModule.unlock().then(() => {
                        if (themeLayerLoaded) {
                            playThemeMusic(); // Use the same function as everywhere else
                        } else {
                            pendingThemeStart = true;
                        }
                    });
                }
                
                // Fallback HTML audio element with fade-in
                const backgroundMusic = document.getElementById('background-music');
                if (backgroundMusic) {
                    // Start at 10% volume and fade to 90% over 2 seconds
                    backgroundMusic.volume = 0.1; // Start at 10%
                    backgroundMusic.play().then(() => {
                        console.log('Background music playing via HTML audio with fade-in');
                        // Fade to 90% volume over 2 seconds
                        let currentVolume = 0.1;
                        const targetVolume = 0.9;
                        const fadeSteps = 60; // 60 steps over 2 seconds (30fps)
                        const volumeIncrement = (targetVolume - currentVolume) / fadeSteps;
                        
                        const fadeInterval = setInterval(() => {
                            currentVolume += volumeIncrement;
                            if (currentVolume >= targetVolume) {
                                currentVolume = targetVolume;
                                clearInterval(fadeInterval);
                            }
                            backgroundMusic.volume = currentVolume;
                        }, 2000 / fadeSteps); // 2000ms / 60 steps
                    }).catch(error => {
                        console.warn('HTML audio failed to play:', error);
                    });
                }
                
                // Use slower fade-out for game logo
                welcomeOverlay.classList.add('fade-out-slow');
                requestDeviceMotionPermission();
                document.body.classList.add('ui-on');
                
                // Add extra 1 second delay before game view fade-in for cleaner appearance
                setTimeout(() => {
                    app.view.classList.add('is-visible');
                }, 3000); // 2s fade-out + 1s extra delay
                
                const overlayFadeDuration = 2000;
                setTimeout(() => {
                    welcomeOverlay.style.display = 'none';
                }, overlayFadeDuration);
            }

            // Developer logo click handler - skip to game logo after minimum 0.5s
            developerOverlay.addEventListener('click', () => {
                if (!developerLogoShown || gameLogoShown) return;
                
                developerClickTime = Date.now();
                const timeSinceStart = developerClickTime - (performance.timing.navigationStart || 0);
                
                // Ensure minimum 0.5s has passed before allowing skip
                if (timeSinceStart >= 500) {
                    transitionToGameLogo();
                } else {
                    setTimeout(() => {
                        transitionToGameLogo();
                    }, 500 - timeSinceStart);
                }
            });

            // Game logo click handler - only add listener after game logo is shown
            function setupGameLogoClickHandler() {
                const playButton = document.getElementById('play-button');
                if (playButton) {
                    playButton.addEventListener('click', () => {
                        // FORCE PLAY THE MUSIC FIRST
                        const backgroundMusic = document.getElementById('background-music');
                        if (backgroundMusic) {
                            backgroundMusic.volume = 0.85;
                            backgroundMusic.play().then(() => {
                                console.log('✅ Music is now playing!');
                            }).catch(error => {
                                console.error('❌ Failed to play music:', error);
                            });
                        }
                        beginExperience();
                    }, { once: true });
                }
                // Remove listener from the whole overlay to require a specific button press
                welcomeOverlay.removeEventListener('click', beginExperience);
            }

            setupAudio();
            startDeveloperLogoSequence();

            volumeSlider.addEventListener('input', (e) => {
                if (!soundModule) return;
                const value = parseFloat(e.target.value);
                if (!Number.isNaN(value)) {
                    soundModule.setMasterVolume(value);
                }
            });

            // --- CONTROLES DE FÍSICA ---
            let dynamicStiffness = 0.0085, dynamicDamping = 0.800, dynamicImpulseMultiplier = 0.225, dynamicGravityPull = 1.42, dynamicOrbitalImpulse = 0.135, dynamicRetractionForce = 4.04;
            let dynamicMaxLength = 190;
            let dynamicOvershoot = 0.976, dynamicSnapBackStrength = 0.575, dynamicCoreBrake = 0.925;
            let dynamicMinThickness = 4.6, dynamicMaxThickness = 24.3;
            let dynamicStretchScaleY = 0.544, dynamicSquashScaleX = 1.346, dynamicHitVibration = 0.795, dynamicRotationThreshold = 8.1;
            let dynamicEnemyHealth = 1, dynamicCriticalSpeed = 4.3, dynamicCritVibrationMultiplier = 1;
            let dynamicSlowMoStrength = 0.04, dynamicSlowMoDuration = 40, dynamicCameraZoom = 1.02, dynamicSplashAmount = 65;
            let dynamicTrailDuration = 24, dynamicTrailSize = 7.1;
            let mobileAccelerometerMultiplier = 2.0; // Start with a more sensible default
            let mobileDeadzone = 0.2, invertX = false, invertY = true;
            let mobileControlMode = 'joystick'; // 'accelerometer' or 'joystick'
            
            // Joystick state
            let joystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, handle: null, base: null, radius: 0 };
            function updateCoreStatus() {
                if (!coreStatusText) return;
                const reach = Math.max(1, dynamicMaxLength);
                const radius = Math.max(0, currentCoreRadius);
                const ratio = (radius / reach) * 100;
                const percentage = Math.round(Math.max(0, Math.min(999, ratio)));
                coreStatusText.textContent = `Nucleo: ${Math.round(radius)} / ${Math.round(reach)} (${percentage}%)`;
            }


            function setupDraggableInput(inputId, variableSetter, precision, sensitivity) {
                const input = document.getElementById(inputId);
                input.addEventListener('change', (e) => { let value = parseFloat(e.target.value); if (isNaN(value)) { value = 0; } variableSetter(value); e.target.value = value.toFixed(precision); });
                let isDragging = false, startX = 0, startValue = 0;
                input.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX; startValue = parseFloat(input.value); document.body.style.cursor = 'ew-resize'; input.style.pointerEvents = 'none'; e.preventDefault(); });
                window.addEventListener('mousemove', (e) => { if (!isDragging) return; const deltaX = e.clientX - startX; const newValue = startValue + (deltaX * sensitivity); input.value = newValue.toFixed(precision); variableSetter(newValue); });
                window.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; document.body.style.cursor = 'default'; input.style.pointerEvents = 'auto'; } });
            }

            setupDraggableInput('stiffness-value', (v) => dynamicStiffness = v, 3, 0.0001);
            setupDraggableInput('damping-value', (v) => dynamicDamping = v, 3, 0.001);
            setupDraggableInput('impulse-value', (v) => dynamicImpulseMultiplier = v, 1, 0.005);
            setupDraggableInput('gravity-value', (v) => dynamicGravityPull = v, 2, 0.01);
            setupDraggableInput('orbital-impulse-value', (v) => dynamicOrbitalImpulse = v, 2, 0.001);
            setupDraggableInput('retraction-value', (v) => dynamicRetractionForce = v, 2, 0.02);
            setupDraggableInput('max-length-value', (v) => { dynamicMaxLength = v; updateCoreStatus(); }, 0, 1);
            setupDraggableInput('overshoot-value', (v) => dynamicOvershoot = v, 2, 0.001);
            setupDraggableInput('snap-back-value', (v) => dynamicSnapBackStrength = v, 2, 0.005);
            setupDraggableInput('core-brake-value', (v) => dynamicCoreBrake = v, 2, 0.001);
            setupDraggableInput('min-thickness-value', (v) => dynamicMinThickness = v, 1, 0.1);
            setupDraggableInput('max-thickness-value', (v) => dynamicMaxThickness = v, 1, 0.1);
            setupDraggableInput('stretch-y-value', (v) => dynamicStretchScaleY = v, 2, 0.002);
            setupDraggableInput('squash-x-value', (v) => dynamicSquashScaleX = v, 2, 0.002);
            setupDraggableInput('hit-vibration-value', (v) => dynamicHitVibration = v, 2, 0.005);
            setupDraggableInput('rotation-threshold-value', (v) => dynamicRotationThreshold = v, 1, 0.1);
            setupDraggableInput('enemy-health-value', (v) => dynamicEnemyHealth = v, 0, 0.1);
            setupDraggableInput('critical-speed-value', (v) => dynamicCriticalSpeed = v, 1, 0.1);
            setupDraggableInput('crit-vibration-value', (v) => dynamicCritVibrationMultiplier = v, 1, 0.05);
            setupDraggableInput('slow-mo-strength-value', (v) => dynamicSlowMoStrength = v, 2, 0.01);
            setupDraggableInput('slow-mo-duration-value', (v) => dynamicSlowMoDuration = v, 0, 1);
            setupDraggableInput('camera-zoom-value', (v) => dynamicCameraZoom = v, 2, 0.01);
            setupDraggableInput('splash-amount-value', (v) => dynamicSplashAmount = v, 0, 1);
            setupDraggableInput('trail-duration-value', (v) => dynamicTrailDuration = v, 0, 1);
            setupDraggableInput('trail-size-value', (v) => dynamicTrailSize = v, 1, 0.1);

            // --- MOBILE CONTROLS SETUP ---
            const mobileControlsContainer = document.getElementById('mobile-controls-container');
            const accelMultiplierInput = document.getElementById('accelerometer-multiplier-value');
            const accelMultiplierSlider = document.getElementById('accelerometer-multiplier-slider');
            const mobileImpulseInput = document.getElementById('mobile-impulse-value');
            const mobileImpulseSlider = document.getElementById('mobile-impulse-slider');
            const deadzoneInput = document.getElementById('accelerometer-deadzone-value');
            const deadzoneSlider = document.getElementById('accelerometer-deadzone-slider');
            const invertXCheckbox = document.getElementById('invert-x-axis');
            const invertYCheckbox = document.getElementById('invert-y-axis');
            const controlModeToggle = document.getElementById('control-mode-toggle');
            controlModeToggle.textContent = (mobileControlMode === 'joystick') ? 'Joystick' : 'Acelerômetro';

            function setAccelMultiplier(value) {
                mobileAccelerometerMultiplier = value;
                accelMultiplierInput.value = value.toFixed(1);
                accelMultiplierSlider.value = value;
            }
            accelMultiplierInput.addEventListener('change', (e) => setAccelMultiplier(parseFloat(e.target.value)));
            accelMultiplierSlider.addEventListener('input', (e) => setAccelMultiplier(parseFloat(e.target.value)));

            function setMobileImpulse(value) {
                mobileImpulseInput.value = value.toFixed(2);
                mobileImpulseSlider.value = value;
            }
            mobileImpulseInput.addEventListener('change', (e) => setMobileImpulse(parseFloat(e.target.value)));
            mobileImpulseSlider.addEventListener('input', (e) => setMobileImpulse(parseFloat(e.target.value)));

            function setDeadzone(value) {
                mobileDeadzone = value;
                deadzoneInput.value = value.toFixed(1);
                deadzoneSlider.value = value;
            }
            deadzoneInput.addEventListener('change', (e) => setDeadzone(parseFloat(e.target.value)));
            deadzoneSlider.addEventListener('input', (e) => setDeadzone(parseFloat(e.target.value)));

            invertXCheckbox.addEventListener('change', (e) => invertX = e.target.checked);
            invertYCheckbox.addEventListener('change', (e) => invertY = e.target.checked);
            
            controlModeToggle.addEventListener('click', () => {
                if (mobileControlMode === 'accelerometer') {
                    mobileControlMode = 'joystick';
                    controlModeToggle.textContent = 'Joystick';
                } else {
                    mobileControlMode = 'accelerometer';
                    controlModeToggle.textContent = 'Acelerômetro';
                }
            });

            // Add test swipe button functionality
            const testSwipeButton = document.getElementById('test-swipe-button');
            if (testSwipeButton) {
                testSwipeButton.addEventListener('click', () => {
                    // Simulate a swipe launch for testing
                    const testDirection = { x: 1, y: 0 }; // Right direction
                    const testForce = parseFloat(mobileImpulseInput.value) || 15;
                    
                    if (player) {
                        player.vx += testDirection.x * testForce;
                        player.vy += testDirection.y * testForce;
                        console.log(`Test swipe executed: force=${testForce}, direction=[1, 0]`);
                    }
                });
            }

            // Function to update debug information in pause menu
            function updateDebugInfo() {
                if (isPaused && isMobile) {
                    const debugAx = document.getElementById('debug-ax');
                    const debugAy = document.getElementById('debug-ay');
                    const debugMx = document.getElementById('debug-mx');
                    const debugMy = document.getElementById('debug-my');
                    const debugMode = document.getElementById('debug-mode');
                    const debugTouch = document.getElementById('debug-touch');
                    
                    if (debugAx) debugAx.textContent = motion.ax.toFixed(2);
                    if (debugAy) debugAy.textContent = motion.ay.toFixed(2);
                    if (debugMx) debugMx.textContent = motion.mx.toFixed(2);
                    if (debugMy) debugMy.textContent = motion.my.toFixed(2);
                    if (debugMode) debugMode.textContent = mobileControlMode;
                    if (debugTouch) debugTouch.textContent = joystick.active.toString();
                }
            }

            function setupJoystick() {
                // Swipe-to-launch controls - listen on the canvas
                app.view.addEventListener('touchstart', (e) => {
                    if (mobileControlMode !== 'joystick') return;
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    joystick.active = true;
                    joystick.startX = touch.clientX;
                    joystick.startY = touch.clientY;
                    joystick.currentX = touch.clientX;
                    joystick.currentY = touch.clientY;
                    joystick.hasLaunched = false; // Track if we've already launched this swipe
                }, { passive: false });

                window.addEventListener('touchmove', (e) => {
                    if (!joystick.active || mobileControlMode !== 'joystick') return;
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    joystick.currentX = touch.clientX;
                    joystick.currentY = touch.clientY;
                }, { passive: false });

                window.addEventListener('touchend', (e) => {
                    if (!joystick.active || mobileControlMode !== 'joystick') return;
                    e.preventDefault();
                    
                    // Calculate swipe direction and launch dart
                    const dx = joystick.currentX - joystick.startX;
                    const dy = joystick.currentY - joystick.startY;
                    const swipeDistance = Math.hypot(dx, dy);
                    const minSwipeDistance = 30; // Minimum swipe distance to register
                    
                    if (swipeDistance >= minSwipeDistance && !joystick.hasLaunched) {
                        // Normalize direction
                        const nx = dx / swipeDistance;
                        const ny = dy / swipeDistance;
                        
                        // Apply impulse based on swipe distance (more distance = more force)
                        const forceMultiplier = Math.min(swipeDistance / 100, 3); // Max 3x force
                        const baseImpulse = parseFloat(mobileImpulseInput.value) || 15;
                        const finalImpulse = baseImpulse * forceMultiplier;
                        
                        // Launch the dart
                        player.vx += nx * finalImpulse;
                        player.vy += ny * finalImpulse;
                        
                        // Mark as launched to prevent multiple launches per swipe
                        joystick.hasLaunched = true;
                        
                        console.log(`Swipe launch: distance=${swipeDistance.toFixed(0)}, force=${finalImpulse.toFixed(2)}, direction=[${nx.toFixed(2)}, ${ny.toFixed(2)}]`);
                    }
                    
                    joystick.active = false;
                    motion.mx = 0;
                    motion.my = 0;
                }, { passive: false });

                // Handle touch cancel to avoid "stuck" input
                window.addEventListener('touchcancel', (e) => {
                    if (mobileControlMode !== 'joystick') return;
                    joystick.active = false;
                    motion.mx = 0;
                    motion.my = 0;
                }, { passive: true });
            }

            document.getElementById('copy-button').addEventListener('click', () => {
                const allValues = {
                    dynamicStiffness, dynamicDamping, dynamicImpulseMultiplier, dynamicGravityPull, dynamicOrbitalImpulse, dynamicRetractionForce,
                    dynamicMaxLength, dynamicOvershoot, dynamicSnapBackStrength, dynamicCoreBrake, dynamicMinThickness, dynamicMaxThickness,
                    dynamicStretchScaleY, dynamicSquashScaleX, dynamicHitVibration, dynamicRotationThreshold, dynamicEnemyHealth, dynamicCriticalSpeed,
                    dynamicCritVibrationMultiplier, dynamicSlowMoStrength, dynamicSlowMoDuration, dynamicCameraZoom, dynamicSplashAmount,
                    dynamicTrailDuration, dynamicTrailSize
                };
                const text = Object.entries(allValues).map(([key, value]) => `${key.replace('dynamic', '')}: ${value}`).join('\n');
                navigator.clipboard.writeText(text).then(() => {
                    const btn = document.getElementById('copy-button');
                    btn.textContent = 'Copiado!';
                    setTimeout(() => btn.textContent = 'Copiar', 1500);
                });
            });
            // --- FIM DOS CONTROLES DE FÍSICA ---

            let score = 0, kills = 0, currentCombo = 0, maxComboInGame = 0, backshots = 0, criticalHits = 0, isMobile = false, isPaused = false, isGameOver = false;
            let playerState = 'at_core', isReturning = false, coreHitTimer = 0, currentCoreRadius = 30, isDangerState = false, nextHitKills = false;
            let center = { x: app.screen.width / 2, y: app.screen.height / 2 };
            let vibrationTimer = 0, slowMoTimer = 0, slowMoTarget = null, coreHealingTimer = 0;
            let powerUps = [];
            let activeEffects = {
                doubleSize: 0,
                sizeMultiplier: 1,
                scalePowerups: [], // Array to track individual scale powerups
                mirror: {
                    tier: 1,
                    tempUpgrades: [],
                },
                healing: []
            };
            const permanentEffects = {
                sizeBonus: 0,
                healingRate: 0,
                mirrorTier: 0
            };
            const collectedUpgradeHistory = new Set();
            const CORE_CHOICE_INTERVAL = 30 * 60; // 30 seconds at 60fps
            let coreChoiceTimer = 0;
            let isCoreChoiceActive = false;
            let newCoreChoices = [];
            let enemySpawnIntensity = 1;
            let enemySpawnAccumulator = 0;
            let enemySpeedMultiplier = 1;
            let coreRunCount = 0;
            let criticalMassTimer = 0, isInCriticalMass = false;

            updateCoreStatus();

            const powerUpTypes = {
                doubleSize: {
                    spawnTimer: (1 + Math.random() * 9) * 60,
                    spawnInterval: () => (1 + Math.random() * 9) * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xFFFF00).drawPolygon([-10, 0, 0, -15, 10, 0, 0, 15]).endFill();
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 2, color: 0xFFFF00 })];
                        return gfx;
                    },
                    effect: () => {
                        // Add a new scale powerup with 3-second duration and 20% size increase
                        const newPowerup = {
                            sizeIncrease: 0.2, // 20% size increase
                            duration: 3 * 60, // 3 seconds at 60fps
                            easeOutDuration: 0.4 * 60, // 0.4 seconds ease out at 60fps
                            isEasing: false
                        };
                        activeEffects.scalePowerups.push(newPowerup);
                        registerTemporaryUpgrade('size');
                        refreshSizeMultiplier();
                    },
                    color: 0xFFFF00
                },
                ropeSize: {
                    spawnTimer: 15 * 60,
                    spawnInterval: () => 15 * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.lineStyle(5, 0xFF00FF, 1).moveTo(-12, 0).lineTo(12, 0).moveTo(0, -12).lineTo(0, 12);
                        gfx.lineStyle(2, 0x8A2BE2, 1).moveTo(-10, 0).lineTo(10, 0).moveTo(0, -10).lineTo(0, 10);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.5, color: 0xFF00FF })];
                        return gfx;
                    },
                    effect: () => {
                        dynamicMaxLength *= 1.10;
                        document.getElementById('max-length-value').value = dynamicMaxLength.toFixed(0);
                        updateCoreStatus();
                    },
                    color: 0xFF00FF
                },
                mirror: {
                    spawnTimer: 28 * 60,
                    spawnInterval: () => 30 * 60 + Math.random() * 12 * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        gfx.lineStyle(2, 0x7dfbff, 0.9).drawCircle(0, 0, 12);
                        gfx.beginFill(0x7dfbff, 0.25).drawCircle(0, 0, 8).endFill();
                        gfx.lineStyle(3, 0xffffff, 0.6).moveTo(-8, 0).lineTo(8, 0);
                        gfx.moveTo(0, -8).lineTo(0, 8);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.6, color: 0x7dfbff })];
                        return gfx;
                    },
                    effect: () => {
                        registerTemporaryUpgrade('mirror');
                        activateMirror(12 * 60);
                        createSplash(player.x, player.y, 0x7dfbff, 50);
                    },
                    color: 0x7dfbff
                },
                invincibilityStar: {
                    spawnTimer: 45 * 60,
                    spawnInterval: () => 60 * 60 + Math.random() * 30 * 60,
                    createGfx: () => {
                        const gfx = new PIXI.Graphics();
                        // Create 4-tip star shape
                        const points = [];
                        const outerRadius = 14;
                        const innerRadius = 7;
                        const tips = 4;
                        
                        for (let i = 0; i < tips * 2; i++) {
                            const angle = (i * Math.PI) / tips;
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            points.push(Math.cos(angle) * radius, Math.sin(angle) * radius);
                        }
                        
                        gfx.beginFill(0xffd700, 0.9).drawPolygon(points).endFill();
                        gfx.lineStyle(2, 0xffff00, 1.0).drawPolygon(points);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 16, outerStrength: 2.5, color: 0xffd700 })];
                        return gfx;
                    },
                    effect: () => {
                        // Only spawn if player is below 50% health (rope extended more than 50%)
                        const currentRopePercent = Math.hypot(player.x - core.x, player.y - core.y) / dynamicMaxLength;
                        if (currentRopePercent < 0.5) return; // Don't activate if above 50% health
                        
                        activeEffects.invincibility = {
                            timer: 10 * 60, // 10 seconds at 60fps
                            oneHitKill: true
                        };
                        
                        // Visual effects
                        player.filters = [new PIXI.filters.GlowFilter({ distance: 20, outerStrength: 3, color: 0xffd700 })];
                        createSplash(player.x, player.y, 0xffd700, 80);
                        
                        // Sound effect
                        if (soundModule) {
                            soundModule.createOneShot({
                                type: 'sawtooth',
                                frequency: nearestAmFrequency(800),
                                attack: 0.01,
                                release: 0.8,
                                duration: 1.0,
                                volume: 0.35,
                            });
                        }
                    },
                    color: 0xffd700
                },
                bomb: {
                    spawnTimer: 120 * 60, // 2 minutes
                    spawnInterval: () => 90 * 60 + Math.random() * 60 * 60, // 1.5-2.5 minutes
                    createGfx: () => {
                        const container = new PIXI.Container();
                        
                        // Dark hole main body
                        const body = new PIXI.Graphics();
                        body.beginFill(0x000000, 0.95).drawCircle(0, 0, 18).endFill();
                        body.lineStyle(3, 0x220011, 0.8).drawCircle(0, 0, 16);
                        body.lineStyle(1, 0x440022, 0.6).drawCircle(0, 0, 12);
                        container.addChild(body);
                        
                        // Event horizon ring
                        const horizon = new PIXI.Graphics();
                        horizon.lineStyle(2, 0x660033, 0.7).drawCircle(0, 0, 22);
                        container.addChild(horizon);
                        
                        // Distortion effect (rotating inner rings)
                        const distortion = new PIXI.Graphics();
                        for (let i = 0; i < 3; i++) {
                            const radius = 8 + i * 3;
                            distortion.lineStyle(1, 0x330011, 0.4 - i * 0.1).drawCircle(0, 0, radius);
                        }
                        container.addChild(distortion);
                        
                        // Add rotation animation data
                        container.bombData = {
                            rotationSpeed: 0.05,
                            pulsePhase: 0,
                            destructionSound: null
                        };
                        
                        container.filters = [new PIXI.filters.GlowFilter({ 
                            distance: 25, 
                            outerStrength: 2, 
                            color: 0x440022,
                            innerStrength: 1
                        })];
                        
                        return container;
                    },
                    effect: () => {
                        // This will be handled in the collision detection
                        return null;
                    },
                    color: 0x440022,
                    isDestructive: true // Special flag for BOMB
                }
            };

            function registerTemporaryUpgrade(type) {
                collectedUpgradeHistory.add(type);
            }

            function refreshSizeMultiplier() {
                activeEffects.sizeMultiplier = 1 + permanentEffects.sizeBonus;
                activeEffects.scalePowerups.forEach(powerup => {
                    activeEffects.sizeMultiplier += powerup.sizeIncrease;
                });
            }

            const trailGfx = new PIXI.Graphics();
            const particlesGfx = new PIXI.Graphics();
            const healingItemsContainer = new PIXI.Container();
            const powerUpsContainer = new PIXI.Container();
            const newCoreContainer = new PIXI.Container();
            newCoreContainer.visible = false;
            const enemyProjectilesGfx = new PIXI.Graphics();
            app.stage.addChild(trailGfx);
            app.stage.addChild(particlesGfx);
            app.stage.addChild(healingItemsContainer);
            app.stage.addChild(powerUpsContainer);
            app.stage.addChild(enemyProjectilesGfx);
            app.stage.addChild(newCoreContainer);

            const CORE_BASE_COLOR = 0xaaaaff;
            const DART_NEAR_COLOR = 0xff6bff;
            const DART_FAR_COLOR = 0x3f1ca4;

            // Core components
            const core = new PIXI.Graphics();
            const coreCracks = new PIXI.Graphics();
            core.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 2, color: CORE_BASE_COLOR })];
            core.position.set(center.x, center.y);
            coreCracks.position.set(center.x, center.y);
            coreCracks.alpha = 1;
            app.stage.addChild(core);
            app.stage.addChild(coreCracks);
            
            const player = new PIXI.Graphics().beginFill(DART_NEAR_COLOR).moveTo(20, 0).lineTo(0, -15).lineTo(-10, 0).lineTo(0, 15).closePath().endFill();
            player.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.5, color: DART_NEAR_COLOR })];
            player.position.set(center.x, center.y);
            player.vx = 0; player.vy = 0;

            const tether = new PIXI.Graphics();
            app.stage.addChild(tether);
            app.stage.addChild(player);

            let enemies = [];
            let enemyProjectiles = [];
            let healingItems = [];
            let enemySpawnTimer = 0;
            let healingSpawnTimer = 900 + Math.random() * 600;
            let dangerWaveState = 'cooldown';
            let dangerWaveTimer = 900 + Math.random() * 600;
            let dangerWaveWarningTimer = 0;
            let dangerWaveActiveTimer = 0;
            let dangerWaveQueue = [];
            const motion = { ax: 0, ay: 0, mx: 0, my: 0 };
            // Accelerometer history for whip detection
            const accelHistory = { x: [], y: [], timestamp: [] };
            const HISTORY_SIZE = 5;
            const WHIP_THRESHOLD = 15; // Minimum acceleration change to trigger whip
            const WHIP_COOLDOWN = 30; // Frames between whip detections
            let lastWhipFrame = 0;
            let trailPoints = [];
            let particles = []; // Will be replaced by optimized particle system
            let previousPlayerPosition = { x: center.x, y: center.y };
            let clones = [];

            // Performance optimization: Replace individual graphics with batched rendering
            let optimizedParticles = []; // Track particles for the optimized system

            const enemyTypes = {
                red: {
                    name: 'Crimson Seeker',
                    color: 0xff4a4a,
                    glowColor: 0xff4a4a,
                    radius: 10,
                    getHealth: () => Math.max(1, dynamicEnemyHealth),
                    getCoreDamage: () => dynamicMaxLength * 0.10,
                    createGfx() {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xff4a4a).drawCircle(0, 0, 10).endFill();
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1, color: 0xff4a4a })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.speed = 2.4;
                    },
                    update(enemy, delta) {
                        const dx = core.x - enemy.gfx.x;
                        const dy = core.y - enemy.gfx.y;
                        const distance = Math.hypot(dx, dy) || 1;
                        enemy.gfx.x += (dx / distance) * enemy.speed * delta;
                        enemy.gfx.y += (dy / distance) * enemy.speed * delta;
                    }
                },
                orange: {
                    name: 'Amber Titan',
                    color: 0xffa64d,
                    glowColor: 0xffa64d,
                    radius: 16,
                    getHealth: () => Math.max(2, dynamicEnemyHealth * 3),
                    getCoreDamage: () => dynamicMaxLength * 0.14,
                    createGfx() {
                        const gfx = new PIXI.Graphics();
                        // Main body
                        gfx.beginFill(0xffa64d).drawCircle(0, 0, 16).endFill();
                        gfx.lineStyle(3, 0xffd37a, 0.6).drawCircle(0, 0, 12);
                        
                        // Shield (initially intact, facing core)
                        gfx.shield = new PIXI.Graphics();
                        gfx.shield.beginFill(0xd4941f, 0.9); // Darker orange for shield
                        gfx.shield.drawRoundedRect(-4, -20, 8, 16, 2); // Rectangular shield shape
                        gfx.shield.endFill();
                        gfx.shield.lineStyle(2, 0x8b6914, 1.0); // Dark border for shield
                        gfx.shield.drawRoundedRect(-4, -20, 8, 16, 2);
                        gfx.addChild(gfx.shield);
                        
                        // Shield crack overlay (initially invisible)
                        gfx.shieldCracks = new PIXI.Graphics();
                        gfx.shieldCracks.alpha = 0;
                        gfx.shield.addChild(gfx.shieldCracks);
                        
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.4, color: 0xffa64d })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.speed = 1.35;
                        enemy.originalSpeed = 1.35;
                        enemy.shieldHealth = 3; // Shield takes 3 hits to break
                        enemy.maxShieldHealth = 3;
                        enemy.isStunned = false;
                        enemy.stunTimer = 0;
                        enemy.isShieldBroken = false;
                    },
                    onHit(enemy, hitInfo) {
                        // Calculate hit angle relative to enemy facing direction
                        const dx = player.x - enemy.gfx.x;
                        const dy = player.y - enemy.gfx.y;
                        const hitAngle = Math.atan2(dy, dx);
                        
                        // Calculate enemy's facing direction (toward core)
                        const toCoreX = core.x - enemy.gfx.x;
                        const toCoreY = core.y - enemy.gfx.y;
                        const facingAngle = Math.atan2(toCoreY, toCoreX);
                        
                        // Calculate angle difference (side attacks are roughly 90° from front)
                        let angleDiff = Math.abs(hitAngle - facingAngle);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                        
                        const isSideAttack = angleDiff > Math.PI / 3; // Side attack if >60° from front
                        const isFrontalAttack = angleDiff <= Math.PI / 3; // Frontal attack if ≤60° from front
                        
                        if (!enemy.isShieldBroken && isFrontalAttack) {
                            // FRONTAL ATTACK - Hit the shield
                            enemy.shieldHealth--;
                            
                            // Add cracks to shield
                            const crackOverlay = enemy.gfx.shieldCracks;
                            if (crackOverlay) {
                                crackOverlay.lineStyle(1.5, 0x000000, 0.9);
                                
                                // Add crack based on current damage
                                const crackProgress = (enemy.maxShieldHealth - enemy.shieldHealth) / enemy.maxShieldHealth;
                                for (let i = 0; i < enemy.maxShieldHealth - enemy.shieldHealth; i++) {
                                    const crackAngle = (Math.random() - 0.5) * Math.PI * 0.4;
                                    const startX = (Math.random() - 0.5) * 6;
                                    const startY = -18 + Math.random() * 12;
                                    const endX = startX + Math.sin(crackAngle) * (4 + Math.random() * 4);
                                    const endY = startY + Math.cos(crackAngle) * (6 + Math.random() * 4);
                                    
                                    crackOverlay.moveTo(startX, startY);
                                    crackOverlay.lineTo(endX, endY);
                                }
                                crackOverlay.alpha = 0.8;
                            }
                            
                            // Shield visual feedback - flash and shake
                            enemy.gfx.shield.alpha = 0.6;
                            setTimeout(() => { if (enemy.gfx.shield) enemy.gfx.shield.alpha = 1.0; }, 100);
                            
                            if (enemy.shieldHealth <= 0) {
                                // Shield is broken!
                                enemy.isShieldBroken = true;
                                enemy.gfx.shield.visible = false;
                                createSplash(enemy.gfx.x, enemy.gfx.y, 0xd4941f, 30); // Shield break effect
                                
                                // Reduce enemy health so next hit kills it
                                enemy.health = 1;
                            }
                            
                            // Frontal hits don't kill immediately, only damage shield
                            return { preventDamage: !enemy.isShieldBroken };
                        } 
                        else if (isSideAttack) {
                            // SIDE ATTACK - Stun the enemy
                            if (!enemy.isStunned) {
                                enemy.isStunned = true;
                                enemy.stunTimer = 90; // 1.5 seconds at 60fps
                                enemy.speed = 0; // Stop movement
                                
                                // Lower shield visual
                                if (enemy.gfx.shield && !enemy.isShieldBroken) {
                                    enemy.gfx.shield.rotation = Math.PI / 4; // Tilt shield down
                                    enemy.gfx.shield.alpha = 0.7; // Make it more transparent
                                }
                                
                                // Visual stun effects
                                createSplash(enemy.gfx.x, enemy.gfx.y, 0xffff00, 20); // Yellow stun effect
                                enemy.gfx.tint = 0xffffaa; // Slight yellow tint while stunned
                            } else {
                                // SECOND HIT ON STUNNED ENEMY - INSTANT KILL!
                                enemy.health = 0; // Guaranteed kill
                                createSplash(enemy.gfx.x, enemy.gfx.y, 0xff0000, 50); // Big red death splash
                            }
                        }
                        
                        return { preventDamage: false };
                    },
                    update(enemy, delta) {
                        // Handle stun timer
                        if (enemy.isStunned && enemy.stunTimer > 0) {
                            enemy.stunTimer -= delta;
                            if (enemy.stunTimer <= 0) {
                                // Recover from stun
                                enemy.isStunned = false;
                                enemy.speed = enemy.originalSpeed;
                                enemy.gfx.tint = 0xffffff; // Remove stun tint
                                
                                // Restore shield position
                                if (enemy.gfx.shield && !enemy.isShieldBroken) {
                                    enemy.gfx.shield.rotation = 0;
                                    enemy.gfx.shield.alpha = 1.0;
                                }
                            }
                        }
                        
                        // Movement (only if not stunned)
                        if (!enemy.isStunned) {
                            const dx = core.x - enemy.gfx.x;
                            const dy = core.y - enemy.gfx.y;
                            const distance = Math.hypot(dx, dy) || 1;
                            enemy.gfx.x += (dx / distance) * enemy.speed * delta;
                            enemy.gfx.y += (dy / distance) * enemy.speed * delta;
                            
                            // Always face the core with shield
                            if (enemy.gfx.shield && !enemy.isShieldBroken) {
                                const shieldAngle = Math.atan2(dy, dx) - Math.PI / 2; // Shield faces core
                                enemy.gfx.shield.rotation = shieldAngle;
                            }
                        }
                    }
                },
                pink: {
                    name: 'Astral Orbiter',
                    color: 0xff7bd8,
                    glowColor: 0xff7bd8,
                    radius: 12,
                    getHealth: () => Math.max(2, dynamicEnemyHealth * 1.8),
                    getCoreDamage: () => dynamicMaxLength * 0.12,
                    createGfx() {
                        const gfx = new PIXI.Graphics();
                        gfx.beginFill(0xff7bd8, 0.85).drawCircle(0, 0, 12).endFill();
                        gfx.lineStyle(2, 0xffffff, 0.9).drawCircle(0, 0, 8);
                        gfx.moveTo(-4, 0).lineTo(4, 0);
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 14, outerStrength: 1.2, color: 0xff7bd8 })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        enemy.data = {
                            angle: enemy.spawnAngle,
                            radius: enemy.spawnRadius,
                            inwardSpeed: 0.8,
                            angularSpeed: 0.045,
                            shootTimer: 90,
                            projectileCooldown: 120,
                        };
                    },
                    update(enemy, delta) {
                        const data = enemy.data;
                        if (!data) return;
                        data.radius = Math.max(currentCoreRadius + 40, data.radius - data.inwardSpeed * delta);
                        data.angle += data.angularSpeed * delta;
                        enemy.gfx.x = core.x + Math.cos(data.angle) * data.radius;
                        enemy.gfx.y = core.y + Math.sin(data.angle) * data.radius;
                        enemy.gfx.rotation = data.angle;
                        data.shootTimer -= delta;
                        if (data.shootTimer <= 0) {
                            createPinkArcProjectiles(enemy);
                            data.shootTimer = data.projectileCooldown;
                        }
                    },
                    onDeath(enemy) {
                        enemyProjectiles = enemyProjectiles.filter(projectile => {
                            if (projectile.ownerType !== 'pink') return true;
                            const px = projectile.x !== undefined ? projectile.x : core.x + Math.cos(projectile.angle || 0) * projectile.radius;
                            const py = projectile.y !== undefined ? projectile.y : core.y + Math.sin(projectile.angle || 0) * projectile.radius;
                            return Math.hypot(px - enemy.gfx.x, py - enemy.gfx.y) > 140;
                        });
                    }
                },
                green: {
                    name: 'Emerald Bow',
                    color: 0x7dff88,
                    glowColor: 0x7dff88,
                    radius: 14,
                    getHealth: () => Math.max(2, dynamicEnemyHealth * 2.5),
                    getCoreDamage: () => dynamicMaxLength * 0.18,
                    createGfx() {
                        const gfx = new PIXI.Graphics();
                        
                        // Draw bow shape
                        gfx.lineStyle(4, 0x7dff88, 1.0);
                        // Bow arc
                        gfx.arc(0, 0, 12, -Math.PI * 0.6, Math.PI * 0.6);
                        // Bow string
                        gfx.moveTo(-8, -8).lineTo(-8, 8);
                        
                        // Ammo indicators (will be updated dynamically)
                        gfx.ammoIndicators = [];
                        for (let i = 0; i < 3; i++) {
                            const indicator = new PIXI.Graphics();
                            indicator.beginFill(0xc8ffd5).drawCircle(0, 0, 2).endFill();
                            indicator.x = -15 - (i * 5);
                            indicator.y = 0;
                            gfx.addChild(indicator);
                            gfx.ammoIndicators.push(indicator);
                        }
                        
                        gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.3, color: 0x7dff88 })];
                        return gfx;
                    },
                    onSpawn(enemy) {
                        // Calculate target position first
                        let targetDistance;
                        if (isDangerState) {
                            // In danger mode, can be anywhere
                            targetDistance = Math.max(currentCoreRadius + 60, dynamicMaxLength * 0.7);
                        } else {
                            // Normal mode - always reachable
                            targetDistance = Math.min(
                                dynamicMaxLength * 0.85, 
                                Math.max(currentCoreRadius + 50, dynamicMaxLength * 0.6)
                            );
                        }
                        
                        const targetAngle = enemy.spawnAngle;
                        const targetX = core.x + Math.cos(targetAngle) * targetDistance;
                        const targetY = core.y + Math.sin(targetAngle) * targetDistance;
                        
                        enemy.state = 'approaching';
                        enemy.speed = 2.8; // Movement speed toward target
                        
                        enemy.data = {
                            targetPosition: { x: targetX, y: targetY },
                            targetAngle: targetAngle + Math.PI, // Point toward core
                            ammoRemaining: 3,
                            shootTimer: 120,
                            brokenParts: 0,
                            isLocked: false
                        };
                    },
                    onHit(enemy, hitInfo) {
                        // Break and lose pieces when hit
                        enemy.data.brokenParts++;
                        
                        // Update visual to show damage
                        const brokenRatio = enemy.data.brokenParts / 4;
                        enemy.gfx.alpha = Math.max(0.4, 1 - brokenRatio * 0.6);
                        
                        // Lose ammo indicators
                        if (enemy.gfx.ammoIndicators && enemy.data.brokenParts <= enemy.gfx.ammoIndicators.length) {
                            const indicator = enemy.gfx.ammoIndicators[enemy.data.brokenParts - 1];
                            if (indicator) {
                                indicator.visible = false;
                            }
                        }
                        
                        // Check if arrow can be deflected back - create simple deflected arrow
                        if (hitInfo && enemy.data.lastShotDirection) {
                            createDeflectedArrow(enemy, enemy.data.lastShotDirection);
                        }
                    },
                    update(enemy, delta) {
                        const data = enemy.data;
                        if (!data) return;
                        
                        if (enemy.state === 'approaching') {
                            // Move toward target position from spawn point
                            const dx = data.targetPosition.x - enemy.gfx.x;
                            const dy = data.targetPosition.y - enemy.gfx.y;
                            const dist = Math.hypot(dx, dy);
                            
                            if (dist > 5) {
                                // Still approaching
                                enemy.gfx.x += (dx / dist) * enemy.speed * delta;
                                enemy.gfx.y += (dy / dist) * enemy.speed * delta;
                                enemy.gfx.rotation = Math.atan2(dy, dx);
                            } else {
                                // Reached target - lock in place
                                enemy.state = 'locked';
                                enemy.gfx.x = data.targetPosition.x;
                                enemy.gfx.y = data.targetPosition.y;
                                enemy.gfx.rotation = data.targetAngle;
                                data.isLocked = true;
                                data.lockPosition = { x: enemy.gfx.x, y: enemy.gfx.y };
                            }
                        } else if (enemy.state === 'locked' && data.isLocked) {
                            // Stay locked in position
                            enemy.gfx.x = data.lockPosition.x;
                            enemy.gfx.y = data.lockPosition.y;
                            enemy.gfx.rotation = data.targetAngle;
                            
                            // Shooting logic
                            if (data.ammoRemaining > 0) {
                                data.shootTimer -= delta;
                                if (data.shootTimer <= 0) {
                                    // Shoot arrow toward core
                                    const coreX = core.x;
                                    const coreY = core.y;
                                    const dx = coreX - enemy.gfx.x;
                                    const dy = coreY - enemy.gfx.y;
                                    const angle = Math.atan2(dy, dx);
                                    
                                    // Store shot direction for deflection
                                    data.lastShotDirection = { x: Math.cos(angle), y: Math.sin(angle) };
                                    
                                    // Create arrow projectile directly
                                    createArrowProjectile(enemy, angle);
                                    
                                    data.ammoRemaining--;
                                    data.shootTimer = 120;
                                    
                                    // Update ammo indicator
                                    if (enemy.gfx.ammoIndicators && enemy.gfx.ammoIndicators[data.ammoRemaining]) {
                                        enemy.gfx.ammoIndicators[data.ammoRemaining].alpha = 0.3;
                                    }
                                }
                            }
                        }
                    }
                }
            };

            function chooseEnemyType() {
                const weights = [
                    { type: 'red', weight: 6 },
                    { type: 'orange', weight: 2 + Math.min(3, kills / 15) },
                    { type: 'pink', weight: 1 + Math.min(3, score / 800) },
                    { type: 'green', weight: 0.8 + Math.min(2.5, currentCombo / 8) },
                ];
                const total = weights.reduce((sum, entry) => sum + entry.weight, 0);
                let roll = Math.random() * total;
                for (const entry of weights) {
                    roll -= entry.weight;
                    if (roll <= 0) {
                        return entry.type;
                    }
                }
                return 'red';
            }

            const MAX_PINK_PROJECTILES = 42;

            function createPinkArcProjectiles(enemy) {
                const existing = enemyProjectiles.filter(p => p.ownerType === 'pink').length;
                if (existing > MAX_PINK_PROJECTILES) {
                    return;
                }
                const data = enemy.data || {};
                const baseRadius = Math.max(currentCoreRadius + 40, data.radius - 15);
                const count = 8;
                const arcSpread = Math.PI / 4.5; // Tighter arc spread for closer projectiles
                const startAngle = (data.angle || 0) - arcSpread / 2;
                for (let i = 0; i < count; i++) {
                    const t = count === 1 ? 0.5 : i / (count - 1);
                    const angle = startAngle + arcSpread * t;
                    
                    // Calculate frequency based on projectile size (smaller = higher pitch)
                    const projectileSize = 3 + Math.random() * 2; // Size between 3-5
                    const baseFreq = 400;
                    const sizeMultiplier = (6 - projectileSize) / 3; // Smaller size = higher multiplier
                    const frequency = baseFreq + (sizeMultiplier * 200); // Higher pitch for smaller
                    
                    enemyProjectiles.push({
                        type: 'pink',
                        ownerType: 'pink',
                        radius: baseRadius,
                        angle,
                        angularVelocity: 0.025 + Math.random() * 0.02,
                        shrinkRate: 0.04,
                        lifetime: 200,
                        color: 0xffa6ff,
                        size: projectileSize,
                        destructible: true,
                        soundFreq: frequency,
                        health: 1,
                    });
                }
            }

            const dangerWavePatterns = [
                {
                    name: 'Crimson Swarm',
                    entries: [
                        { type: 'red', count: 10, interval: 3 }
                    ]
                },
                {
                    name: 'Amber Giants',
                    entries: [
                        { type: 'orange', count: 8, interval: 6 }
                    ]
                },
                {
                    name: 'Emerald Charge',
                    entries: [
                        { type: 'green', count: 5, interval: 8 }
                    ]
                },
                {
                    name: 'Spiral Pressure',
                    entries: [
                        { type: 'pink', count: 4, interval: 10 },
                        { type: 'red', count: 6, interval: 4, initialDelay: 18 }
                    ]
                }
            ];


            
            function handleDeviceMotion(event) {
                const accel = event.acceleration;
                if (!accel) return;

                const currentTime = Date.now();
                const currentAccel = { x: accel.x || 0, y: accel.y || 0 };

                // Add to history for whip detection
                accelHistory.x.push(currentAccel.x);
                accelHistory.y.push(currentAccel.y);
                accelHistory.timestamp.push(currentTime);

                // Keep history size manageable
                if (accelHistory.x.length > HISTORY_SIZE) {
                    accelHistory.x.shift();
                    accelHistory.y.shift();
                    accelHistory.timestamp.shift();
                }

                // Detect whip gesture if we have enough history
                if (accelHistory.x.length >= 3) {
                    const recentX = accelHistory.x.slice(-3);
                    const recentY = accelHistory.y.slice(-3);
                    const recentTime = accelHistory.timestamp.slice(-3);

                    // Calculate acceleration changes (derivatives)
                    const deltaX1 = recentX[1] - recentX[0];
                    const deltaX2 = recentX[2] - recentX[1];
                    const deltaY1 = recentY[1] - recentY[0];
                    const deltaY2 = recentY[2] - recentY[1];

                    // Calculate magnitude of change (how sudden the movement is)
                    const changeMagnitude = Math.sqrt(
                        Math.pow((deltaX2 - deltaX1), 2) +
                        Math.pow((deltaY2 - deltaY1), 2)
                    );

                    // If we detect a significant whip gesture and we're in cooldown period
                    if (changeMagnitude > WHIP_THRESHOLD && (currentTime - lastWhipFrame) > WHIP_COOLDOWN) {
                        // Calculate the direction of the whip
                        const whipDirection = {
                            x: deltaX2 - deltaX1,
                            y: deltaY2 - deltaY1
                        };

                        // Normalize the direction vector
                        const whipLength = Math.sqrt(whipDirection.x * whipDirection.x + whipDirection.y * whipDirection.y);
                        if (whipLength > 0) {
                            const normalizedDirection = {
                                x: whipDirection.x / whipLength,
                                y: whipDirection.y / whipLength
                            };

                            // Apply the direction to motion with the accelerometer multiplier
                            motion.ax = normalizedDirection.x;
                            motion.ay = normalizedDirection.y;
                            lastWhipFrame = currentTime;
                        }
                    } else {
                        // No significant whip detected, use raw acceleration for subtle movements
                        motion.ax = currentAccel.x;
                        motion.ay = currentAccel.y;
                    }
                } else {
                    // Not enough history yet, use raw values
                    motion.ax = currentAccel.x;
                    motion.ay = currentAccel.y;
                }
            }
            function handleMouseMove(event) { motion.mx = event.movementX; motion.my = event.movementY; }

            function spawnPowerUp(type) {
                const powerUpData = powerUpTypes[type];
                if (!powerUpData) return;
    
                const gfx = powerUpData.createGfx();
                
                // BOMB powerups spawn from screen edge and move slowly toward core
                if (type === 'bomb') {
                    // Spawn from random edge of screen
                    const angle = Math.random() * Math.PI * 2;
                    const screenHypot = Math.hypot(app.screen.width, app.screen.height);
                    const spawnDistance = screenHypot / 2 + 100;
                    
                    gfx.x = core.x + Math.cos(angle) * spawnDistance;
                    gfx.y = core.y + Math.sin(angle) * spawnDistance;
                    
                    const powerUp = { gfx, type, data: powerUpData, orbit: null };
                    powerUpsContainer.addChild(gfx);
                    powerUps.push(powerUp);
                } else {
                    // Normal powerup orbit logic for other types
                    // --- New Trajectory Logic ---
                    // 1. Proximity is at least the rope length.
                    const semiMinor = dynamicMaxLength + (20 + Math.random() * 80) * 0.10; // Closest point of the arc, now 30% closer again.
        
                    // 2. The arc is wide, ensuring it passes through the screen.
                    const screenHypot = Math.hypot(app.screen.width, app.screen.height);
                    const semiMajor = semiMinor + screenHypot / 2 + Math.random() * 200; // Farthest point of the arc.
        
                    // 3. The orbit is rotated randomly.
                    const rotation = Math.random() * Math.PI * 1.2;
        
                    // 4. Determine a starting angle 'theta' that places the power-up off-screen.
                    // We find the angle where the ellipse intersects a bounding box larger than the screen.
                    const offscreenRadius = screenHypot / 2 + 50; // A radius safely outside the screen.
                    const cosR = Math.cos(rotation);
                    const sinR = Math.sin(rotation);
                    // Simplified intersection check: find theta where ellipse radius is > offscreenRadius.
                    // We can approximate this by starting far out on the major axis.
                    const startTheta = Math.random() < 0.5 ? Math.PI : 0; // Start at one of the two far ends of the ellipse.
        
                    const orbit = {
                        semiMajor,
                        semiMinor,
                        theta: startTheta,
                        direction: Math.random() < 0.5 ? -1 : 1,
                        angularSpeed: (0.012 + Math.random() * 0.006) * 0.4, // Slowed down by 30%, then another 20%
                        rotation,
                        cosR: cosR,
                        sinR: sinR,
                    };
        
                    // Set initial position based on the calculated off-screen start point.
                    const localX = orbit.semiMajor * Math.cos(orbit.theta);
                    const localY = orbit.semiMinor * Math.sin(orbit.theta);
                    gfx.x = core.x + (localX * orbit.cosR - localY * orbit.sinR);
                    gfx.y = core.y + (localX * orbit.sinR + localY * orbit.cosR);
        
                    const powerUp = { gfx, type, data: powerUpData, orbit };
                    powerUpsContainer.addChild(gfx);
                    powerUps.push(powerUp);
                }

                powerUpData.spawnTimer = powerUpData.spawnInterval();
            }

            // BOMB explosion mechanics
            function triggerBombExplosion(bombX, bombY, hitAngle) {
                // Play deep destructive sound
                playBombDestructionSound();
                
                // Create massive explosion visual
                createSplash(bombX, bombY, 0x000000, 200);
                createSplash(bombX, bombY, 0x440022, 150);
                createSplash(bombX, bombY, 0xffffff, 100);
                
                // Create cone effect - calculate cone parameters
                const coneWidth = Math.PI / 3; // 60 degrees wide
                const coneRange = dynamicMaxLength * 1.5; // Large reach
                
                // Find all enemies in the cone
                const enemiesInCone = [];
                for (const enemy of enemies) {
                    const dx = enemy.gfx.x - bombX;
                    const dy = enemy.gfx.y - bombY;
                    const distance = Math.hypot(dx, dy);
                    const enemyAngle = Math.atan2(dy, dx);
                    
                    // Check if enemy is within cone
                    let angleDiff = Math.abs(enemyAngle - hitAngle);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (distance <= coneRange && angleDiff <= coneWidth / 2) {
                        enemiesInCone.push({ enemy, distance, angle: enemyAngle });
                    }
                }
                
                // Suck enemies into the cone center with dramatic effect
                for (const { enemy } of enemiesInCone) {
                    createSplash(enemy.gfx.x, enemy.gfx.y, enemy.baseColor, 50);
                    app.stage.removeChild(enemy.gfx);
                    
                    // Award points for each enemy destroyed
                    kills++;
                    currentCombo++;
                    score += 25 * currentCombo; // Higher score for BOMB kills
                }
                
                // Remove destroyed enemies from the array
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (enemiesInCone.some(({ enemy }) => enemy === enemies[i])) {
                        enemies.splice(i, 1);
                    }
                }
                
                // Update UI
                maxComboInGame = Math.max(maxComboInGame, currentCombo);
                scoreText.textContent = `Pontuação: ${score}`;
                comboText.textContent = `Combo: x${currentCombo}`;
                
                // Massive slow motion effect
                if (slowMoTimer <= 0) {
                    slowMoTimer = dynamicSlowMoDuration * 2; // Extra long slow mo
                    slowMoTarget = null; // No camera movement
                }
                
                console.log(`BOMB destroyed ${enemiesInCone.length} enemies!`);
            }
            
            function triggerBombGameOver() {
                // Play catastrophic sound
                playBombGameOverSound();
                
                // Immediate screen effect
                app.view.style.filter = 'brightness(3) contrast(2)';
                dangerOverlay.style.boxShadow = 'inset 0 0 500px 200px rgba(0, 0, 0, 0.9)';
                
                // Start death sequence immediately
                setTimeout(() => {
                    startDeathSequence();
                }, 500);
                
                console.log('BOMB reached the core! Instant game over!');
            }
            
            function playBombDestructionSound() {
                if (!soundModule) return;
                
                // Deep, destructive sine wave with increasing interval
                let frequency = nearestAmFrequency(55); // Very low base frequency
                const duration = 3.0;
                const steps = 8;
                
                for (let i = 0; i < steps; i++) {
                    setTimeout(() => {
                        const currentFreq = frequency * (1 + i * 0.1); // Slightly increasing
                        soundModule.createOneShot({
                            type: 'sine',
                            frequency: currentFreq,
                            attack: 0.1,
                            release: 0.8,
                            duration: 0.6,
                            volume: 0.4 - (i * 0.03), // Decreasing volume
                        });
                    }, i * (duration * 1000) / steps);
                }
            }
            
            function playBombGameOverSound() {
                if (!soundModule) return;
                
                // Catastrophic low frequency sound
                const baseFreq = nearestAmFrequency(40); // Extremely low
                
                soundModule.createOneShot({
                    type: 'sine',
                    frequency: baseFreq,
                    attack: 0.2,
                    release: 4.0,
                    duration: 5.0,
                    volume: 0.6,
                });
                
                // Add harmonic overtones for more impact
                setTimeout(() => {
                    soundModule.createOneShot({
                        type: 'triangle',
                        frequency: baseFreq * 1.5,
                        attack: 0.1,
                        release: 2.0,
                        duration: 3.0,
                        volume: 0.3,
                    });
                }, 500);
            }


            function updatePowerUps(delta) {
                // Spawn new power-ups
                for (const type in powerUpTypes) {
                    const puType = powerUpTypes[type];
                    if (puType.spawnTimer > 0) {
                        puType.spawnTimer -= delta;
                    } else {
                        spawnPowerUp(type);
                    }
                }

                // Update existing power-ups
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    
                    // Handle BOMB powerup differently - it moves slowly toward core
                    if (powerUp.type === 'bomb') {
                        // Animate the bomb's rotating parts
                        if (powerUp.gfx.bombData) {
                            powerUp.gfx.bombData.pulsePhase += 0.1 * delta;
                            powerUp.gfx.children[2].rotation += powerUp.gfx.bombData.rotationSpeed * delta; // Distortion rings
                            
                            // Pulsing effect for menacing appearance
                            const pulse = 0.8 + Math.sin(powerUp.gfx.bombData.pulsePhase) * 0.2;
                            powerUp.gfx.alpha = pulse;
                        }

                        // Move slowly toward core (spiral inward)
                        const dx = core.x - powerUp.gfx.x;
                        const dy = core.y - powerUp.gfx.y;
                        const distToCore = Math.hypot(dx, dy);
                        
                        if (distToCore > currentCoreRadius + 25) {
                            const moveSpeed = 0.8 * delta; // Slow movement toward core
                            powerUp.gfx.x += (dx / distToCore) * moveSpeed;
                            powerUp.gfx.y += (dy / distToCore) * moveSpeed;
                        }

                        // Check for dart collision with BOMB
                        const hitRadius = 25; // Larger hit radius for BOMB
                        if (Math.hypot(player.x - powerUp.gfx.x, player.y - powerUp.gfx.y) < hitRadius) {
                            // BOMB hit by dart - create massive cone explosion
                            const hitAngle = Math.atan2(player.y - powerUp.gfx.y, player.x - powerUp.gfx.x);
                            triggerBombExplosion(powerUp.gfx.x, powerUp.gfx.y, hitAngle);
                            
                            // Remove the bomb
                            powerUpsContainer.removeChild(powerUp.gfx);
                            powerUps.splice(i, 1);
                            continue;
                        }

                        // Check if BOMB reached core (GAME OVER)
                        if (distToCore <= currentCoreRadius + 25) {
                            triggerBombGameOver();
                            powerUpsContainer.removeChild(powerUp.gfx);
                            powerUps.splice(i, 1);
                            continue;
                        }
                        
                        continue; // Skip normal powerup logic for BOMB
                    }

                    // Normal powerup behavior for non-BOMB powerups
                    const orbit = powerUp.orbit;
                    if (!orbit) continue;

                    orbit.theta += orbit.direction * orbit.angularSpeed * delta;
                    if (orbit.theta > Math.PI * 2) {
                        orbit.theta -= Math.PI * 2;
                    } else if (orbit.theta < 0) {
                        orbit.theta += Math.PI * 2;
                    }

                    const cosTheta = Math.cos(orbit.theta);
                    const sinTheta = Math.sin(orbit.theta);
                    const localX = orbit.semiMajor * cosTheta;
                    const localY = orbit.semiMinor * sinTheta;
                    const rotatedX = localX * orbit.cosR - localY * orbit.sinR;
                    const rotatedY = localX * orbit.sinR + localY * orbit.cosR;

                    const originX = core.x;
                    const originY = core.y;
                    powerUp.gfx.x = originX + rotatedX;
                    powerUp.gfx.y = originY + rotatedY;

                    // Pulsing alpha effect to signal availability
                    powerUp.gfx.alpha = 0.7 + Math.sin(Date.now() / 300) * 0.3;

                    if (Math.hypot(player.x - powerUp.gfx.x, player.y - powerUp.gfx.y) < 30) {
                        powerUp.data.effect();
                        powerUpsContainer.removeChild(powerUp.gfx);
                        powerUps.splice(i, 1);
                        createSplash(player.x, player.y, powerUp.data.color, 40);
                        continue;
                    }

                    const distFromCore = Math.hypot(rotatedX, rotatedY);
                    const maxRadius = Math.max(orbit.semiMajor + 60, Math.max(app.screen.width, app.screen.height));
                    if (distFromCore > maxRadius) {
                        powerUpsContainer.removeChild(powerUp.gfx);
                        powerUps.splice(i, 1);
                    }
                }
            }

            function recalculateMirrorTier() {
                const mirrorEffect = activeEffects.mirror;
                mirrorEffect.tier = 1 + permanentEffects.mirrorTier + mirrorEffect.tempUpgrades.length;
            }

            function createMirrorClones() {
                // Clear existing clones
                for (const clone of clones) {
                    app.stage.removeChild(clone.gfx);
                    app.stage.removeChild(clone.tether);
                }
                clones = [];

                const tier = activeEffects.mirror.tier;
                if (tier <= 1) return;

                for (let i = 1; i < tier; i++) {
                    const gfx = new PIXI.Graphics().beginFill(0x7dfbff).moveTo(20, 0).lineTo(0, -15).lineTo(-10, 0).lineTo(0, 15).closePath().endFill();
                    gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.2, color: 0x7dfbff })];
                    gfx.alpha = 0.85;
                    
                    const tether = new PIXI.Graphics();
                    
                    app.stage.addChild(tether);
                    app.stage.addChild(gfx);

                    clones.push({
                        gfx,
                        tether,
                        position: { x: center.x, y: center.y },
                        previousPosition: { x: center.x, y: center.y }
                    });
                }
            }

            function activateMirror(durationFrames) {
                const mirrorEffect = activeEffects.mirror;
                if (!mirrorEffect) return;

                if (durationFrames > 0) {
                    mirrorEffect.tempUpgrades.push({ duration: durationFrames, timer: durationFrames });
                }
                
                recalculateMirrorTier();
                createMirrorClones();
            }

            function updateMirrorUpgrades(delta) {
                const mirrorEffect = activeEffects.mirror;
                if (!mirrorEffect.tempUpgrades.length) return;

                let tierChanged = false;
                for (let i = mirrorEffect.tempUpgrades.length - 1; i >= 0; i--) {
                    const upgrade = mirrorEffect.tempUpgrades[i];
                    upgrade.timer -= delta;
                    if (upgrade.timer <= 0) {
                        mirrorEffect.tempUpgrades.splice(i, 1);
                        tierChanged = true;
                    }
                }

                if (tierChanged) {
                    recalculateMirrorTier();
                    createMirrorClones();
                }
            }

            function startGame(isMobileDetected) {
                isMobile = !!isMobileDetected;
                if (isMobile) {
                    document.body.classList.add('mobile-debug');
                    
                    // Set mobile-specific defaults
                    mobileControlMode = 'joystick';
                    controlModeToggle.textContent = 'Joystick';
                    
                    // Set mobile base impulse to 20
                    mobileImpulseInput.value = '20';
                    mobileImpulseSlider.value = '20';
                    mobileImpulseSlider.max = '50.0';
                    
                    // Set orbital impulse to 10 for mobile
                    dynamicOrbitalImpulse = 10;
                    document.getElementById('orbital-impulse-value').value = '10';
                    
                    app.ticker.start();
                } else {
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                }
            }

            function requestDeviceMotionPermission() {
                const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
                const canOrient = ('ondeviceorientation' in window) || (typeof DeviceOrientationEvent !== 'undefined');
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission()
                        .then(state => {
                            if (state === 'granted') {
                                window.addEventListener('devicemotion', handleDeviceMotion);
                                startGame(true);
                            } else {
                                startGame(false);
                            }
                        })
                        .catch(() => startGame(false));
                } else if (hasTouch && canOrient) {
                    window.addEventListener('devicemotion', handleDeviceMotion);
                    startGame(true);
                } else {
                    startGame(false);
                }
            }
            permissionButton.addEventListener('click', () => {
                permissionOverlay.classList.add('hidden'); 
                beginExperience();
            });


            function pauseGame() { 
                isPaused = true; 
                app.ticker.stop(); 
                pauseOverlay.classList.remove('hidden'); 
                if (isMobile) {
                    mobileControlsContainer.style.display = 'block';
                }
            }
            function resumeGame() { 
                if (!isMobile) { 
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                } else { 
                    isPaused = false; 
                    app.ticker.start(); 
                    pauseOverlay.classList.add('hidden'); 
                    mobileControlsContainer.style.display = 'none';
                } 
            } 
            
            document.addEventListener('pointerlockchange', () => {
                if(document.pointerLockElement === app.view){
                    document.addEventListener('mousemove', handleMouseMove, false); app.ticker.start(); isPaused = false; pauseOverlay.classList.add('hidden');
                } else { 
                    document.removeEventListener('mousemove', handleMouseMove, false); if(isGameOver || !experienceStarted) return; pauseGame();
                }
            }, false);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !isPaused && document.pointerLockElement === app.view) {
                    document.exitPointerLock();
                }
                if (e.key && e.key.toLowerCase() === 'u') {
                    // Only allow toggling if the game is running and not over
                    if (experienceStarted && !isGameOver) {
                        document.body.classList.toggle('controls-on');
                    }
                }
            });

            // Mobile pause button
            const mobilePauseButton = document.getElementById('mobile-pause-button');
            if (mobilePauseButton) {
                mobilePauseButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isGameOver && experienceStarted) {
                        if (isPaused) {
                            resumeGame();
                        } else {
                            pauseGame();
                        }
                    }
                });
            }
            resumeButton.addEventListener('click', resumeGame);
            resumeButton.addEventListener('touchstart', (e) => { e.preventDefault(); resumeGame(); });
            playAgainButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('touchstart', (e) => { e.preventDefault(); resetGame(); });
            document.getElementById('pause-return-home-button').addEventListener('click', returnToHome);
            document.getElementById('pause-return-home-button').addEventListener('touchstart', (e) => { e.preventDefault(); returnToHome(); });

            const returnHomeButton = document.getElementById('return-home-button');
            returnHomeButton.addEventListener('click', returnToHome);
            returnHomeButton.addEventListener('touchstart', (e) => { e.preventDefault(); returnToHome(); });

            function returnToHome() {
                document.exitPointerLock();
                experienceStarted = false; // Allow game to start again
                gameOverOverlay.classList.add('hidden');
                pauseOverlay.classList.add('hidden');
                resetState();
                experienceStarted = false; // Allow game to start again
                welcomeOverlay.style.display = 'flex';
                welcomeOverlay.classList.remove('fade-out-slow');
                welcomeOverlay.classList.add('show');
                document.body.classList.add('intro-active');
                document.body.classList.remove('ui-on');
                mobileControlsContainer.style.display = 'none';
                setupGameLogoClickHandler();
            }

            const stars = document.querySelectorAll('.star');
            let currentRating = 0;

            function setStars(rating) {
                stars.forEach(s => {
                    const value = parseInt(s.dataset.value);
                    if (value <= rating) {
                        s.innerHTML = '★';
                        s.classList.add('filled');
                    } else {
                        s.innerHTML = '☆';
                        s.classList.remove('filled');
                    }
                });
            }

            stars.forEach(star => {
                star.addEventListener('mouseover', () => {
                    const value = parseInt(star.dataset.value);
                    stars.forEach(s => {
                        const sValue = parseInt(s.dataset.value);
                        if (sValue <= value) {
                            s.innerHTML = '★';
                            s.classList.add('filled');
                        } else {
                            s.innerHTML = '☆';
                            s.classList.remove('filled');
                        }
                    });
                });

                star.addEventListener('mouseout', () => {
                    setStars(currentRating);
                });

                star.addEventListener('click', () => {
                    currentRating = parseInt(star.dataset.value);
                    setStars(currentRating);
                    document.getElementById('rating-thanks').classList.remove('hidden');
                });
            });

            function endGame() {
                isGameOver = true;
                app.ticker.stop();

                // Hide game elements immediately
                tether.visible = false; // Hide tether on game over screen
                player.visible = false; // Hide player dart
                core.visible = false; // Hide core
                coreCracks.visible = false; // Hide core cracks

                // Update final stats
                document.getElementById('final-kills').textContent = kills;
                document.getElementById('final-max-combo').textContent = maxComboInGame;
                document.getElementById('final-backshots').textContent = backshots;
                document.getElementById('final-critical-hits').textContent = criticalHits;

                // Show game over overlay
                gameOverOverlay.classList.remove('hidden');
                document.body.classList.remove('ui-on'); // Hide in-game UI
                document.body.classList.remove('controls-on'); // Hide controls just in case

                // Wait 2 seconds before releasing mouse control to let game over screen fade in
                setTimeout(() => {
                    if(document.pointerLockElement === app.view) {
                        document.exitPointerLock();
                    }
                }, 2000);
            }

            function resetState() {
                score = 0; kills = 0; currentCombo = 0; maxComboInGame = 0; backshots = 0; criticalHits = 0; isPaused = false; isGameOver = false;  coreHitTimer = 0; currentCoreRadius = 30; isDangerState = false; nextHitKills = false;
                comboNoteIndex = 0;
                playerState = 'at_core'; isReturning = false;
                player.tint = 0xFFFFFF;
                scoreText.textContent = `Pontuação: ${score}`;
                comboText.textContent = `Combo: x${currentCombo}`;

                // Clean up performance optimizer resources
                if (window.performanceOptimizer) {
                    performanceOptimizer.cleanup();
                }

                // Reset critical mass state
                criticalMassTimer = 0;
                isInCriticalMass = false;
                
                // Reset screen effects
                app.view.style.filter = '';
                dangerOverlay.style.boxShadow = '';

                dangerOverlay.classList.add('hidden');
                core.filters[0].color = CORE_BASE_COLOR;
                core.filters[0].outerStrength = 2;
                dangerOverlay.classList.remove('active');
                
                // Redraw core at original size
                core.clear();
                core.beginFill(CORE_BASE_COLOR).drawCircle(0, 0, currentCoreRadius).endFill();
                core.width = core.height = currentCoreRadius * 2;
                updateCoreStatus();
                core.tint = CORE_BASE_COLOR;
                coreCracks.clear();

                enemies.forEach(e => app.stage.removeChild(e.gfx)); enemies.length = 0;
                powerUps.forEach(p => powerUpsContainer.removeChild(p.gfx)); powerUps.length = 0;
                healingItems.forEach(item => healingItemsContainer.removeChild(item.gfx)); healingItems.length = 0;
                activeEffects.doubleSize = 0;
                activeEffects.scalePowerups = []; // Reset scale powerups array
                activeEffects.mirror.tier = 1;
                activeEffects.mirror.tempUpgrades = [];
                activeEffects.healing = [];
                permanentEffects.sizeBonus = 0;
                permanentEffects.healingRate = 0;
                permanentEffects.mirrorTier = 0;
                collectedUpgradeHistory.clear();
                coreChoiceTimer = 0;
                isCoreChoiceActive = false;
                newCoreChoices = [];
                enemySpawnIntensity = 1;
                enemySpawnAccumulator = 0;
                enemySpeedMultiplier = 1;
                coreRunCount = 0;
                refreshSizeMultiplier();
                for (const clone of clones) {
                    app.stage.removeChild(clone.gfx);
                    app.stage.removeChild(clone.tether);
                }
                clones = [];
                newCoreContainer.visible = false;
                newCoreContainer.removeChildren();
                coreHealingTimer = 0;
                trailPoints = []; particles = [];
                player.x = center.x; player.y = center.y; player.vx = 0; player.vy = 0;
                tether.visible = true;
                coreCracks.visible = true;
                player.visible = true;
                core.visible = true;
                healingSpawnTimer = 900 + Math.random() * 600;
                dangerWaveState = 'cooldown';
                dangerWaveTimer = 900 + Math.random() * 600;
                dangerWaveWarningTimer = 0;
                dangerWaveActiveTimer = 0;
                dangerWaveQueue = [];
                setDangerOverlayWave(false);
core.tint = CORE_BASE_COLOR;
                player.rotation = 0; player.scale.set(1);
                app.stage.scale.set(1); app.stage.position.set(0,0); app.stage.pivot.set(0,0);
                slowMoTarget = null; slowMoTimer = 0; app.ticker.speed = 1.0;
                gameOverOverlay.classList.add('hidden');
                document.getElementById('rating-thanks').classList.add('hidden');
                currentRating = 0;
                setStars(0);
            }

            function resetGame() {
                // Wait for the overlay to fully hide before starting the game to prevent immediate pause.
                // The overlay has a 0.3s transition.
                setTimeout(() => {
                    resetState();
                    document.body.classList.add('ui-on'); // Show UI for new game
                    if(!isMobile) {
                        // Request pointer lock only after the overlay is gone.
                        app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                    } else {
                        app.ticker.start();
                    }
                }, 350); // A little more than the transition duration
                if (gameOverOverlay) {
                    gameOverOverlay.classList.add('hidden');
                }
            }

            function updatePlayer() {
                if (vibrationTimer > 0) vibrationTimer--;

                // On mobile, use accelerometer for continuous input (not swipe-to-launch)
                if (isMobile && !isPaused) {
                    if (mobileControlMode === 'accelerometer') {
                        let finalAccelX = motion.ax;
                        let finalAccelY = motion.ay;

                        // Apply deadzone by checking if the absolute value is less than the deadzone threshold
                        if (Math.abs(finalAccelX) < mobileDeadzone) finalAccelX = 0;
                        if (Math.abs(finalAccelY) < mobileDeadzone) finalAccelY = 0;

                        // Fix accelerometer directions - invert Y by default, X can be toggled
                        if (invertX) finalAccelX *= -1;
                        if (!invertY) finalAccelY *= -1; // Default behavior is inverted Y
                        else finalAccelY *= 1; // If "invert Y" is checked, don't invert (double negative)

                        // Apply stronger multiplier and convert to motion
                        motion.mx = finalAccelX * mobileAccelerometerMultiplier * 5; // Stronger response
                        motion.my = finalAccelY * mobileAccelerometerMultiplier * 5;

                        motion.ax = 0; motion.ay = 0; // Reset accelerometer input after use
                    } else {
                        // In joystick mode, motion is handled by the swipe-to-launch system
                        // No continuous motion input needed here
                        motion.mx = 0;
                        motion.my = 0;
                    }
                }

                // Use the same impulse logic for both mobile and desktop
                let impulse = (playerState === 'at_core') ? dynamicImpulseMultiplier : dynamicOrbitalImpulse;
                player.vx += motion.mx * impulse;
                player.vy += motion.my * impulse;
                motion.mx = 0; motion.my = 0;
                
                let dx = player.x - core.x, dy = player.y - core.y, dist = Math.hypot(dx, dy);
                const radialVelocity = (player.vx * dx + player.vy * dy) / (dist || 1);
                if (!isReturning && radialVelocity < 0 && dist > 50) { isReturning = true; }
                if (dist > 1) {
                    const angle = Math.atan2(dy, dx);
                    const springForce = dist * dynamicStiffness;
                    let totalReturnForce = springForce + dynamicGravityPull;
                    if (isReturning) { totalReturnForce += dynamicRetractionForce; }
                    player.vx -= Math.cos(angle) * totalReturnForce;
                    player.vy -= Math.sin(angle) * totalReturnForce;
                }
                
                player.vx *= dynamicDamping; player.vy *= dynamicDamping;
                player.x += player.vx; player.y += player.vy;

                dx = player.x - core.x; dy = player.y - core.y; dist = Math.hypot(dx, dy);
                const absoluteMaxLength = dynamicMaxLength * dynamicOvershoot;

                if (dist > dynamicMaxLength) {
                    const overshootAmount = dist - dynamicMaxLength;
                    const snapBackForce = overshootAmount * dynamicSnapBackStrength;
                    const angle = Math.atan2(dy, dx);
                    player.vx -= Math.cos(angle) * snapBackForce;
                    player.vy -= Math.sin(angle) * snapBackForce;
                }
                if (dist > absoluteMaxLength) {
                    const angle = Math.atan2(dy, dx);
                    player.x = core.x + Math.cos(angle) * absoluteMaxLength;
                    player.y = core.y + Math.sin(angle) * absoluteMaxLength;
                    const ux = dx / dist; const uy = dy / dist;
                    const velAlongRope = player.vx * ux + player.vy * uy;
                    if (velAlongRope > 0) { player.vx -= velAlongRope * ux; player.vy -= velAlongRope * uy; }
                }

                // Lógica de Estado e Aparência
                const speed = Math.hypot(player.vx, player.vy);
                if (dist > 1 && speed > dynamicRotationThreshold) { 
                    player.rotation = Math.atan2(dy, dx);
                }

                const MAX_VISUAL_SPEED = 15;
                const normalizedSpeed = Math.min(1.0, speed / MAX_VISUAL_SPEED);
                let scaleX = 1 - (1 - dynamicSquashScaleX) * normalizedSpeed;
                let scaleY = 1 + (dynamicStretchScaleY - 1) * normalizedSpeed;

                // Apply cumulative size multiplier
                if (activeEffects.sizeMultiplier > 1) {
                    scaleX *= activeEffects.sizeMultiplier;
                    scaleY *= activeEffects.sizeMultiplier;
                }

                if (vibrationTimer > 0) {
                    const vibrationAmount = (dynamicHitVibration / 15) * vibrationTimer;
                    scaleX += (Math.random() - 0.5) * vibrationAmount;
                    scaleY += (Math.random() - 0.5) * vibrationAmount;
                }
                player.scale.set(scaleX, scaleY);
                
                const vitality = Math.max(0, 1.0 - (dist / dynamicMaxLength));
                player.tint = lerpColor(DART_FAR_COLOR, DART_NEAR_COLOR, vitality);

                if (playerState === 'launched') {
                     trailPoints.push({ x: player.x, y: player.y, lifetime: dynamicTrailDuration, tint: player.tint });
                }

                if (playerState === 'launched' && dist < currentCoreRadius) {
                    playerState = 'at_core'; currentCombo = 0; isReturning = false;
                    comboNoteIndex = 0;
                    comboText.textContent = `Combo: x${currentCombo}`;
                    player.rotation = 0;
                } else if (playerState === 'at_core' && dist > (core.width / 2) + 5) {
                    playerState = 'launched'; isReturning = false; 
                }
                if (playerState === 'at_core') {
                    player.vx *= dynamicCoreBrake; player.vy *= dynamicCoreBrake;
                }

                // Update core visual state
                if (coreHitTimer > 0) {
                    coreHitTimer--;
                    const flash = Math.sin(coreHitTimer * 0.8) > 0; // Faster flash
                    core.tint = flash ? 0xff8888 : (isDangerState ? 0xff0000 : CORE_BASE_COLOR);
                } else {
                    core.tint = isDangerState ? 0xff0000 : CORE_BASE_COLOR;
                }

                // Update core danger state
                const wasInDanger = isDangerState;
                const isWarningState = currentCoreRadius > dynamicMaxLength * 0.9;
                isDangerState = currentCoreRadius > dynamicMaxLength; // Full danger state
                if (isDangerState && !wasInDanger) {
                    nextHitKills = true;
                }
                const isWaveActive = isDangerWaveOngoing();

                // Handle warning state (vignette) and wave alerts
                if ((isWarningState && !isDangerState) || isWaveActive) {
                    dangerOverlay.classList.remove('hidden');
                    if (!dangerOverlay.classList.contains('active')) dangerOverlay.classList.add('active');
                } else if (!isWarningState && !isWaveActive) {
                    dangerOverlay.classList.add('hidden');
                    dangerOverlay.classList.remove('active');
                }

                // Handle full danger state (shaking, red core)
                if (isDangerState) {
                    dangerOverlay.classList.remove('hidden'); 
                    if (!dangerOverlay.classList.contains('active')) dangerOverlay.classList.add('active');

                    core.filters[0].color = 0xff0000;
                    core.filters[0].outerStrength = 4; // More intense glow
                    if (coreHitTimer <= 0) core.tint = 0xff0000; // If not flashing, be red
                    // Add shake
                    core.position.set(center.x + (Math.random() - 0.5) * 4, center.y + (Math.random() - 0.5) * 4);
                    coreCracks.position.copyFrom(core.position);
                } else if (wasInDanger && !isDangerState && !isWaveActive && !isWarningState) { // Exited danger state
                    core.filters[0].color = CORE_BASE_COLOR;
                    core.filters[0].outerStrength = 2;
                    core.position.set(center.x, center.y); // Stop shaking
                    coreCracks.position.copyFrom(core.position);
                }

                if (!isDangerState) {
                    if (coreHealingTimer > 0) {
                        coreHealingTimer--;
                        core.filters[0].color = 0x9ff0ff;
                        core.filters[0].outerStrength = 3;
                        if (coreHitTimer <= 0) {
                            core.tint = 0x9de6ff;
                        }
                    } else if (!isWarningState && !isWaveActive && coreHitTimer <= 0) {
                        core.filters[0].color = CORE_BASE_COLOR;
                        core.filters[0].outerStrength = 2;
                        core.tint = CORE_BASE_COLOR;
                    }
                } else {
                    coreHealingTimer = 0;
                }
            }

            function updateClones(delta) {
                if (isCoreChoiceActive) {
                    for (const clone of clones) {
                        clone.gfx.visible = false;
                        clone.tether.visible = false;
                    }
                    return;
                }

                const tier = activeEffects.mirror.tier;
                if (tier <= 1) return;

                const baseAngle = Math.atan2(player.y - core.y, player.x - core.x);
                const dist = Math.hypot(player.x - core.x, player.y - core.y);

                for (let i = 0; i < clones.length; i++) {
                    const clone = clones[i];
                    const angle = baseAngle + (2 * Math.PI * (i + 1)) / tier;

                    clone.previousPosition.x = clone.position.x;
                    clone.previousPosition.y = clone.position.y;

                    clone.position.x = core.x + Math.cos(angle) * dist;
                    clone.position.y = core.y + Math.sin(angle) * dist;

                    clone.gfx.visible = true;
                    clone.tether.visible = true;
                    clone.gfx.position.set(clone.position.x, clone.position.y);
                    clone.gfx.rotation = angle;
                    clone.gfx.scale.copyFrom(player.scale);
                    clone.gfx.tint = player.tint;

                    if (playerState === 'launched') {
                        trailPoints.push({ x: clone.position.x, y: clone.position.y, lifetime: dynamicTrailDuration, tint: clone.gfx.tint });
                    }
                }
            }
            
            function lerpColor(start, end, t) {
                const sr = (start >> 16) & 0xff, sg = (start >> 8) & 0xff, sb = start & 0xff;
                const er = (end >> 16) & 0xff, eg = (end >> 8) & 0xff, eb = end & 0xff;
                const r = Math.round(sr + (er - sr) * t);
                const g = Math.round(sg + (eg - sg) * t);
                const b = Math.round(sb + (eb - sb) * t);
                return (r << 16) | (g << 8) | b;
            }

            function easeInOutCubic(x) { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }

            function drawTetherGraphics(gfx, targetX, targetY, endColorOverride) {
                gfx.clear();
                const dx = targetX - core.x;
                const dy = targetY - core.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 1) return;
                const normalizedDist = Math.min(1.0, dist / dynamicMaxLength);
                const easedDist = easeInOutCubic(normalizedDist);
                const thickness = dynamicMinThickness + (1 - easedDist) * (dynamicMaxThickness - dynamicMinThickness);
                const segments = 24;
                
                // Use core color as the starting point for better blending
                const coreColor = core.tint || CORE_BASE_COLOR;
                const startColor = coreColor;
                
                let endColor;
                if (endColorOverride !== undefined) {
                    endColor = endColorOverride;
                } else {
                    // Create a neighboring hue variation of the core color for beauty effect
                    const coreR = (coreColor >> 16) & 0xff;
                    const coreG = (coreColor >> 8) & 0xff;
                    const coreB = coreColor & 0xff;
                    
                    // Convert to HSV for hue shifting
                    const max = Math.max(coreR, coreG, coreB) / 255;
                    const min = Math.min(coreR, coreG, coreB) / 255;
                    const delta = max - min;
                    
                    let h = 0, s = 0, v = max;
                    
                    if (delta !== 0) {
                        s = delta / max;
                        if (max === coreR / 255) h = ((coreG - coreB) / 255) / delta;
                        else if (max === coreG / 255) h = 2 + ((coreB - coreR) / 255) / delta;
                        else h = 4 + ((coreR - coreG) / 255) / delta;
                        h /= 6;
                        if (h < 0) h += 1;
                    }
                    
                    // Shift hue by 0.15 (54 degrees) for neighboring color and increase saturation
                    h = (h + 0.15) % 1;
                    s = Math.min(1, s + 0.2); // More saturated tip
                    v = Math.min(1, v + 0.1); // Slightly brighter tip
                    
                    // Convert back to RGB
                    const c = v * s;
                    const x = c * (1 - Math.abs(((h * 6) % 2) - 1));
                    const m = v - c;
                    
                    let r, g, b;
                    if (h < 1/6) { r = c; g = x; b = 0; }
                    else if (h < 2/6) { r = x; g = c; b = 0; }
                    else if (h < 3/6) { r = 0; g = c; b = x; }
                    else if (h < 4/6) { r = 0; g = x; b = c; }
                    else if (h < 5/6) { r = x; g = 0; b = c; }
                    else { r = c; g = 0; b = x; }
                    
                    r = Math.round((r + m) * 255);
                    g = Math.round((g + m) * 255);
                    b = Math.round((b + m) * 255);
                    
                    endColor = (r << 16) | (g << 8) | b;
                }
                
                for (let i = 0; i < segments; i++) {
                    const t1 = i / segments;
                    const t2 = (i + 1) / segments;
                    const color = lerpColor(startColor, endColor, t2);
                    const alpha = 0.35 + 0.45 * t2;
                    const x1 = core.x + dx * t1;
                    const y1 = core.y + dy * t1;
                    const x2 = core.x + dx * t2;
                    const y2 = core.y + dy * t2;
                    gfx.lineStyle(thickness, color, alpha).moveTo(x1, y1).lineTo(x2, y2);
                }
            }

            function updateTether() {
                drawTetherGraphics(tether, player.x, player.y);
                for (const clone of clones) {
                    if (clone.gfx.visible) {
                        drawTetherGraphics(clone.tether, clone.position.x, clone.position.y, 0x7dfbff);
                    } else {
                        clone.tether.clear();
                    }
                }
            }

            function updateTrail() {
                trailGfx.clear();
                for (let i = trailPoints.length - 1; i >= 0; i--) {
                    let point = trailPoints[i];
                    point.lifetime--;
                    const alpha = Math.max(0, point.lifetime / dynamicTrailDuration);
                    const scale = Math.max(0, point.lifetime / dynamicTrailDuration);
                    trailGfx.beginFill(point.tint, alpha * 0.5).drawCircle(point.x, point.y, dynamicTrailSize * scale).endFill();
                    if (point.lifetime <= 0) { trailPoints.splice(i, 1); }
                }
            }

            function createSplash(x, y, color, amount) {
                // Use performance-optimized particle system
                if (window.performanceOptimizer) {
                    const optimized = performanceOptimizer.createOptimizedSplash(x, y, color, amount);
                    amount = optimized.amount; // Use reduced amount for better performance
                }
                
                // Apply performance limits
                const maxParticles = window.performanceOptimizer ? 
                    performanceOptimizer.settings.maxParticles : 100;
                if (particles.length > maxParticles) {
                    particles.splice(0, particles.length - maxParticles);
                }
                
                for (let i = 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 4;
                    particles.push({
                        x, y, color,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        lifetime: 20 + Math.random() * 20,
                        alpha: 1.0,
                    });
                }
            }

            function updateParticles() {
                particlesGfx.clear();
                
                // Apply performance limits to prevent FPS drops
                const maxParticles = window.performanceOptimizer ? 
                    performanceOptimizer.settings.maxParticles : 100;
                if (particles.length > maxParticles) {
                    particles.splice(0, particles.length - maxParticles);
                }
                
                // Batch rendering by color for better performance
                const colorBatches = {};
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx; p.y += p.vy;
                    p.vx *= 0.95; p.vy *= 0.95;
                    p.lifetime--;
                    p.alpha = Math.max(0, p.lifetime / 40);

                    if (p.lifetime <= 0) { 
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    // Group particles by color for batching
                    if (!colorBatches[p.color]) {
                        colorBatches[p.color] = [];
                    }
                    colorBatches[p.color].push(p);
                }
                
                // Render each color batch
                Object.keys(colorBatches).forEach(color => {
                    particlesGfx.beginFill(parseInt(color));
                    colorBatches[color].forEach(p => {
                        particlesGfx.drawCircle(p.x, p.y, 2);
                    });
                    particlesGfx.endFill();
                });
            }
            
            function updateSlowMotion() {
                if (slowMoTimer > 0) {
                    slowMoTimer--;
                    const halfDuration = dynamicSlowMoDuration / 2;
                    const progress = Math.abs(slowMoTimer - halfDuration) / halfDuration;
                    const easedProgress = easeInOutCubic(1 - progress);

                    app.ticker.speed = 1.0 - (1.0 - dynamicSlowMoStrength) * easedProgress;
                    
                    const targetScale = 1 + (dynamicCameraZoom - 1) * easedProgress;
                    app.stage.scale.set(targetScale);
                    
                    // Keep camera perfectly still - no movement at all
                    app.stage.pivot.set(0, 0);
                    app.stage.position.set(0, 0);

                } else if (app.ticker.speed !== 1.0) {
                    app.ticker.speed = 1.0;
                    app.stage.scale.set(1.0);
                    app.stage.pivot.set(0, 0);
                    app.stage.position.set(0, 0);
                    slowMoTarget = null;
                }
            }

            const NEW_CORE_UPGRADES = {
                size: {
                    label: 'Mass Amplifier',
                    color: 0xffe066,
                    apply() {
                        if (!permanentEffects.sizeBonus) permanentEffects.sizeBonus = 0;
                        permanentEffects.sizeBonus += 0.25;
                        refreshSizeMultiplier();
                    }
                },
                healing: {
                    label: 'Eternal Pulse',
                    color: 0x7dfbff,
                    apply() {
                        permanentEffects.healingRate += 1.2;
                    }
                },
                mirror: {
                    label: 'Echo Twin',
                    color: 0x9cf9ff,
                    apply() {
                        permanentEffects.mirrorTier++;
                        recalculateMirrorTier();
                        createMirrorClones();
                    }
                }
            };

            function createNewCoreGraphic(config) {
                const container = new PIXI.Container();
                
                // Create sparkling aura background
                const sparkleContainer = new PIXI.Container();
                for (let i = 0; i < 12; i++) {
                    const sparkle = new PIXI.Graphics();
                    const sparkleSize = 2 + Math.random() * 3;
                    const sparkleAngle = (Math.PI * 2 / 12) * i + Math.random() * 0.5;
                    const sparkleDistance = 45 + Math.random() * 15;
                    
                    sparkle.beginFill(config.color, 0.7 + Math.random() * 0.3);
                    sparkle.drawStar(0, 0, 4, sparkleSize, sparkleSize * 0.6);
                    sparkle.endFill();
                    
                    sparkle.x = Math.cos(sparkleAngle) * sparkleDistance;
                    sparkle.y = Math.sin(sparkleAngle) * sparkleDistance;
                    sparkle.rotation = Math.random() * Math.PI * 2;
                    
                    // Store animation data
                    sparkle.animData = {
                        baseDistance: sparkleDistance,
                        angle: sparkleAngle,
                        rotationSpeed: (Math.random() - 0.5) * 0.1,
                        pulsePhase: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.05 + Math.random() * 0.03
                    };
                    
                    sparkleContainer.addChild(sparkle);
                }
                container.addChild(sparkleContainer);
                container.sparkleContainer = sparkleContainer;

                // Main body with enhanced glow
                const body = new PIXI.Graphics();
                body.lineStyle(6, config.color, 0.95).drawCircle(0, 0, 30);
                body.beginFill(config.color, 0.35).drawCircle(0, 0, 22).endFill();
                body.lineStyle(2, 0xffffff, 0.8).drawCircle(0, 0, 26);
                container.addChild(body);

                // Magical rim with pulsing effect
                const rim = new PIXI.Graphics();
                rim.lineStyle(3, 0xffffff, 0.9).drawCircle(0, 0, 38);
                rim.lineStyle(1, config.color, 0.7).drawCircle(0, 0, 42);
                container.addChild(rim);
                container.rim = rim;

                // Enhanced icon with core color theme
                const icon = new PIXI.Graphics();
                if (config === NEW_CORE_UPGRADES.size) {
                    icon.beginFill(config.color, 0.9).drawPolygon([-12, -8, 12, -8, 0, 16]).endFill();
                    icon.lineStyle(2, 0xffffff, 0.8).drawPolygon([-12, -8, 12, -8, 0, 16]);
                } else if (config === NEW_CORE_UPGRADES.healing) {
                    icon.lineStyle(4, config.color, 0.9).moveTo(-12, 0).lineTo(12, 0).moveTo(0, -12).lineTo(0, 12);
                    icon.lineStyle(2, 0xffffff, 0.7).moveTo(-10, 0).lineTo(10, 0).moveTo(0, -10).lineTo(0, 10);
                } else {
                    icon.lineStyle(4, config.color, 0.9).drawCircle(0, 0, 12);
                    icon.lineStyle(2, 0xffffff, 0.7).drawCircle(0, 0, 10);
                    icon.moveTo(-12, 0).lineTo(12, 0).moveTo(0, -12).lineTo(0, 12);
                }
                container.addChild(icon);

                // Enhanced label with glow
                const label = new PIXI.Text(config.label, {
                    fontFamily: 'Press Start 2P',
                    fontSize: 14,
                    fill: '#ffffff',
                    align: 'center',
                    stroke: config.color,
                    strokeThickness: 2,
                });
                label.anchor.set(0.5, -1.8);
                container.addChild(label);

                // Add intense glow filter
                container.filters = [new PIXI.filters.GlowFilter({ 
                    distance: 25, 
                    outerStrength: 3.5, 
                    color: config.color,
                    innerStrength: 2
                })];

                return container;
            }

            function showLevelText(level) {
                const levelText = document.getElementById('level-text');
                levelText.textContent = `WAVE ${level}`;
                levelText.style.display = 'block';
                levelText.classList.add('flash');
                levelText.style.color = '#ffffff';
                levelText.style.textShadow = '0 0 20px #ffffff, 0 0 40px #aaaaff';
                levelText.style.zIndex = '1000'; // Ensure it's on top
                setTimeout(() => {
                    levelText.style.display = 'none';
                    levelText.classList.remove('flash');
                }, 2000); // Longer display duration
            }

            function launchNewCoreSelection() {
                if (isGameOver || isCoreChoiceActive) return;

                showLevelText(coreRunCount + 1);
                createSplash(core.x, core.y, 0xffffff, 150);

                const availableTypes = Array.from(collectedUpgradeHistory).filter(type => {
                    if (type === 'size') return permanentEffects.sizeBonus === 0;
                    if (type === 'healing') return permanentEffects.healingRate === 0;
                    if (type === 'mirror') return true;
                    return false;
                });

                if (!availableTypes.length) {
                    coreChoiceTimer = 0;
                    return;
                }

                isCoreChoiceActive = true;
                newCoreContainer.visible = true;
                newCoreContainer.removeChildren();
                newCoreChoices = [];
                
                // Ensure eternal upgrades are rendered on top of all other graphics
                app.stage.removeChild(newCoreContainer);
                app.stage.addChild(newCoreContainer);

                const total = availableTypes.length;
                // Reworked eternal upgrade orbit logic to be based on dynamicMaxLength * dynamicOvershoot,
                // have a small outer margin, and clamp inward when the core swells.
                const ropeReach = dynamicMaxLength * dynamicOvershoot;
                const pickupCollisionRadius = 36;
                const maxOffset = Math.max(0, ropeReach - currentCoreRadius - pickupCollisionRadius);
                let orbitOffset = 0;
                if (maxOffset > 0) {
                    const preferredOffset = Math.min(60, Math.max(30, (ropeReach * 0.95) - currentCoreRadius));
                    orbitOffset = Math.min(preferredOffset, maxOffset);
                    if (orbitOffset < 12 && maxOffset >= 12) {
                        orbitOffset = 12;
                    }
                }
                const radius = currentCoreRadius + orbitOffset;

                availableTypes.forEach((type, index) => {
                    const cfg = NEW_CORE_UPGRADES[type];
                    if (!cfg) return;

                    const startFromTop = index % 2 === 0;
                    const startY = startFromTop ? center.y - radius - 240 : center.y + radius + 240;
                    const startX = center.x;
                    const baseAngle = (Math.PI * 2 / total) * index;
                    const target = {
                        x: center.x + Math.cos(baseAngle) * radius,
                        y: center.y + Math.sin(baseAngle) * radius
                    };

                    const gfx = createNewCoreGraphic(cfg);
                    gfx.position.set(startX, startY);
                    newCoreContainer.addChild(gfx);

                    newCoreChoices.push({
                        type,
                        gfx,
                        config: cfg,
                        start: { x: startX, y: startY },
                        target,
                        angle: baseAngle,
                        radius,
                        state: 'approach',
                        progress: 0
                    });
                });
            }

            function updateNewCoreSelection(delta) {
                if (!isCoreChoiceActive) return;

                const approachFrames = 90;
                const orbitSpeed = 0.0025 * delta;

                // Darken all background elements during eternal upgrades
                const darkenAlpha = 0.3;
                
                // Darken enemies
                enemies.forEach(enemy => {
                    if (enemy.gfx.alpha > darkenAlpha) {
                        enemy.gfx.alpha = Math.max(darkenAlpha, enemy.gfx.alpha - 0.02 * delta);
                    }
                });
                
                // Darken powerups
                powerUps.forEach(powerUp => {
                    if (powerUp.gfx.alpha > darkenAlpha) {
                        powerUp.gfx.alpha = Math.max(darkenAlpha, powerUp.gfx.alpha - 0.02 * delta);
                    }
                });
                
                // Darken healing items
                healingItems.forEach(item => {
                    if (item.gfx.alpha > darkenAlpha) {
                        item.gfx.alpha = Math.max(darkenAlpha, item.gfx.alpha - 0.02 * delta);
                    }
                });

                for (const choice of newCoreChoices) {
                    // Animate sparkling aura
                    if (choice.gfx.sparkleContainer) {
                        choice.gfx.sparkleContainer.children.forEach(sparkle => {
                            if (sparkle.animData) {
                                const data = sparkle.animData;
                                data.pulsePhase += data.pulseSpeed * delta;
                                
                                // Pulsing distance animation
                                const pulseFactor = 1 + Math.sin(data.pulsePhase) * 0.3;
                                const newDistance = data.baseDistance * pulseFactor;
                                sparkle.x = Math.cos(data.angle) * newDistance;
                                sparkle.y = Math.sin(data.angle) * newDistance;
                                
                                // Rotation animation
                                sparkle.rotation += data.rotationSpeed * delta;
                                
                                // Alpha pulsing
                                sparkle.alpha = 0.4 + Math.sin(data.pulsePhase * 1.5) * 0.6;
                            }
                        });
                    }
                    
                    // Animate magical rim pulsing
                    if (choice.gfx.rim) {
                        const pulseIntensity = 0.7 + Math.sin(Date.now() * 0.005) * 0.3;
                        choice.gfx.rim.alpha = pulseIntensity;
                    }
                    
                    if (choice.state === 'approach') {
                        choice.progress = Math.min(1, choice.progress + delta / approachFrames);
                        const ease = 1 - Math.pow(1 - choice.progress, 3);
                        choice.gfx.x = choice.start.x + (choice.target.x - choice.start.x) * ease;
                        choice.gfx.y = choice.start.y + (choice.target.y - choice.start.y) * ease;
                        if (choice.progress >= 1) {
                            choice.state = 'orbit';
                            choice.progress = 0;
                        }
                    } else {
                        choice.angle += orbitSpeed;
                        choice.gfx.x = center.x + Math.cos(choice.angle) * choice.radius;
                        choice.gfx.y = center.y + Math.sin(choice.angle) * choice.radius;
                    }

                    const dist = Math.hypot(player.x - choice.gfx.x, player.y - choice.gfx.y);
                    if (dist <= 36) {
                        finalizeNewCoreChoice(choice);
                        break;
                    }
                }
            }

            function finalizeNewCoreChoice(choice) {
                choice.config.apply();
                collectedUpgradeHistory.delete(choice.type);

                destroyAllEnemiesWithShockwave();
                recalcDifficultyScaling();

                newCoreContainer.visible = false;
                newCoreContainer.removeChildren();
                newCoreChoices = [];
                isCoreChoiceActive = false;
                coreChoiceTimer = 0;
            }

            function destroyAllEnemiesWithShockwave() {
                createSplash(core.x, core.y, 0xffffff, 200);
                enemies.forEach(enemy => {
                    createSplash(enemy.gfx.x, enemy.gfx.y, enemy.baseColor || 0xffffff, 80);
                    app.stage.removeChild(enemy.gfx);
                });
                enemies.length = 0;
                enemyProjectiles.length = 0;
                enemyProjectilesGfx.clear();
            }

            function recalcDifficultyScaling() {
                coreRunCount += 1;
                enemySpawnIntensity *= 1.10;
                enemySpeedMultiplier *= 1.05;
                enemySpawnAccumulator = 0;
            }

            function applyPermanentHealingTick(delta) {
                if (permanentEffects.healingRate <= 0 || isGameOver) return;
                const healAmount = (permanentEffects.healingRate / 60) * delta;
                if (healAmount > 0) {
                    applyCoreHealing(healAmount);
                    coreHealingTimer = Math.max(coreHealingTimer, 30);
                }
            }

            function spawnEnemy(forcedType) {
                const typeKey = forcedType || chooseEnemyType();
                const config = enemyTypes[typeKey] || enemyTypes.red;
                const gfx = config.createGfx ? config.createGfx() : new PIXI.Graphics().beginFill(config.color || 0xff4a4a).drawCircle(0, 0, config.radius || 10).endFill();
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(app.screen.width, app.screen.height) / 2 + 70;
                gfx.position.set(center.x + Math.cos(angle) * radius, center.y + Math.sin(angle) * radius);

                const baseHealth = Math.max(1, config.getHealth ? config.getHealth() : dynamicEnemyHealth);
                const enemy = {
                    type: typeKey,
                    gfx,
                    health: baseHealth,
                    maxHealth: baseHealth,
                    hitTimer: 0,
                    baseColor: config.color || 0xff4a4a,
                    visualBaseTint: config.color || 0xff4a4a,
                    collisionRadius: config.radius || 10,
                    spawnAngle: angle,
                    spawnRadius: radius,
                    state: 'default',
                    data: {},
                };

                if (!gfx.filters || gfx.filters.length === 0) {
                    const glowColor = config.glowColor || config.color || 0xff4a4a;
                    gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.1, color: glowColor })];
                }

                if (config.onSpawn) {
                    config.onSpawn(enemy);
                }

                if (typeof enemy.speed === 'number') {
                    enemy.speed *= enemySpeedMultiplier;
                }
                if (enemy.data && typeof enemy.data === 'object') {
                    for (const key of Object.keys(enemy.data)) {
                        if (/speed/i.test(key) && typeof enemy.data[key] === 'number') {
                            enemy.data[key] *= enemySpeedMultiplier;
                        }
                    }
                }

                app.stage.addChild(gfx);
                enemies.push(enemy);
            }



            function checkTrailCollision(enemy, currentPos, previousPos, hitRadius) {
                // Check collision along the trail between previous and current position
                const dx = currentPos.x - previousPos.x;
                const dy = currentPos.y - previousPos.y;
                const length = Math.hypot(dx, dy);
                
                if (length < 0.1) {
                    // If movement is minimal, just check current position
                    return Math.hypot(currentPos.x - enemy.gfx.x, currentPos.y - enemy.gfx.y) < hitRadius;
                }
                
                // Normalize the movement vector
                const stepX = dx / length;
                const stepY = dy / length;
                
                // Check multiple points along the trail
                const steps = Math.ceil(length / 10); // Check every 10 pixels along the trail
                for (let step = 0; step <= steps; step++) {
                    const t = step / steps;
                    const trailX = previousPos.x + dx * t;
                    const trailY = previousPos.y + dy * t;
                    
                    const distToEnemy = Math.hypot(trailX - enemy.gfx.x, trailY - enemy.gfx.y);
                    if (distToEnemy < hitRadius) {
                        return true;
                    }
                }
                
                return false;
            }

            function updateEnemies(delta) {
                if (isCoreChoiceActive) return;
                delta = delta || 1;
                const speed = Math.hypot(player.vx, player.vy);
                const dist = Math.hypot(player.x - core.x, player.y - core.y);
                const isCritical = dist > dynamicMaxLength * 0.95 && speed > dynamicCriticalSpeed;

                const currentPos = { x: player.x, y: player.y };
                const hitRadius = 20 * activeEffects.sizeMultiplier;

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const config = enemyTypes[enemy.type] || enemyTypes.red;

                    if (config.update) {
                        config.update(enemy, delta);
                    }

                    if (!enemy.visualBaseTint) {
                        enemy.visualBaseTint = enemy.baseColor;
                    }

                    if (enemy.hitTimer > 0) {
                        enemy.hitTimer -= delta;
                        if (enemy.hitTimer < 0) enemy.hitTimer = 0;
                        const flash = Math.sin(enemy.hitTimer * 0.5) > 0; // Faster flash
                        enemy.gfx.tint = flash ? 0xffffff : enemy.visualBaseTint;
                    } else {
                        enemy.gfx.tint = enemy.visualBaseTint;
                    }

                    let hitSource = null;
                    if (enemy.hitTimer === 0) {
                        const hitSources = [
                            { isMirror: false, current: currentPos, previous: previousPlayerPosition }
                        ];
                        for (const clone of clones) {
                            if (clone.gfx.visible) {
                                hitSources.push({
                                    isMirror: true,
                                    current: clone.position,
                                    previous: clone.previousPosition
                                });
                            }
                        }
                        for (const source of hitSources) {
                            if (checkTrailCollision(enemy, source.current, source.previous, hitRadius)) {
                                hitSource = source;
                                break;
                            }
                        }
                    }

                    if (hitSource) {
                        if (isReturning) {
                            backshots++;
                        }
                        if (isCritical) {
                            criticalHits++;
                        }
                        
                        const damageDealt = isCritical ? 2 : 1;
                        const enemyHealthBefore = enemy.health;
                        enemy.health -= damageDealt;
                        enemy.hitTimer = 10;
                        vibrationTimer = isCritical ? 15 * dynamicCritVibrationMultiplier : 15;
                        createSplash(enemy.gfx.x, enemy.gfx.y, enemy.baseColor, dynamicSplashAmount / (isCritical ? 1 : 2));
                        
                        // DART BOUNCING: If enemy survives the hit, bounce the dart back
                        if (enemy.health > 0 && enemyHealthBefore > 0) {
                            // Calculate bounce direction (inverse of current velocity)
                            const bounceMultiplier = 0.8; // Reduce velocity slightly on bounce
                            player.vx *= -bounceMultiplier;
                            player.vy *= -bounceMultiplier;
                            
                            // Force immediate return to core
                            isReturning = true;
                            
                            // Add some visual feedback for the bounce
                            createSplash(hitSource.current.x, hitSource.current.y, 0xFFFF00, 25);
                            
                            // Play bounce sound
                            if (soundModule) {
                                soundModule.createOneShot({
                                    type: 'triangle',
                                    frequency: nearestAmFrequency(300 + Math.random() * 200),
                                    attack: 0.01,
                                    release: 0.2,
                                    duration: 0.25,
                                    volume: 0.15,
                                });
                            }
                        }
                        
                        if (isCritical && slowMoTimer <= 0) {
                            slowMoTimer = dynamicSlowMoDuration;
                            slowMoTarget = { x: enemy.gfx.x, y: enemy.gfx.y };
                        }
                        if (config.onHit) {
                            config.onHit(enemy, { isCritical });
                        }
                        
                        // CRITICAL HIT MECHANIC: Green arrow enemy instant kill during charge state
                        if (enemy.type === 'green' && enemy.state === 'charge') {
                            // Instant kill with critical hit effects
                            enemy.health = 0;
                            criticalHits++; // Count as additional critical hit
                            
                            // Enhanced visual effects for critical kill
                            createSplash(enemy.gfx.x, enemy.gfx.y, 0xFFFFFF, dynamicSplashAmount * 2);
                            createSplash(enemy.gfx.x, enemy.gfx.y, 0x7dff88, dynamicSplashAmount);
                            
                            // Play special critical kill sound
                            if (soundModule) {
                                soundModule.createOneShot({
                                    type: 'sawtooth',
                                    frequency: nearestAmFrequency(600 + Math.random() * 300),
                                    attack: 0.01,
                                    release: 0.4,
                                    duration: 0.5,
                                    volume: 0.25,
                                });
                            }
                            
                            // Force slow motion effect
                            if (slowMoTimer <= 0) {
                                slowMoTimer = dynamicSlowMoDuration * 1.5; // Longer slow mo for critical kill
                                slowMoTarget = null; // No camera movement
                            }
                        }
                    }

                    if (enemy.health <= 0) {
                        kills++;
                        createSplash(enemy.gfx.x, enemy.gfx.y, 0xffffff, dynamicSplashAmount * 1.5);
                        playEnemyImpactSFX(isCritical, currentCombo + 1);
                        if (config.onDeath) {
                            config.onDeath(enemy);
                        }
                        app.stage.removeChild(enemy.gfx);
                        enemies.splice(i, 1);
                        currentCombo++;
                        maxComboInGame = Math.max(maxComboInGame, currentCombo);
                        score += 10 * currentCombo;
                        scoreText.textContent = `Pontuação: ${score}`;
                        comboText.textContent = `Combo: x${currentCombo}`;
                        continue;
                    }

                    const distToCore = Math.hypot(core.x - enemy.gfx.x, core.y - enemy.gfx.y);
                    if (distToCore < currentCoreRadius + enemy.collisionRadius) {
                        const damageAmount = config.getCoreDamage ? config.getCoreDamage(enemy) : dynamicMaxLength * 0.10;
                        applyCoreDamage(damageAmount, enemy.gfx.x, enemy.gfx.y, enemy.baseColor);
                        if (config.onCoreHit) {
                            config.onCoreHit(enemy);
                        }
                        app.stage.removeChild(enemy.gfx);
                        enemies.splice(i, 1);
                    }
                }
            }



            function refreshCoreVisual() {
                core.clear();
                core.beginFill(CORE_BASE_COLOR).drawCircle(0, 0, currentCoreRadius).endFill();
                core.width = core.height = currentCoreRadius * 2;
                updateCoreStatus();
            }

            function applyCoreDamage(amount, impactX, impactY, splashColor = 0xffffff) {
                if (nextHitKills) {
                    startDeathSequence();
                    return;
                }
                coreHitTimer = 20;
                createSplash(impactX, impactY, splashColor, dynamicSplashAmount);
                playCoreDamageSFX();

                if (slowMoTimer <= 0) {
                    slowMoTimer = dynamicSlowMoDuration / 2;
                    slowMoTarget = { x: core.x, y: core.y };
                }

                currentCoreRadius += amount;
                refreshCoreVisual();
                coreCracks.alpha = Math.min(1, coreCracks.alpha + amount / (dynamicMaxLength * 0.8));

                const impactAngle = Math.atan2(impactY - core.y, impactX - core.x);
                const crackLength = currentCoreRadius * (0.4 + Math.random() * 0.3);
                const startX = Math.cos(impactAngle) * currentCoreRadius;
                const startY = Math.sin(impactAngle) * currentCoreRadius;
                coreCracks.lineStyle(1.5, 0x000000, 0.6)
                    .moveTo(startX, startY)
                    .lineTo(startX - Math.cos(impactAngle) * crackLength, startY - Math.sin(impactAngle) * crackLength);
            }


            function applyCoreHealing(amount) {
                if (amount <= 0) return;
                const previousRadius = currentCoreRadius;
                currentCoreRadius = Math.max(30, currentCoreRadius - amount);
                if (currentCoreRadius === previousRadius) {
                    return;
                }
                refreshCoreVisual();
                coreCracks.alpha = Math.max(0.25, coreCracks.alpha - amount / (dynamicMaxLength * 1.2));
            }

            function spawnHealingItem() {
                const gfx = new PIXI.Graphics();
                gfx.beginFill(0x7dfbff, 0.25).drawCircle(0, 0, 14).endFill();
                gfx.lineStyle(2, 0xdfffff, 0.85).drawCircle(0, 0, 17);
                gfx.filters = [new PIXI.filters.GlowFilter({ distance: 12, outerStrength: 1.4, color: 0x7dfbff })];
            
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(app.screen.width, app.screen.height) / 2 + 70;
                gfx.position.set(center.x + Math.cos(angle) * radius, center.y + Math.sin(angle) * radius);
            
                const item = {
                    gfx,
                    speed: 1.4,
                    noisePhase: Math.random() * Math.PI * 2,
                    noiseSpeed: 0.045 + Math.random() * 0.025,
                    noiseAmplitude: 50 + Math.random() * 20
                };
                healingItemsContainer.addChild(gfx);
                healingItems.push(item);
            }
            
            function collectHealingItem(index, item, reachedCore) {
                healingItemsContainer.removeChild(item.gfx);
                healingItems.splice(index, 1);
                const healAmount = reachedCore ? dynamicMaxLength * 0.08 : dynamicMaxLength * 0.12;
                const duration = 240;
                registerTemporaryUpgrade('healing');
                activeEffects.healing.push({
                    amount: healAmount,
                    remaining: healAmount,
                    duration,
                    timer: duration
                });
                coreHealingTimer = Math.max(coreHealingTimer, 90);
                createSplash(item.gfx.x, item.gfx.y, 0x7dfbff, 40);
                if (typeof soundModule !== 'undefined' && soundModule && typeof soundModule.createOneShot === 'function') {
                    soundModule.createOneShot({
                        type: 'sine',
                        frequency: 420,
                        attack: 0.02,
                        release: 0.9,
                        duration: 0.8,
                        volume: 0.3
                    });
                }
            }
            
            function updateHealingItems(delta) {
                if (dangerWaveState === 'cooldown' && healingItems.length === 0) {
                    healingSpawnTimer -= delta;
                    if (healingSpawnTimer <= 0) {
                        spawnHealingItem();
                        healingSpawnTimer = 1200 + Math.random() * 720;
                    }
                }
            
                
for (let i = healingItems.length - 1; i >= 0; i--) {
                    const item = healingItems[i];
                    const dx = core.x - item.gfx.x;
                    const dy = core.y - item.gfx.y;
                    const dist = Math.hypot(dx, dy);
                    const nx = dx / (dist || 1);
                    const ny = dy / (dist || 1);
                    const perpX = -ny;
                    const perpY = nx;
            
                    item.noisePhase += item.noiseSpeed * delta;
                    const sway = Math.sin(item.noisePhase) * item.noiseAmplitude;
            
                    const move = item.speed * delta;
                    item.gfx.x += nx * move + perpX * sway * 0.02 * delta;
                    item.gfx.y += ny * move + perpY * sway * 0.02 * delta;
            
                    const bob = 0.9 + Math.sin(item.noisePhase * 2) * 0.08;
                    item.gfx.scale.set(bob, bob);
            
                    if (Math.hypot(player.x - item.gfx.x, player.y - item.gfx.y) < 28 || dist < currentCoreRadius + 8) {
                        collectHealingItem(i, item, dist < currentCoreRadius + 8);
                        continue;
                    }
            
                    const screenRadius = Math.max(app.screen.width, app.screen.height) * 1.2;
                    if (Math.hypot(item.gfx.x - center.x, item.gfx.y - center.y) > screenRadius) {
                        healingItemsContainer.removeChild(item.gfx);
                        healingItems.splice(i, 1);
                    }
                }
            }
            
            function updateHealingEffects(delta) {
                if (!activeEffects.healing.length) return;
                let totalHeal = 0;
                for (let i = activeEffects.healing.length - 1; i >= 0; i--) {
                    const effect = activeEffects.healing[i];
                    const healRate = effect.amount / effect.duration;
                    const healStep = Math.min(effect.remaining, healRate * delta);
                    effect.remaining -= healStep;
                    effect.timer -= delta;
                    totalHeal += healStep;
                    if (effect.remaining <= 0 || effect.timer <= 0) {
                        activeEffects.healing.splice(i, 1);
                    }
                }
                if (totalHeal > 0) {
                    applyCoreHealing(totalHeal);
                    coreHealingTimer = Math.max(coreHealingTimer, 60);
                }
            }
            
            // Standalone arrow functions
            function createArrowProjectile(enemy, angle) {
                const speed = 3.5;
                
                enemyProjectiles.push({
                    type: 'arrow',
                    ownerType: 'emeraldBow',
                    owner: enemy,
                    x: enemy.gfx.x,
                    y: enemy.gfx.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    angle: angle,
                    color: 0x7dff88,
                    size: 6,
                    lifetime: 300,
                    coreDamage: dynamicMaxLength * 0.15,
                    isArrow: true
                });
            }
            
            function createDeflectedArrow(enemy, direction) {
                const speed = 3.5 * 1.2;
                const angle = Math.atan2(direction.y, direction.x) + Math.PI; // Reverse direction
                
                enemyProjectiles.push({
                    type: 'deflected_arrow',
                    ownerType: 'player',
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    angle: angle,
                    color: 0xffff00,
                    size: 8,
                    lifetime: 300,
                    targetEnemy: enemy,
                    isDeflectedArrow: true
                });
            }

            // Enemy system methods for arrow mechanics
            window.gameState = {
                core,
                currentCoreRadius,
                config: { physics: { maxLength: dynamicMaxLength } },
                isDangerState,
                enemySystem: {
                    createArrowProjectile,
                    createDeflectedArrow,
                    createPinkArcProjectiles
                }
            };

            function updateEnemyProjectiles(delta) {
                if (isCoreChoiceActive) return;
                if (enemyProjectiles.length === 0) {
                    enemyProjectilesGfx.clear();
                    return;
                }

                delta = delta || 1;
                enemyProjectilesGfx.clear();

                const hitRadius = 18 * activeEffects.sizeMultiplier;
                const segments = [
                    { isMirror: false, current: { x: player.x, y: player.y }, previous: previousPlayerPosition }
                ];
                for (const clone of clones) {
                    if (clone.gfx.visible) {
                        segments.push({
                            isMirror: true,
                            current: clone.position,
                            previous: clone.previousPosition
                        });
                    }
                }
                const tempTarget = { gfx: { x: 0, y: 0 } };

                for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                    const projectile = enemyProjectiles[i];
                    
                    // Handle different projectile types
                    if (projectile.isArrow || projectile.isDeflectedArrow) {
                        // Linear movement for arrows
                        projectile.x += projectile.vx * delta;
                        projectile.y += projectile.vy * delta;
                        projectile.lifetime -= delta;

                        // Draw arrow shape
                        const arrowLength = 12;
                        const arrowWidth = 6;
                        const angle = projectile.angle;
                        
                        enemyProjectilesGfx.beginFill(projectile.color, 0.9);
                        // Arrow head (triangle)
                        const headX = projectile.x + Math.cos(angle) * arrowLength;
                        const headY = projectile.y + Math.sin(angle) * arrowLength;
                        const leftX = projectile.x + Math.cos(angle + Math.PI * 0.8) * arrowWidth;
                        const leftY = projectile.y + Math.sin(angle + Math.PI * 0.8) * arrowWidth;
                        const rightX = projectile.x + Math.cos(angle - Math.PI * 0.8) * arrowWidth;
                        const rightY = projectile.y + Math.sin(angle - Math.PI * 0.8) * arrowWidth;
                        
                        enemyProjectilesGfx.moveTo(headX, headY);
                        enemyProjectilesGfx.lineTo(leftX, leftY);
                        enemyProjectilesGfx.lineTo(rightX, rightY);
                        enemyProjectilesGfx.closePath();
                        enemyProjectilesGfx.endFill();
                        
                        // Arrow shaft (line)
                        enemyProjectilesGfx.lineStyle(2, projectile.color, 0.8);
                        enemyProjectilesGfx.moveTo(projectile.x, projectile.y);
                        enemyProjectilesGfx.lineTo(projectile.x - Math.cos(angle) * arrowLength, 
                                                 projectile.y - Math.sin(angle) * arrowLength);
                        
                        // Handle deflected arrow hitting its target
                        if (projectile.isDeflectedArrow && projectile.targetEnemy) {
                            const distToTarget = Math.hypot(projectile.x - projectile.targetEnemy.gfx.x, 
                                                          projectile.y - projectile.targetEnemy.gfx.y);
                            if (distToTarget < 25) {
                                // Destroy the bow enemy instantly
                                createSplash(projectile.targetEnemy.gfx.x, projectile.targetEnemy.gfx.y, 0xffff00, 80);
                                createSplash(projectile.targetEnemy.gfx.x, projectile.targetEnemy.gfx.y, 0x7dff88, 40);
                                
                                // Remove enemy
                                const enemyIndex = enemies.indexOf(projectile.targetEnemy);
                                if (enemyIndex >= 0) {
                                    app.stage.removeChild(projectile.targetEnemy.gfx);
                                    enemies.splice(enemyIndex, 1);
                                    
                                    // Award score and combo
                                    kills++;
                                    currentCombo++;
                                    maxComboInGame = Math.max(maxComboInGame, currentCombo);
                                    score += 20 * currentCombo; // Double points for deflection kill
                                    scoreText.textContent = `Pontuação: ${score}`;
                                    comboText.textContent = `Combo: x${currentCombo}`;
                                }
                                
                                enemyProjectiles.splice(i, 1);
                                continue;
                            }
                        }
                        
                    } else {
                        // Original orbital projectile behavior (pink enemies)
                        projectile.angle += (projectile.angularVelocity || 0) * delta;
                        projectile.radius = Math.max(currentCoreRadius + 25, projectile.radius - (projectile.shrinkRate || 0) * delta);
                        projectile.lifetime -= delta;

                        const px = core.x + Math.cos(projectile.angle) * projectile.radius;
                        const py = core.y + Math.sin(projectile.angle) * projectile.radius;
                        projectile.x = px;
                        projectile.y = py;

                        enemyProjectilesGfx.beginFill(projectile.color || 0xffffff, 0.9);
                        enemyProjectilesGfx.drawCircle(px, py, projectile.size || 4);
                        enemyProjectilesGfx.endFill();
                    }

                    let destroyed = false;
                    tempTarget.gfx.x = projectile.x;
                    tempTarget.gfx.y = projectile.y;

                    // Check collision with player/clones (only for enemy projectiles, not deflected ones)
                    if (!projectile.isDeflectedArrow) {
                        for (const segment of segments) {
                            if (checkTrailCollision(tempTarget, segment.current, segment.previous, hitRadius)) {
                                const splashColor = segment.isMirror ? 0x7dfbff : (projectile.color || 0xffffff);
                                createSplash(projectile.x, projectile.y, splashColor, 16);

                                // Play destruction sound
                                if (projectile.soundFreq && soundModule) {
                                    soundModule.createOneShot({
                                        type: 'triangle',
                                        frequency: nearestAmFrequency(projectile.soundFreq),
                                        attack: 0.01,
                                        release: 0.2,
                                        duration: 0.25,
                                        volume: 0.15,
                                    });
                                }
                                
                                destroyed = true;
                                break;
                            }
                        }
                    }

                    // Check collision with core (only for enemy projectiles)
                    if (!destroyed && !projectile.isDeflectedArrow) {
                        const distToCore = Math.hypot(core.x - projectile.x, core.y - projectile.y);
                        if (distToCore < currentCoreRadius + (projectile.size || 4)) {
                            const damage = projectile.coreDamage || dynamicMaxLength * 0.05;
                            applyCoreDamage(damage, projectile.x, projectile.y, projectile.color || 0xffffff);
                            destroyed = true;
                        }
                    }

                    // Check lifetime expiry
                    if (!destroyed && projectile.lifetime <= 0) {
                        destroyed = true;
                    }

                    // Check screen bounds for arrows
                    if (!destroyed && (projectile.isArrow || projectile.isDeflectedArrow)) {
                        const screenBounds = Math.max(app.screen.width, app.screen.height) + 100;
                        if (Math.hypot(projectile.x - center.x, projectile.y - center.y) > screenBounds) {
                            destroyed = true;
                        }
                    }

                    if (destroyed) {
                        enemyProjectiles.splice(i, 1);
                    }
                }
            }

            function isDangerWaveOngoing() {
                return dangerWaveState === 'warning' || dangerWaveState === 'spawning' || dangerWaveState === 'active';
            }
            
            function chooseDangerWavePattern() {
                const available = dangerWavePatterns.filter(pattern => {
                    if (kills < 8 && pattern.entries.some(entry => entry.type === 'green')) {
                        return false;
                    }
                    if (score < 150 && pattern.entries.some(entry => entry.type === 'pink')) {
                        return false;
                    }
                    return true;
                });
                const pool = available.length ? available : dangerWavePatterns;
                return pool[Math.floor(Math.random() * pool.length)];
            }
            
            function setDangerOverlayWave(isActive) {
                if (isActive) {
                    dangerOverlay.classList.remove('hidden');
                    dangerOverlay.classList.add('active');
                    dangerOverlay.classList.add('wave-alert');
                } else {
                    dangerOverlay.classList.remove('wave-alert');
                }
            }
            
            function startDangerWave(pattern) {
                dangerWaveState = 'warning';
                dangerWaveWarningTimer = 90;
                dangerWaveQueue = pattern.entries.map(entry => ({
                    type: entry.type,
                    remaining: entry.count,
                    interval: entry.interval || 3,
                    timer: entry.initialDelay || 0,
                }));
                setDangerOverlayWave(true);
                if (typeof soundModule !== 'undefined' && soundModule && typeof soundModule.createOneShot === 'function') {
                    soundModule.createOneShot({
                        type: 'sawtooth',
                        frequency: 180,
                        attack: 0.01,
                        release: 0.6,
                        duration: 0.6,
                        volume: 0.45,
                    });
                }
            }
            
            function endDangerWave() {
                dangerWaveState = 'cooldown';
                dangerWaveTimer = 900 + Math.random() * 600;
                dangerWaveWarningTimer = 0;
                dangerWaveActiveTimer = 0;
                dangerWaveQueue = [];
                setDangerOverlayWave(false);
                healingSpawnTimer = Math.min(healingSpawnTimer, 360);
            }
            
            function updateDangerWaves(delta) {
                if (isGameOver || isCoreChoiceActive) return;
                switch (dangerWaveState) {
                    case 'cooldown':
                        dangerWaveTimer -= delta;
                        if (dangerWaveTimer <= 0 && enemies.length <= 18) {
                            const pattern = chooseDangerWavePattern();
                            startDangerWave(pattern);
                        }
                        break;
                    case 'warning':
                        dangerWaveWarningTimer -= delta;
                        if (dangerWaveWarningTimer <= 0) {
                            dangerWaveState = 'spawning';
                        }
                        break;
                    case 'spawning':
                        let hasRemaining = false;
                        for (const entry of dangerWaveQueue) {
                            if (entry.remaining <= 0) continue;
                            entry.timer -= delta;
                            if (entry.timer <= 0) {
                                spawnEnemy(entry.type);
                                entry.remaining--;
                                entry.timer = entry.interval;
                            }
                            if (entry.remaining > 0) {
                                hasRemaining = true;
                            }
                        }
                        if (!hasRemaining) {
                            dangerWaveState = 'active';
                            dangerWaveActiveTimer = 240;
                        }
                        break;
                    case 'active':
                        dangerWaveActiveTimer -= delta;
                        if (dangerWaveActiveTimer <= 0) {
                            endDangerWave();
                        }
                        break;
                }
            }


            function updateScalePowerups(delta) {
                // Update scale powerups with smooth ease-out transition
                for (let i = activeEffects.scalePowerups.length - 1; i >= 0; i--) {
                    const powerup = activeEffects.scalePowerups[i];
                    
                    if (!powerup.isEasing) {
                        // Normal duration countdown
                        powerup.duration -= delta;
                        
                        if (powerup.duration <= 0) {
                            // Start easing out
                            powerup.isEasing = true;
                            powerup.originalSizeIncrease = powerup.sizeIncrease;
                            powerup.easeTimer = powerup.easeOutDuration;
                        }
                    } else {
                        // Easing out phase
                        powerup.easeTimer -= delta;
                        
                        if (powerup.easeTimer <= 0) {
                            // Remove powerup completely
                            activeEffects.scalePowerups.splice(i, 1);
                        } else {
                            // Smooth ease out using cubic ease
                            const progress = 1 - (powerup.easeTimer / powerup.easeOutDuration);
                            const easedProgress = easeInOutCubic(progress);
                            powerup.sizeIncrease = powerup.originalSizeIncrease * (1 - easedProgress);
                        }
                    }
                }
                
                // Recalculate total size multiplier
                refreshSizeMultiplier();
            }

            function gameLoop(delta) {
                // Update performance optimizer first
                if (window.performanceOptimizer) {
                    performanceOptimizer.update(delta);
                }
                
                // Update debug info for mobile
                if (isMobile) {
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.innerHTML = `AX: ${motion.ax.toFixed(2)}<br>AY: ${motion.ay.toFixed(2)}<br>MX: ${motion.mx.toFixed(2)}<br>MY: ${motion.my.toFixed(2)}`;
                    }
                    
                    // Update pause menu debug info
                    updateDebugInfo();
                }

                updateSlowMotion();
                const effectiveDelta = delta * app.ticker.speed;
                const pausedDelta = isCoreChoiceActive ? 0 : effectiveDelta;
                updateScalePowerups(pausedDelta);
                updatePowerUps(pausedDelta);
                updateMirrorUpgrades(pausedDelta);
                updateHealingEffects(pausedDelta);

                // Store previous position before updating player
                previousPlayerPosition.x = player.x;
                previousPlayerPosition.y = player.y;
                
                updatePlayer(effectiveDelta);
                updateClones(effectiveDelta);
                updateTether(effectiveDelta);
                updateTrail(effectiveDelta);
                updateParticles(effectiveDelta);
                updateHealingItems(pausedDelta);

                if (!isCoreChoiceActive) {
                    coreChoiceTimer += effectiveDelta;
                    if (coreChoiceTimer >= CORE_CHOICE_INTERVAL) {
                        launchNewCoreSelection();
                    }
                }

                updateNewCoreSelection(effectiveDelta);
                applyPermanentHealingTick(effectiveDelta);

                if (!isCoreChoiceActive) {
                    enemySpawnTimer += effectiveDelta;
                    if (enemySpawnTimer > 60 && dangerWaveState === 'cooldown') {
                        enemySpawnAccumulator += enemySpawnIntensity;
                        const spawnCount = Math.floor(enemySpawnAccumulator);
                        if (spawnCount > 0) {
                            for (let i = 0; i < spawnCount; i++) {
                                spawnEnemy();
                            }
                            enemySpawnAccumulator -= spawnCount;
                        }
                        enemySpawnTimer = 0;
                    }
                    updateEnemies(effectiveDelta);
                    updateEnemyProjectiles(effectiveDelta);
                    updateDangerWaves(effectiveDelta);
                }



                // Check for critical mass explosion
                if (currentCoreRadius >= dynamicMaxLength * 1.5 && !isInCriticalMass) {
                    isInCriticalMass = true;
                    criticalMassTimer = 120; // 2 seconds at 60fps
                    
                    // Play critical mass warning sound
                    if (soundModule) {
                        soundModule.createOneShot({
                            type: 'sawtooth',
                            frequency: nearestAmFrequency(200),
                            attack: 0.1,
                            release: 2.0,
                            duration: 2.0,
                            volume: 0.4,
                        });
                    }
                }

                // Update critical mass countdown
                if (isInCriticalMass && criticalMassTimer > 0) {
                    criticalMassTimer--;
                    
                    // Dramatic increase in tension and vibration
                    const tensionLevel = (120 - criticalMassTimer) / 120; // 0 to 1 over 2 seconds
                    
                    // Intense screen shake
                    const shakeIntensity = tensionLevel * 15;
                    core.position.set(
                        center.x + (Math.random() - 0.5) * shakeIntensity,
                        center.y + (Math.random() - 0.5) * shakeIntensity
                    );
                    coreCracks.position.copyFrom(core.position);
                    
                    // Add vibration to player
                    vibrationTimer = Math.max(vibrationTimer, 30);
                    
                    // Intensify danger overlay
                    dangerOverlay.style.boxShadow = `inset 0 0 ${150 + tensionLevel * 200}px ${50 + tensionLevel * 100}px rgba(255, 0, 0, ${0.35 + tensionLevel * 0.4})`;
                    
                    // Screen fade effect as we approach explosion
                    if (criticalMassTimer <= 30) {
                        const fadeLevel = (30 - criticalMassTimer) / 30; // Last 0.5 seconds
                        app.view.style.filter = `brightness(${1 + fadeLevel * 2})`;
                    }
                    
                    // Final explosion
                    if (criticalMassTimer <= 0) {
                        startDeathSequence();
                    }
                }
            }
            app.ticker.add(gameLoop);

            function startDeathSequence() {
                if (isGameOver) return;
                isGameOver = true;
                if(document.pointerLockElement === app.view) document.exitPointerLock();

                // 1. Core explosion
                createSplash(core.x, core.y, 0xFFFFFF, 300); // Large white splash
                core.visible = false;
                coreCracks.visible = false;
                tether.visible = false;

                // 2. Shatter the dart
                player.visible = false;
                for (let i = 0; i < 15; i++) {
                    const angle = (Math.PI * 2 / 15) * i + (Math.random() - 0.5) * 0.2;
                    const speed = 1 + Math.random() * 3;
                    particles.push({
                        x: player.x, y: player.y, color: player.tint,
                        vx: Math.cos(angle) * speed + player.vx * 0.5, // Inherit some momentum
                        vy: Math.sin(angle) * speed + player.vy * 0.5,
                        lifetime: 60 + Math.random() * 60, alpha: 1.0,
                    });
                }

                // 3. Fade in game over screen after a delay
                setTimeout(endGame, 2000);
            }
            
            // Initial core draw
            core.beginFill(CORE_BASE_COLOR).drawCircle(0, 0, currentCoreRadius).endFill();
            core.width = core.height = currentCoreRadius * 2;
            updateCoreStatus();

            setupJoystick();
            app.ticker.stop();

            window.addEventListener('resize', () => {
                app.renderer.resize(window.innerWidth, window.innerHeight);
                center = { x: app.screen.width / 2, y: app.screen.height / 2 };
                core.position.set(center.x, center.y);
                const newMaxLength = 180;
                const maxLengthInput = document.getElementById('max-length-value');
                maxLengthInput.value = newMaxLength;
                dynamicMaxLength = newMaxLength;
                updateCoreStatus();

            });

            // Add simple performance monitoring
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F1') {
                    e.preventDefault();
                    if (window.performanceOptimizer) {
                        performanceOptimizer.settings.particleQuality = 0.5;
                        console.log('🎮 Performance: Quality set to 50%');
                    }
                }
                if (e.key === 'F2') {
                    e.preventDefault();
                    if (window.performanceOptimizer) {
                        performanceOptimizer.settings.particleQuality = 1.0;
                        console.log('🎮 Performance: Quality set to 100%');
                    }
                }
            });
        }
    </script>
</body>
</html>
