<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Guardião da Etérea - Protótipo v4.7 (Controles de Rastro)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.3/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-glow@3.2.0/dist/filter-glow.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(138, 43, 226, 0.04) 0%, 
                rgba(0, 191, 255, 0.02) 30%, 
                rgba(75, 0, 130, 0.03) 60%, 
                rgba(0, 0, 0, 0.98) 100%), 
                #000000;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        canvas.game-canvas {
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
        }
        canvas.game-canvas.is-visible {
            opacity: 1;
        }
        #developer-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(138, 43, 226, 0.04) 0%, 
                rgba(0, 191, 255, 0.02) 30%, 
                rgba(75, 0, 130, 0.03) 60%, 
                rgba(0, 0, 0, 0.98) 100%), 
                #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 400;
            cursor: pointer;
            opacity: 1;
            transition: opacity 1s ease-in-out;
        }
        #developer-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        #developer-logo {
            max-width: 90%;
            max-height: 90%;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        #developer-logo.fade-in {
            opacity: 1;
        }
        #welcome-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(138, 43, 226, 0.04) 0%, 
                rgba(0, 191, 255, 0.02) 30%, 
                rgba(75, 0, 130, 0.03) 60%, 
                rgba(0, 0, 0, 0.98) 100%), 
                #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            cursor: default;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }
        #welcome-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        #welcome-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        #welcome-overlay.fade-out-slow {
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
        }
        #welcome-logo {
            max-width: 80%;
            max-height: 80%;
            opacity: 0;
            transition: opacity 3s ease-in-out;
        }
        #welcome-logo.fade-in {
            opacity: 1;
        }
        #play-button-container {
            position: absolute;
            bottom: 15%;
            opacity: 0;
            transition: opacity 1s ease-in-out 1.5s; /* Fade in after logo */
        }
        #welcome-overlay.show #play-button-container {
            opacity: 1;
        }
        #play-button {
            background: none;
            border: none;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(24px, 4vw, 48px); /* Responsive font size */
            cursor: pointer;
            padding: 20px;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8), 0 0 16px rgba(197, 138, 255, 0.7);
            transition: text-shadow 0.3s ease;
        }
        #play-button:hover {
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #c58aff, 0 0 40px #c58aff;
        }
        #play-button span {
            display: inline-block;
            animation: bounce 1.8s infinite ease-in-out;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-25px); }
            60% { transform: translateY(-12px); }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        #controls-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(20, 20, 40, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #4a4a8a;
            color: white;
            z-index: 200;
            pointer-events: auto;
            width: 280px;
            backdrop-filter: blur(5px);
        }

        #ui-container, #controls-container {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0s 0.5s;
            pointer-events: none; /* Prevent interaction when hidden */
        }

        /* Show score/combo only when UI is active and game is not over */
        body.ui-on #ui-container {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        /* Show controls only when explicitly toggled on during active gameplay */
        body.ui-on.controls-on #controls-container {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition-delay: 0s;
        }
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #controls-container h3 {
            margin: 0;
            text-align: center;
            font-size: 1.1em;
            color: #c58aff;
        }
        #copy-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ddd;
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #copy-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .volume-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            width: 80%;
        }
        .volume-control label {
            margin-right: 10px;
        }
        .volume-control input[type="range"] {
            width: 100%;
        }
        .value-input {
            font-weight: bold;
            color: #eadaff;
            background-color: rgba(0,0,0,0.3);
            padding: 3px 8px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            border: 1px solid rgba(255,255,255,0.1);
            width: 70px;
            text-align: right;
            -moz-appearance: textfield; /* Firefox */
        }
        .value-input:hover {
            cursor: ew-resize;
        }
        .value-input::-webkit-outer-spin-button,
        .value-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0; /* Safari and Chrome */
        }
        label {
            font-size: 0.9em;
        }
        /* Accordion Styles */
        details {
            border-bottom: 1px solid rgba(138, 138, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        details:last-of-type {
            border-bottom: none;
            padding-bottom: 0;
        }
        summary {
            cursor: pointer;
            font-weight: bold;
            list-style: none; /* Remove default marker */
            padding: 5px 0;
            color: #b39ddb;
            font-size: 1em;
        }
        summary::-webkit-details-marker {
            display: none; /* Chrome */
        }
        summary::before {
            content: '+';
            margin-right: 10px;
            font-weight: bold;
        }
        details[open] > summary::before {
            content: '−';
        }
        details .control-group-content {
            padding-top: 10px;
        }
        #score, #combo {
            padding: 20px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            text-align: center; z-index: 100; pointer-events: auto; transition: opacity 0.3s ease;
        }
        .hidden { opacity: 0; pointer-events: none; }
        .overlay h1 { font-size: 3em; margin-bottom: 10px; }
        .overlay p { font-size: 1.2em; margin-bottom: 20px; }
        .overlay button {
            padding: 15px 30px; font-size: 1.2em; cursor: pointer; background-color: #4a4a8a;
            border: 2px solid #8a8aff; color: white; border-radius: 10px; margin-top: 20px;
            transition: background-color 0.2s, transform 0.2s;
        }
        .overlay button:hover { background-color: #6a6aff; transform: scale(1.05); }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #8c6aff; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        body.intro-active #ui-container,
        body.intro-active #controls-container {
            display: none !important;
        }
        .overlay-logo {
            width: 100px;
            margin-bottom: 20px;
        }
        #final-score-details {
            margin: 20px 0;
            text-align: left;
        }
        #final-score-details p {
            margin: 5px 0;
            font-size: 1.2em;
        }
        #rating-container {
            margin-top: 20px;
        }
        .stars {
            font-size: 2em;
            cursor: pointer;
        }
        .star {
            color: #c58aff;
            transition: color 0.2s;
        }
        .star:hover, .star.filled {
            color: #ffff00;
        }
        #rating-thanks {
            margin-top: 10px;
            color: #d1c4e9;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <div id="developer-overlay">
        <img id="developer-logo" src="developer.png" alt="Developer Logo">
    </div>
    <div id="welcome-overlay">
        <img id="welcome-logo" src="eonwisp.png" alt="Eonwisp Logo">
        <div id="play-button-container">
            <button id="play-button">
                <span style="animation-delay: 0.0s;">P</span>
                <span style="animation-delay: 0.1s;">L</span>
                <span style="animation-delay: 0.2s;">A</span>
                <span style="animation-delay: 0.3s;">Y</span>
            </button>
        </div>
    </div>
    <audio id="theme-music" loop src="eonwisp.mp3" autoplay playsinline preload="auto" muted></audio>

    <div id="permission-overlay" class="overlay hidden">
        <h1>Guardião da Etérea</h1>
        <p>Este jogo utiliza o giroscópio do seu dispositivo.<br>No PC, o mouse será capturado para melhor controle.</p>
        <button id="permission-button">Iniciar Jogo</button>
    </div>

    <div id="pause-overlay" class="overlay hidden">
        <img src="eonwisp.png" class="overlay-logo" alt="Eonwisp">
        <h1>Jogo Pausado</h1>
        <div class="volume-control">
            <label for="volume-slider">Volume</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1">
        </div>
        <button id="resume-button">Continuar</button>
        <button id="pause-return-home-button">Return Home</button>
    </div>

    <div id="game-over-overlay" class="overlay hidden">
        <img src="eonwisp.png" class="overlay-logo" alt="Eonwisp">
        <h1>Fim de Jogo</h1>
        <div id="final-score-details">
            <p>Kills: <span id="final-kills">0</span></p>
            <p>Max Combo: <span id="final-max-combo">0</span></p>
            <p>Backshots: <span id="final-backshots">0</span></p>
            <p>Critical Hits: <span id="final-critical-hits">0</span></p>
        </div>
        <div id="rating-container">
            <p>Rate your experience:</p>
            <div class="stars">
                <span class="star" data-value="1">☆</span><span class="star" data-value="2">☆</span><span class="star" data-value="3">☆</span><span class="star" data-value="4">☆</span><span class="star" data-value="5">☆</span>
            </div>
            <p id="rating-thanks" class="hidden">Thank you for your feedback!</p>
        </div>
        <button id="play-again-button">Jogar Novamente</button>
        <button id="return-home-button">Return Home</button>
    </div>

    <div id="controls-container">
        <div class="controls-header">
            <h3>Controles de Física</h3>
            <button id="copy-button">Copiar</button>
        </div>
        <details>
            <summary>Movimento</summary>
            <div class="control-group-content">
                <div class="control-item"> <label for="impulse-value">Impulso (Mouse)</label> <input type="number" id="impulse-value" class="value-input" step="0.05" value="0.1"> </div>
                <div class="control-item"> <label for="orbital-impulse-value">Impulso em Órbita</label> <input type="number" id="orbital-impulse-value" class="value-input" step="0.01" value="0.10"> </div>
                <div class="control-item"> <label for="damping-value">Amortecimento</label> <input type="number" id="damping-value" class="value-input" step="0.005" value="0.800"> </div>
                <div class="control-item"> <label for="core-brake-value">Freio no Núcleo</label> <input type="number" id="core-brake-value" class="value-input" step="0.05" value="0.94"> </div>
            </div>
        </details>
        <details>
            <summary>Corda</summary>
            <div class="control-group-content">
                <div class="control-item"> <label for="max-length-value">Tamanho Máx.</label> <input type="number" id="max-length-value" class="value-input" step="10" value="180"> </div>
                <div class="control-item"> <label for="gravity-value">Atração Gravitacional</label> <input type="number" id="gravity-value" class="value-input" step="0.05" value="1.62"> </div>
                <div class="control-item"> <label for="retraction-value">Força de Retração</label> <input type="number" id="retraction-value" class="value-input" step="0.05" value="2.18"> </div>
                <div class="control-item"> <label for="overshoot-value">Elasticidade (%)</label> <input type="number" id="overshoot-value" class="value-input" step="0.01" value="0.99"> </div>
                <div class="control-item"> <label for="snap-back-value">Força Elástica</label> <input type="number" id="snap-back-value" class="value-input" step="0.01" value="0.50"> </div>
                <div class="control-item"> <label for="stiffness-value">Rigidez (Stiffness)</label> <input type="number" id="stiffness-value" class="value-input" step="0.001" value="0.001"> </div>
            </div>
        </details>
        <details>
            <summary>Combate</summary>
             <div class="control-group-content">
                 <div class="control-item"> <label for="enemy-health-value">Vida Padrão (Inimigo)</label> <input type="number" id="enemy-health-value" class="value-input" step="1" value="1"> </div>
                 <div class="control-item"> <label for="critical-speed-value">Vel. Crítica Mín.</label> <input type="number" id="critical-speed-value" class="value-input" step="0.5" value="7.6"> </div>
                 <div class="control-item"> <label for="hit-vibration-value">Vibração (Impacto)</label> <input type="number" id="hit-vibration-value" class="value-input" step="0.01" value="1.44"> </div>
                 <div class="control-item"> <label for="crit-vibration-value">Multiplicador Vib. Crítica</label> <input type="number" id="crit-vibration-value" class="value-input" step="0.1" value="2.0"> </div>
            </div>
        </details>
        <details>
            <summary>Aparência</summary>
            <div class="control-group-content">
                 <div class="control-item"> <label for="min-thickness-value">Espessura Mín.</label> <input type="number" id="min-thickness-value" class="value-input" step="0.5" value="6.5"> </div>
                 <div class="control-item"> <label for="max-thickness-value">Espessura Máx.</label> <input type="number" id="max-thickness-value" class="value-input" step="0.5" value="18.2"> </div>
                 <div class="control-item"> <label for="stretch-y-value">Alongamento Vel. (Y)</label> <input type="number" id="stretch-y-value" class="value-input" step="0.01" value="0.56"> </div>
                 <div class="control-item"> <label for="squash-x-value">Achatar Vel. (X)</label> <input type="number" id="squash-x-value" class="value-input" step="0.01" value="1.40"> </div>
                 <div class="control-item"> <label for="rotation-threshold-value">Vel. Mín. Rotação</label> <input type="number" id="rotation-threshold-value" class="value-input" step="0.1" value="7.9"> </div>
            </div>
        </details>
        <details open>
             <summary>Efeitos</summary>
             <div class="control-group-content">
                <div class="control-item"> <label for="slow-mo-strength-value">Força do Slow-Mo</label> <input type="number" id="slow-mo-strength-value" class="value-input" step="0.01" value="0.04"> </div>
                <div class="control-item"> <label for="slow-mo-duration-value">Duração do Slow-Mo</label> <input type="number" id="slow-mo-duration-value" class="value-input" step="1" value="49"> </div>
                <div class="control-item"> <label for="camera-zoom-value">Zoom da Câmera</label> <input type="number" id="camera-zoom-value" class="value-input" step="0.05" value="1.02"> </div>
                <div class="control-item"> <label for="splash-amount-value">Qtd. Partículas (Splash)</label> <input type="number" id="splash-amount-value" class="value-input" step="1" value="76"> </div>
                <div class="control-item"> <label for="trail-duration-value">Duração do Rastro</label> <input type="number" id="trail-duration-value" class="value-input" step="1" value="20"> </div>
                <div class="control-item"> <label for="trail-size-value">Tamanho do Rastro</label> <input type="number" id="trail-size-value" class="value-input" step="0.5" value="5.0"> </div>
            </div>
        </details>
    </div>

    <div id="ui-container">
        <div id="score">Pontuação: 0</div>
        <div id="combo">Combo: x0</div>
    </div>

    <script>
        window.onload = function() {
            document.body.classList.add('intro-active');
            const app = new PIXI.Application({
                width: window.innerWidth,
                height: window.innerHeight,
                antialias: true,
                transparent: false,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                backgroundColor: 0x0a0a1a,
            });
            document.body.appendChild(app.view);
            app.view.style.position = 'absolute';
            app.view.classList.add('game-canvas');

            const developerOverlay = document.getElementById('developer-overlay');
            const developerLogo = document.getElementById('developer-logo');
            const welcomeOverlay = document.getElementById('welcome-overlay');
            const welcomeLogo = document.getElementById('welcome-logo');
            const themeMusic = document.getElementById('theme-music');
            const scoreText = document.getElementById('score');
            const comboText = document.getElementById('combo');
            const permissionOverlay = document.getElementById('permission-overlay');
            const permissionButton = document.getElementById('permission-button');
            const pauseOverlay = document.getElementById('pause-overlay');
            const resumeButton = document.getElementById('resume-button');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const playAgainButton = document.getElementById('play-again-button');
            const volumeSlider = document.getElementById('volume-slider');
            const controlsContainer = document.getElementById('controls-container');

            themeMusic.volume = parseFloat(volumeSlider.value);

            let musicStarted = false;
            let developerLogoShown = false;
            let gameLogoShown = false;
            let experienceStarted = false;
            let developerClickTime = 0;
            let audioUnlocked = false;

            function setupAudio() {
                // Reset state on every page load
                audioUnlocked = false;
                musicStarted = false;
                themeMusic.currentTime = 0;
                themeMusic.muted = true;
                themeMusic.volume = parseFloat(volumeSlider.value);

                // Prime the audio by trying to play it muted
                const playPromise = themeMusic.play();
                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        console.log("Audio primed (playing muted).");
                        musicStarted = true;
                    }).catch(error => {
                        console.warn("Muted autoplay was blocked by the browser.", error);
                    });
                }

                // Set up a one-time listener for the first user interaction
                const unlockEvents = ['pointerdown', 'keydown', 'touchstart'];
                const unlockOnce = () => {
                    if (audioUnlocked) return;
                    audioUnlocked = true;
                    
                    console.log("User interaction detected, unlocking audio.");
                    themeMusic.muted = false;
                    themeMusic.volume = parseFloat(volumeSlider.value);
                    
                    // Ensure it plays from the start
                    themeMusic.currentTime = 0;
                    themeMusic.play().catch(e => console.warn("Error playing audio after unlock:", e));

                    // Clean up listeners
                    unlockEvents.forEach(e => document.body.removeEventListener(e, unlockOnce));
                };
                unlockEvents.forEach(e => document.body.addEventListener(e, unlockOnce, { once: true, passive: true }));
            }

            function startDeveloperLogoSequence() {
                if (developerLogoShown) return;
                developerLogoShown = true;
                
                console.log("🏢 Starting developer logo sequence...");
                
                // Fade in developer logo
                setTimeout(() => {
                    developerLogo.classList.add('fade-in');
                }, 500);
                
                // Auto-advance after 3 seconds if not clicked
                setTimeout(() => {
                    if (!gameLogoShown) {
                        transitionToGameLogo();
                    }
                }, 3500); // 500ms delay + 3000ms hold
            }

            function transitionToGameLogo() {
                if (gameLogoShown) return;
                gameLogoShown = true;
                
                console.log("🎮 Transitioning to game logo...");
                
                // Fade out developer overlay
                developerOverlay.classList.add('fade-out');
                
                // Show and fade in game logo
                setTimeout(() => {
                    welcomeOverlay.classList.add('show');
                    setTimeout(() => {
                        welcomeLogo.classList.add('fade-in');
                        // Only add click handler after game logo is visible
                        setupGameLogoClickHandler();
                    }, 100);
                }, 500);
                
                // Hide developer overlay completely after fade out
                setTimeout(() => {
                    developerOverlay.style.display = 'none';
                }, 1000);
            }

            function beginExperience() {
                document.body.classList.remove('intro-active');
                if (experienceStarted) return;
                experienceStarted = true;
                
                console.log("🚀 Starting game experience...");
                
                // Force audio to play from the beginning, unmuted.
                // This ensures it syncs with the game start animation.
                themeMusic.muted = false;
                themeMusic.currentTime = 0;
                themeMusic.play().catch(e => console.warn("Begin experience play() failed:", e));
                
                // Use slower fade-out for game logo
                welcomeOverlay.classList.add('fade-out-slow');
                requestDeviceMotionPermission();
                document.body.classList.add('ui-on');
                
                // Add extra 1 second delay before game view fade-in for cleaner appearance
                setTimeout(() => {
                    app.view.classList.add('is-visible');
                }, 3000); // 2s fade-out + 1s extra delay
                
                const overlayFadeDuration = 2000;
                setTimeout(() => {
                    welcomeOverlay.style.display = 'none';
                }, overlayFadeDuration);
            }

            // Developer logo click handler - skip to game logo after minimum 0.5s
            developerOverlay.addEventListener('click', () => {
                if (!developerLogoShown || gameLogoShown) return;
                
                developerClickTime = Date.now();
                const timeSinceStart = developerClickTime - (performance.timing.navigationStart || 0);
                
                // Ensure minimum 0.5s has passed before allowing skip
                if (timeSinceStart >= 500) {
                    transitionToGameLogo();
                } else {
                    setTimeout(() => {
                        transitionToGameLogo();
                    }, 500 - timeSinceStart);
                }
            });

            // Game logo click handler - only add listener after game logo is shown
            function setupGameLogoClickHandler() {
                const playButton = document.getElementById('play-button');
                if (playButton) {
                    playButton.addEventListener('click', beginExperience, { once: true });
                }
                // Remove listener from the whole overlay to require a specific button press
                welcomeOverlay.removeEventListener('click', beginExperience);
            }

            setupAudio();
            startDeveloperLogoSequence();

            volumeSlider.addEventListener('input', (e) => {
                themeMusic.volume = e.target.value;
            });

            // --- CONTROLES DE FÍSICA ---
            let dynamicStiffness = 0.001, dynamicDamping = 0.800, dynamicImpulseMultiplier = 0.1, dynamicGravityPull = 1.62, dynamicOrbitalImpulse = 0.10, dynamicRetractionForce = 2.18;
            let dynamicMaxLength = 180;
            let dynamicOvershoot = 0.99, dynamicSnapBackStrength = 0.50, dynamicCoreBrake = 0.94;
            let dynamicMinThickness = 6.5, dynamicMaxThickness = 18.2;
            let dynamicStretchScaleY = 0.56, dynamicSquashScaleX = 1.40, dynamicHitVibration = 1.44, dynamicRotationThreshold = 7.9;
            let dynamicEnemyHealth = 1, dynamicCriticalSpeed = 7.6, dynamicCritVibrationMultiplier = 2.0;
            let dynamicSlowMoStrength = 0.04, dynamicSlowMoDuration = 49, dynamicCameraZoom = 1.02, dynamicSplashAmount = 76;
            let dynamicTrailDuration = 20, dynamicTrailSize = 5.0;
            let mobileAccelerometerMultiplier = 3.0; // Multiplier for mobile accelerometer sensitivity

            function setupDraggableInput(inputId, variableSetter, precision, sensitivity) {
                const input = document.getElementById(inputId);
                input.addEventListener('change', (e) => { let value = parseFloat(e.target.value); if (isNaN(value)) { value = 0; } variableSetter(value); e.target.value = value.toFixed(precision); });
                let isDragging = false, startX = 0, startValue = 0;
                input.addEventListener('mousedown', (e) => { isDragging = true; startX = e.clientX; startValue = parseFloat(input.value); document.body.style.cursor = 'ew-resize'; input.style.pointerEvents = 'none'; e.preventDefault(); });
                window.addEventListener('mousemove', (e) => { if (!isDragging) return; const deltaX = e.clientX - startX; const newValue = startValue + (deltaX * sensitivity); input.value = newValue.toFixed(precision); variableSetter(newValue); });
                window.addEventListener('mouseup', () => { if (isDragging) { isDragging = false; document.body.style.cursor = 'default'; input.style.pointerEvents = 'auto'; } });
            }

            setupDraggableInput('stiffness-value', (v) => dynamicStiffness = v, 3, 0.0001);
            setupDraggableInput('damping-value', (v) => dynamicDamping = v, 3, 0.001);
            setupDraggableInput('impulse-value', (v) => dynamicImpulseMultiplier = v, 1, 0.005);
            setupDraggableInput('gravity-value', (v) => dynamicGravityPull = v, 2, 0.01);
            setupDraggableInput('orbital-impulse-value', (v) => dynamicOrbitalImpulse = v, 2, 0.001);
            setupDraggableInput('retraction-value', (v) => dynamicRetractionForce = v, 2, 0.02);
            setupDraggableInput('max-length-value', (v) => dynamicMaxLength = v, 0, 1);
            setupDraggableInput('overshoot-value', (v) => dynamicOvershoot = v, 2, 0.001);
            setupDraggableInput('snap-back-value', (v) => dynamicSnapBackStrength = v, 2, 0.005);
            setupDraggableInput('core-brake-value', (v) => dynamicCoreBrake = v, 2, 0.001);
            setupDraggableInput('min-thickness-value', (v) => dynamicMinThickness = v, 1, 0.1);
            setupDraggableInput('max-thickness-value', (v) => dynamicMaxThickness = v, 1, 0.1);
            setupDraggableInput('stretch-y-value', (v) => dynamicStretchScaleY = v, 2, 0.002);
            setupDraggableInput('squash-x-value', (v) => dynamicSquashScaleX = v, 2, 0.002);
            setupDraggableInput('hit-vibration-value', (v) => dynamicHitVibration = v, 2, 0.005);
            setupDraggableInput('rotation-threshold-value', (v) => dynamicRotationThreshold = v, 1, 0.1);
            setupDraggableInput('enemy-health-value', (v) => dynamicEnemyHealth = v, 0, 0.1);
            setupDraggableInput('critical-speed-value', (v) => dynamicCriticalSpeed = v, 1, 0.1);
            setupDraggableInput('crit-vibration-value', (v) => dynamicCritVibrationMultiplier = v, 1, 0.05);
            setupDraggableInput('slow-mo-strength-value', (v) => dynamicSlowMoStrength = v, 2, 0.01);
            setupDraggableInput('slow-mo-duration-value', (v) => dynamicSlowMoDuration = v, 0, 1);
            setupDraggableInput('camera-zoom-value', (v) => dynamicCameraZoom = v, 2, 0.01);
            setupDraggableInput('splash-amount-value', (v) => dynamicSplashAmount = v, 0, 1);
            setupDraggableInput('trail-duration-value', (v) => dynamicTrailDuration = v, 0, 1);
            setupDraggableInput('trail-size-value', (v) => dynamicTrailSize = v, 1, 0.1);

            document.getElementById('copy-button').addEventListener('click', () => {
                const allValues = {
                    dynamicStiffness, dynamicDamping, dynamicImpulseMultiplier, dynamicGravityPull, dynamicOrbitalImpulse, dynamicRetractionForce,
                    dynamicMaxLength, dynamicOvershoot, dynamicSnapBackStrength, dynamicCoreBrake, dynamicMinThickness, dynamicMaxThickness,
                    dynamicStretchScaleY, dynamicSquashScaleX, dynamicHitVibration, dynamicRotationThreshold, dynamicEnemyHealth, dynamicCriticalSpeed,
                    dynamicCritVibrationMultiplier, dynamicSlowMoStrength, dynamicSlowMoDuration, dynamicCameraZoom, dynamicSplashAmount,
                    dynamicTrailDuration, dynamicTrailSize
                };
                const text = Object.entries(allValues).map(([key, value]) => `${key.replace('dynamic', '')}: ${value}`).join('\n');
                navigator.clipboard.writeText(text).then(() => {
                    const btn = document.getElementById('copy-button');
                    btn.textContent = 'Copiado!';
                    setTimeout(() => btn.textContent = 'Copiar', 1500);
                });
            });
            // --- FIM DOS CONTROLES DE FÍSICA ---

            let score = 0, kills = 0, currentCombo = 0, maxComboInGame = 0, backshots = 0, criticalHits = 0, isMobile = false, isPaused = false, isGameOver = false;
            let playerState = 'at_core', isReturning = false;
            let center = { x: app.screen.width / 2, y: app.screen.height / 2 };
            let vibrationTimer = 0, slowMoTimer = 0, slowMoTarget = null;

            const trailGfx = new PIXI.Graphics();
            const particlesGfx = new PIXI.Graphics();
            app.stage.addChild(trailGfx);
            app.stage.addChild(particlesGfx);

            const CORE_BASE_COLOR = 0xaaaaff;
            const DART_NEAR_COLOR = 0xff6bff;
            const DART_FAR_COLOR = 0x3f1ca4;

            const core = new PIXI.Graphics().beginFill(CORE_BASE_COLOR).drawCircle(0, 0, 30).endFill();
            core.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 2, color: CORE_BASE_COLOR })];
            core.position.set(center.x, center.y);
            app.stage.addChild(core);
            
            const player = new PIXI.Graphics().beginFill(DART_NEAR_COLOR).moveTo(20, 0).lineTo(0, -15).lineTo(-10, 0).lineTo(0, 15).closePath().endFill();
            player.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1.5, color: DART_NEAR_COLOR })];
            player.position.set(center.x, center.y);
            player.vx = 0; player.vy = 0;

            const tether = new PIXI.Graphics();
            app.stage.addChild(tether);
            app.stage.addChild(player);

            let enemies = [];
            let enemySpawnTimer = 0;
            const motion = { ax: 0, ay: 0, mx: 0, my: 0 };
            let trailPoints = [];
            let particles = [];
            
            function handleOrientation(event) { motion.ax = (event.gamma || 0) / 45; motion.ay = (event.beta || 0) / 45; }
            function handleMouseMove(event) { motion.mx = event.movementX; motion.my = event.movementY; }

            function startGame(isMobileDetected) {
                isMobile = !!isMobileDetected;
                if (isMobile) {
                    app.ticker.start();
                } else {
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                }
            }

            function requestDeviceMotionPermission() {
                const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
                const canOrient = ('ondeviceorientation' in window) || (typeof DeviceOrientationEvent !== 'undefined');
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission()
                        .then(state => {
                            if (state === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation);
                                startGame(true);
                            } else {
                                startGame(false);
                            }
                        })
                        .catch(() => startGame(false));
                } else if (hasTouch && canOrient) {
                    window.addEventListener('deviceorientation', handleOrientation);
                    startGame(true);
                } else {
                    startGame(false);
                }
            }
            permissionButton.addEventListener('click', () => { 
                permissionOverlay.classList.add('hidden'); 
                beginExperience();
            });

            function pauseGame() { isPaused = true; app.ticker.stop(); pauseOverlay.classList.remove('hidden'); }
            function resumeGame() { 
                if (!isMobile) { 
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                } else { 
                    isPaused = false; 
                    app.ticker.start(); 
                    pauseOverlay.classList.add('hidden'); 
                } 
            } 
            
            document.addEventListener('pointerlockchange', () => {
                if(document.pointerLockElement === app.view){
                    document.addEventListener('mousemove', handleMouseMove, false); app.ticker.start(); isPaused = false; pauseOverlay.classList.add('hidden');
                } else { 
                    document.removeEventListener('mousemove', handleMouseMove, false); if(isGameOver || !app.ticker.started) return; pauseGame();
                }
            }, false);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !isPaused && document.pointerLockElement === app.view) {
                    document.exitPointerLock();
                }
                if (e.key && e.key.toLowerCase() === 'u') {
                    // Only allow toggling if the game is running and not over
                    if (experienceStarted && !isGameOver) {
                        document.body.classList.toggle('controls-on');
                    }
                }
            });
            resumeButton.addEventListener('click', resumeGame);
            playAgainButton.addEventListener('click', resetGame);
            document.getElementById('pause-return-home-button').addEventListener('click', returnToHome);

            document.getElementById('return-home-button').addEventListener('click', returnToHome);

            function returnToHome() {
                document.exitPointerLock();
                gameOverOverlay.classList.add('hidden');
                pauseOverlay.classList.add('hidden');
                resetState();
                experienceStarted = false; // Allow game to start again
                welcomeOverlay.style.display = 'flex';
                welcomeOverlay.classList.remove('fade-out-slow');
                welcomeOverlay.classList.add('show');
                document.body.classList.add('intro-active');
                document.body.classList.remove('ui-on');
                setupGameLogoClickHandler();
            }

            const stars = document.querySelectorAll('.star');
            let currentRating = 0;

            function setStars(rating) {
                stars.forEach(s => {
                    const value = parseInt(s.dataset.value);
                    if (value <= rating) {
                        s.innerHTML = '★';
                        s.classList.add('filled');
                    } else {
                        s.innerHTML = '☆';
                        s.classList.remove('filled');
                    }
                });
            }

            stars.forEach(star => {
                star.addEventListener('mouseover', () => {
                    const value = parseInt(star.dataset.value);
                    stars.forEach(s => {
                        const sValue = parseInt(s.dataset.value);
                        if (sValue <= value) {
                            s.innerHTML = '★';
                            s.classList.add('filled');
                        } else {
                            s.innerHTML = '☆';
                            s.classList.remove('filled');
                        }
                    });
                });

                star.addEventListener('mouseout', () => {
                    setStars(currentRating);
                });

                star.addEventListener('click', () => {
                    currentRating = parseInt(star.dataset.value);
                    setStars(currentRating);
                    document.getElementById('rating-thanks').classList.remove('hidden');
                });
            });

            function endGame() {
                isGameOver = true; if(document.pointerLockElement === app.view) document.exitPointerLock(); app.ticker.stop();
                document.getElementById('final-kills').textContent = kills;
                document.getElementById('final-max-combo').textContent = maxComboInGame;
                document.getElementById('final-backshots').textContent = backshots;
                document.getElementById('final-critical-hits').textContent = criticalHits;
                gameOverOverlay.classList.remove('hidden');
                document.body.classList.remove('ui-on'); // Hide in-game UI
                document.body.classList.remove('controls-on'); // Hide controls just in case
            }

            function resetState() {
                score = 0; kills = 0; currentCombo = 0; maxComboInGame = 0; backshots = 0; criticalHits = 0; isPaused = false; isGameOver = false;
                playerState = 'at_core'; isReturning = false;
                player.tint = 0xFFFFFF;
                scoreText.textContent = `Pontuação: ${score}`;
                comboText.textContent = `Combo: x${currentCombo}`;
                enemies.forEach(e => app.stage.removeChild(e.gfx)); enemies.length = 0;
                trailPoints = []; particles = [];
                player.x = center.x; player.y = center.y; player.vx = 0; player.vy = 0;
                player.rotation = 0; player.scale.set(1);
                app.stage.scale.set(1); app.stage.position.set(0,0); app.stage.pivot.set(0,0);
                slowMoTarget = null; slowMoTimer = 0; app.ticker.speed = 1.0;
                gameOverOverlay.classList.add('hidden');
                document.getElementById('rating-thanks').classList.add('hidden');
                currentRating = 0;
                setStars(0);
            }

            function resetGame() {
                resetState();
                document.body.classList.add('ui-on'); // Show UI for new game
                if(!isMobile) {
                    app.view.requestPointerLock().catch(err => console.warn("Pointer lock failed:", err));
                } else {
                    app.ticker.start();
                }
            }

            function updatePlayer() {
                if (vibrationTimer > 0) vibrationTimer--;
                
                if (isMobile) {
                    player.vx += motion.ax * mobileAccelerometerMultiplier; player.vy += motion.ay * mobileAccelerometerMultiplier;
                } else {
                    let impulse = (playerState === 'at_core') ? dynamicImpulseMultiplier : dynamicOrbitalImpulse;
                    player.vx += motion.mx * impulse;
                    player.vy += motion.my * impulse;
                    motion.mx = 0; motion.my = 0;
                }
                
                let dx = player.x - core.x, dy = player.y - core.y, dist = Math.hypot(dx, dy);
                const radialVelocity = (player.vx * dx + player.vy * dy) / (dist || 1);
                if (!isReturning && radialVelocity < 0 && dist > 50) { isReturning = true; }
                if (dist > 1) {
                    const angle = Math.atan2(dy, dx);
                    const springForce = dist * dynamicStiffness;
                    let totalReturnForce = springForce + dynamicGravityPull;
                    if (isReturning) { totalReturnForce += dynamicRetractionForce; }
                    player.vx -= Math.cos(angle) * totalReturnForce;
                    player.vy -= Math.sin(angle) * totalReturnForce;
                }
                
                player.vx *= dynamicDamping; player.vy *= dynamicDamping;
                player.x += player.vx; player.y += player.vy;

                dx = player.x - core.x; dy = player.y - core.y; dist = Math.hypot(dx, dy);
                const absoluteMaxLength = dynamicMaxLength * dynamicOvershoot;

                if (dist > dynamicMaxLength) {
                    const overshootAmount = dist - dynamicMaxLength;
                    const snapBackForce = overshootAmount * dynamicSnapBackStrength;
                    const angle = Math.atan2(dy, dx);
                    player.vx -= Math.cos(angle) * snapBackForce;
                    player.vy -= Math.sin(angle) * snapBackForce;
                }
                if (dist > absoluteMaxLength) {
                    const angle = Math.atan2(dy, dx);
                    player.x = core.x + Math.cos(angle) * absoluteMaxLength;
                    player.y = core.y + Math.sin(angle) * absoluteMaxLength;
                    const ux = dx / dist; const uy = dy / dist;
                    const velAlongRope = player.vx * ux + player.vy * uy;
                    if (velAlongRope > 0) { player.vx -= velAlongRope * ux; player.vy -= velAlongRope * uy; }
                }

                // Lógica de Estado e Aparência
                const speed = Math.hypot(player.vx, player.vy);
                if (dist > 1 && speed > dynamicRotationThreshold) { 
                    player.rotation = Math.atan2(dy, dx);
                }

                const MAX_VISUAL_SPEED = 15;
                const normalizedSpeed = Math.min(1.0, speed / MAX_VISUAL_SPEED);
                let scaleX = 1 - (1 - dynamicSquashScaleX) * normalizedSpeed;
                let scaleY = 1 + (dynamicStretchScaleY - 1) * normalizedSpeed;
                if (vibrationTimer > 0) {
                    const vibrationAmount = (dynamicHitVibration / 15) * vibrationTimer;
                    scaleX += (Math.random() - 0.5) * vibrationAmount;
                    scaleY += (Math.random() - 0.5) * vibrationAmount;
                }
                player.scale.set(scaleX, scaleY);
                
                const vitality = Math.max(0, 1.0 - (dist / dynamicMaxLength));
                player.tint = lerpColor(DART_FAR_COLOR, DART_NEAR_COLOR, vitality);
                
                if (playerState === 'launched') {
                     trailPoints.push({ x: player.x, y: player.y, lifetime: dynamicTrailDuration, tint: player.tint });
                }

                if (playerState === 'launched' && dist < (core.width / 2)) {
                    playerState = 'at_core'; currentCombo = 0; isReturning = false;
                    comboText.textContent = `Combo: x${currentCombo}`;
                    player.rotation = 0;
                } else if (playerState === 'at_core' && dist > (core.width / 2) + 5) {
                    playerState = 'launched'; isReturning = false; 
                }
                if (playerState === 'at_core') {
                    player.vx *= dynamicCoreBrake; player.vy *= dynamicCoreBrake;
                }
            }
            
            function lerpColor(start, end, t) {
                const sr = (start >> 16) & 0xff, sg = (start >> 8) & 0xff, sb = start & 0xff;
                const er = (end >> 16) & 0xff, eg = (end >> 8) & 0xff, eb = end & 0xff;
                const r = Math.round(sr + (er - sr) * t);
                const g = Math.round(sg + (eg - sg) * t);
                const b = Math.round(sb + (eb - sb) * t);
                return (r << 16) | (g << 8) | b;
            }

            function easeInOutCubic(x) { return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2; }

            function updateTether() {
                tether.clear();
                const dx = player.x - core.x, dy = player.y - core.y, dist = Math.hypot(dx, dy);
                if (dist < 1) return;
                const normalizedDist = Math.min(1.0, dist / dynamicMaxLength);
                const easedDist = easeInOutCubic(normalizedDist);
                const thickness = dynamicMinThickness + (1 - easedDist) * (dynamicMaxThickness - dynamicMinThickness);
                const segments = 24;
                const startColor = CORE_BASE_COLOR;
                const endColor = player.tint;
                for (let i = 0; i < segments; i++) {
                    const t1 = i / segments;
                    const t2 = (i + 1) / segments;
                    const color = lerpColor(startColor, endColor, t2);
                    const alpha = 0.35 + 0.45 * t2;
                    const x1 = core.x + dx * t1;
                    const y1 = core.y + dy * t1;
                    const x2 = core.x + dx * t2;
                    const y2 = core.y + dy * t2;
                    tether.lineStyle(thickness, color, alpha).moveTo(x1, y1).lineTo(x2, y2);
                }
            }

            function updateTrail() {
                trailGfx.clear();
                for (let i = trailPoints.length - 1; i >= 0; i--) {
                    let point = trailPoints[i];
                    point.lifetime--;
                    const alpha = Math.max(0, point.lifetime / dynamicTrailDuration);
                    const scale = Math.max(0, point.lifetime / dynamicTrailDuration);
                    trailGfx.beginFill(point.tint, alpha * 0.5).drawCircle(point.x, point.y, dynamicTrailSize * scale).endFill();
                    if (point.lifetime <= 0) { trailPoints.splice(i, 1); }
                }
            }

            function createSplash(x, y, color, amount) {
                for (let i = 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 4;
                    particles.push({
                        x, y, color,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        lifetime: 20 + Math.random() * 20,
                        alpha: 1.0,
                    });
                }
            }

            function updateParticles() {
                particlesGfx.clear();
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx; p.y += p.vy;
                    p.vx *= 0.95; p.vy *= 0.95;
                    p.lifetime--;
                    p.alpha = Math.max(0, p.lifetime / 40);

                    particlesGfx.beginFill(p.color, p.alpha).drawCircle(p.x, p.y, 2).endFill();
                    if (p.lifetime <= 0) { particles.splice(i, 1); }
                }
            }
            
            function updateSlowMotion() {
                if (slowMoTimer > 0) {
                    slowMoTimer--;
                    const halfDuration = dynamicSlowMoDuration / 2;
                    const progress = Math.abs(slowMoTimer - halfDuration) / halfDuration;
                    const easedProgress = easeInOutCubic(1 - progress);

                    app.ticker.speed = 1.0 - (1.0 - dynamicSlowMoStrength) * easedProgress;
                    
                    const targetScale = 1 + (dynamicCameraZoom - 1) * easedProgress;
                    app.stage.scale.set(targetScale);
                    
                    let pivotX, pivotY;

                    if (slowMoTimer > halfDuration) {
                        // Phase 1: Go from center to target
                        const attackProgress = 1 - ((slowMoTimer - halfDuration) / halfDuration);
                        const easedAttackProgress = easeInOutCubic(attackProgress);
                        pivotX = center.x + (slowMoTarget.x - center.x) * easedAttackProgress;
                        pivotY = center.y + (slowMoTarget.y - center.y) * easedAttackProgress;
                    } else {
                        // Phase 2: Return from target to center
                        const returnProgress = 1 - (slowMoTimer / halfDuration);
                        const easedReturnProgress = easeInOutCubic(returnProgress);
                        pivotX = slowMoTarget.x + (center.x - slowMoTarget.x) * easedReturnProgress;
                        pivotY = slowMoTarget.y + (center.y - slowMoTarget.y) * easedReturnProgress;
                    }
                    
                    app.stage.pivot.set(pivotX, pivotY);
                    app.stage.position.set(center.x, center.y);

                } else if (app.ticker.speed !== 1.0) {
                    app.ticker.speed = 1.0;
                    app.stage.scale.set(1.0);
                    app.stage.pivot.set(0,0);
                    app.stage.position.set(0,0);
                    slowMoTarget = null;
                }
            }

            function spawnEnemy() {
                const gfx = new PIXI.Graphics().beginFill(0xff4a4a).drawCircle(0, 0, 10).endFill();
                gfx.filters = [new PIXI.filters.GlowFilter({ distance: 10, outerStrength: 1, color: 0xff4a4a })];
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(app.screen.width, app.screen.height) / 2 + 50;
                gfx.position.set(center.x + Math.cos(angle) * radius, center.y + Math.sin(angle) * radius);
                
                const enemy = { gfx, health: dynamicEnemyHealth, maxHealth: dynamicEnemyHealth, hitTimer: 0 };
                app.stage.addChild(gfx);
                enemies.push(enemy);
            }

            function updateEnemies() {
                const speed = Math.hypot(player.vx, player.vy);
                const dist = Math.hypot(player.x - core.x, player.y - core.y);
                const isCritical = dist > dynamicMaxLength * 0.95 && speed > dynamicCriticalSpeed;

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const angle = Math.atan2(core.y - enemy.gfx.y, core.x - enemy.gfx.x);
                    enemy.gfx.x += Math.cos(angle) * 2 * app.ticker.speed;
                    enemy.gfx.y += Math.sin(angle) * 2 * app.ticker.speed;
                    
                    if (enemy.hitTimer > 0) {
                        enemy.hitTimer--;
                        const flash = Math.sin(enemy.hitTimer * 0.5) > 0;
                        enemy.gfx.tint = flash ? 0xFFFFFF : 0xff4a4a;
                    } else {
                        enemy.gfx.tint = 0xff4a4a;
                    }

                    if (Math.hypot(player.x - enemy.gfx.x, player.y - enemy.gfx.y) < 20) {
                        if (enemy.hitTimer === 0) {
                            if (isReturning) {
                                backshots++;
                            }
                            if (isCritical) {
                                criticalHits++;
                            }
                            enemy.health -= isCritical ? 2 : 1;
                            enemy.hitTimer = 10;
                            vibrationTimer = isCritical ? 15 * dynamicCritVibrationMultiplier : 15;
                            createSplash(enemy.gfx.x, enemy.gfx.y, 0xff4a4a, dynamicSplashAmount / (isCritical ? 1 : 2) );
                            if (isCritical && slowMoTimer <=0) { 
                                slowMoTimer = dynamicSlowMoDuration; 
                                slowMoTarget = { x: enemy.gfx.x, y: enemy.gfx.y };
                            }
                        }

                        if (enemy.health <= 0) {
                            kills++;
                            createSplash(enemy.gfx.x, enemy.gfx.y, 0xffffff, dynamicSplashAmount * 1.5);
                            app.stage.removeChild(enemy.gfx);
                            enemies.splice(i, 1);
                            currentCombo++;
                            maxComboInGame = Math.max(maxComboInGame, currentCombo);
                            score += 10 * currentCombo;
                            scoreText.textContent = `Pontuação: ${score}`;
                            comboText.textContent = `Combo: x${currentCombo}`;
                        }
                    } else if (Math.hypot(core.x - enemy.gfx.x, core.y - enemy.gfx.y) < 40) {
                         endGame(); return;
                    }
                }
            }

            function gameLoop(delta) {
                updateSlowMotion();
                const effectiveDelta = delta * app.ticker.speed;
                updatePlayer(effectiveDelta);
                updateTether(effectiveDelta);
                updateTrail(effectiveDelta);
                updateParticles(effectiveDelta);
                enemySpawnTimer += effectiveDelta;
                if (enemySpawnTimer > 60) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
                updateEnemies(effectiveDelta);
            }
            app.ticker.add(gameLoop);
            app.ticker.stop();

            window.addEventListener('resize', () => {
                app.renderer.resize(window.innerWidth, window.innerHeight);
                center = { x: app.screen.width / 2, y: app.screen.height / 2 };
                core.position.set(center.x, center.y);
                const newMaxLength = 180;
                const maxLengthInput = document.getElementById('max-length-value');
                maxLengthInput.value = newMaxLength;
                dynamicMaxLength = newMaxLength;
            });
        }
    </script>
</body>
</html>
