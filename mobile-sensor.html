<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mobile Sensor Sender</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; background: #0a0a1a; color: #e7e7ff; margin: 0; padding: 16px; }
    h1 { color: #ff6bff; font-size: 18px; margin-bottom: 12px; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid #4a4a8a; border-radius: 10px; padding: 16px; margin-bottom: 12px; }
    button { background: #4a4a8a; color: #fff; border: none; padding: 12px 16px; border-radius: 8px; font-size: 16px; }
    button:disabled { opacity: 0.6; }
    .row { display: flex; justify-content: space-between; margin: 6px 0; }
    .ok { color: #00ff8a; }
    .warn { color: #ffd166; }
    .err { color: #ff6464; }
    code { color: #7dfbff; }
  </style>
</head>
<body>
  <h1>ðŸ“± Mobile Sensor Sender</h1>

  <div class="card">
    <div class="row"><span>Status:</span><span id="status" class="warn">Not connected</span></div>
    <div class="row"><span>WS URL:</span><span><code id="wsUrl">ws://localhost:8080?role=mobile</code></span></div>
    <div class="row"><span>Rate:</span><span id="rate">0 msg/s (30fps target)</span></div>
    <div class="row"><span>Sent:</span><span id="sent">0</span></div>
  </div>

  <div class="card">
    <button id="btnStart">Start Sensors</button>
    <button id="btnReset" style="margin-left: 8px; background: #8a4a4a;">Reset Connection</button>
  </div>

  <div class="card">
    <div class="row"><strong>Accelerometer (m/sÂ²)</strong><span id="aTs">--</span></div>
    <div class="row"><span>X</span><span id="ax">--</span></div>
    <div class="row"><span>Y</span><span id="ay">--</span></div>
    <div class="row"><span>Z</span><span id="az">--</span></div>
  </div>

  <div class="card">
    <div class="row"><strong>Gyroscope (rad/s)</strong><span id="gTs">--</span></div>
    <div class="row"><span>X</span><span id="gx">--</span></div>
    <div class="row"><span>Y</span><span id="gy">--</span></div>
    <div class="row"><span>Z</span><span id="gz">--</span></div>
  </div>

  <script>
    (function () {
      // If served via http://localhost:8080, ws should be reachable at same host:port
      const defaultWs = 'ws://localhost:8080?role=mobile';
      const wsUrl = defaultWs;
      const dom = {
        status: document.getElementById('status'),
        wsUrl: document.getElementById('wsUrl'),
        btn: document.getElementById('btnStart'),
        rate: document.getElementById('rate'),
        sent: document.getElementById('sent'),
        ax: document.getElementById('ax'),
        ay: document.getElementById('ay'),
        az: document.getElementById('az'),
        aTs: document.getElementById('aTs'),
        gx: document.getElementById('gx'),
        gy: document.getElementById('gy'),
        gz: document.getElementById('gz'),
        gTs: document.getElementById('gTs'),
      };
      dom.wsUrl.textContent = wsUrl;

      let ws = null;
      let messagesSent = 0;
      let msgCounter = { count: 0, last: performance.now() };
      let latest = {
        accel: { x: 0, y: 0, z: 0, t: 0 },
        gyro: { x: 0, y: 0, z: 0, t: 0 }
      };
      let rafId = null;
      let rateTimerId = null;

      function setStatus(text, cls) {
        dom.status.textContent = text;
        dom.status.className = cls || '';
      }

      function connectWS() {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
        try {
          ws = new WebSocket(wsUrl);
          setStatus('Connectingâ€¦', 'warn');

          ws.onopen = () => setStatus('Connected', 'ok');
          ws.onclose = () => setStatus('Disconnected', 'err');
          ws.onerror = () => setStatus('Error', 'err');
        } catch (e) {
          setStatus('WS Error', 'err');
        }
      }

      function requestPermissionsIfNeeded() {
        // iOS requires explicit user gesture. Android Chrome usually does not.
        const AnyMotion = window.DeviceMotionEvent;
        if (AnyMotion && typeof AnyMotion.requestPermission === 'function') {
          return DeviceMotionEvent.requestPermission().catch(() => 'denied');
        }
        return Promise.resolve('granted');
      }

      function startSensors() {
        connectWS();

        // Avoid double listeners
        window.removeEventListener('devicemotion', onDeviceMotion);
        window.addEventListener('devicemotion', onDeviceMotion, { passive: true });

        // Sender loop (30 fps target for better performance and less lag)
        if (rafId) cancelAnimationFrame(rafId);
        let lastSendTime = 0;
        const sendInterval = 1000 / 30; // 30 fps = ~33ms interval

        const send = (currentTime) => {
          rafId = requestAnimationFrame(send);

          // Throttle to 30fps to reduce lag
          if (currentTime - lastSendTime < sendInterval) return;
          lastSendTime = currentTime;

          if (!ws || ws.readyState !== WebSocket.OPEN) return;

          const payload = {
            type: 'sensor',
            accelerometer: { x: latest.accel.x, y: latest.accel.y, z: latest.accel.z },
            gyroscope: { x: latest.gyro.x, y: latest.gyro.y, z: latest.gyro.z },
            timestamp: Date.now()
          };

          try {
            ws.send(JSON.stringify(payload));
            messagesSent++;
            msgCounter.count++;
          } catch { /* ignore transient send errors */ }
        };
        send();

        // Rate meter
        if (rateTimerId) clearInterval(rateTimerId);
        rateTimerId = setInterval(() => {
          const now = performance.now();
          const dt = (now - msgCounter.last) / 1000;
          if (dt >= 1) {
            const rate = (msgCounter.count / dt).toFixed(0);
            dom.rate.textContent = rate + ' msg/s';
            dom.sent.textContent = messagesSent.toString();
            msgCounter.count = 0;
            msgCounter.last = now;
          }
          if (!ws || ws.readyState === WebSocket.CLOSED) {
            clearInterval(rateTimerId);
            rateTimerId = null;
          }
        }, 250);
      }

      function onDeviceMotion(e) {
        // Enhanced sensor data processing with better fallbacks
        const a = e.accelerationIncludingGravity || e.acceleration;
        if (a && (a.x !== null || a.y !== null || a.z !== null)) {
          // Use actual sensor values when available
          latest.accel.x = a.x ?? 0;
          latest.accel.y = a.y ?? 0;
          latest.accel.z = a.z ?? 9.8; // Default gravity if Z is null
        } else {
          // Fallback: generate realistic movement simulation for testing
          const time = Date.now() / 1000;
          latest.accel.x = Math.sin(time * 0.5) * 2 + (Math.random() - 0.5) * 0.5;
          latest.accel.y = Math.cos(time * 0.3) * 1.5 + (Math.random() - 0.5) * 0.5;
          latest.accel.z = 9.8 + Math.sin(time * 0.8) * 1 + (Math.random() - 0.5) * 0.3;
        }
        latest.accel.t = Date.now();

        // Enhanced gyroscope processing
        const r = e.rotationRate;
        if (r && (r.alpha !== null || r.beta !== null || r.gamma !== null)) {
          // Convert deg/s to rad/s for real sensor data
          const d2r = Math.PI / 180;
          latest.gyro.x = (r.beta ?? 0) * d2r;
          latest.gyro.y = (r.gamma ?? 0) * d2r;
          latest.gyro.z = (r.alpha ?? 0) * d2r;
        } else {
          // Fallback: generate realistic rotation simulation
          const time = Date.now() / 1000;
          latest.gyro.x = Math.sin(time * 1.1) * 0.2 + (Math.random() - 0.5) * 0.02;
          latest.gyro.y = Math.cos(time * 0.7) * 0.15 + (Math.random() - 0.5) * 0.02;
          latest.gyro.z = Math.sin(time * 1.3) * 0.1 + (Math.random() - 0.5) * 0.01;
        }
        latest.gyro.t = Date.now();

        // Update HUD
        dom.ax.textContent = Number(latest.accel.x).toFixed(3);
        dom.ay.textContent = Number(latest.accel.y).toFixed(3);
        dom.az.textContent = Number(latest.accel.z).toFixed(3);
        dom.aTs.textContent = new Date(latest.accel.t).toLocaleTimeString();

        dom.gx.textContent = Number(latest.gyro.x).toFixed(3);
        dom.gy.textContent = Number(latest.gyro.y).toFixed(3);
        dom.gz.textContent = Number(latest.gyro.z).toFixed(3);
        dom.gTs.textContent = new Date(latest.gyro.t).toLocaleTimeString();
      }

      dom.btn.addEventListener('click', async () => {
        dom.btn.disabled = true;
        dom.btn.textContent = 'Startingâ€¦';
        const perm = await requestPermissionsIfNeeded();
        if (perm === 'denied') {
          setStatus('Permission denied', 'err');
          dom.btn.disabled = false;
          dom.btn.textContent = 'Start Sensors';
          return;
        }
        startSensors();
        dom.btn.textContent = 'Sensors Running';
      });

      // Reset button handler
      const btnReset = document.getElementById('btnReset');
      btnReset.addEventListener('click', () => {
        // Prevent multiple reset operations
        if (btnReset.disabled) return;
        btnReset.disabled = true;

        // Close existing connection
        if (ws) {
          try { ws.close(); } catch {}
          ws = null;
        }

        // Stop animation frame and timers
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        if (rateTimerId) {
          clearInterval(rateTimerId);
          rateTimerId = null;
        }

        // Reset counters
        messagesSent = 0;
        msgCounter = { count: 0, last: performance.now() };

        // Update UI
        dom.sent.textContent = '0';
        dom.rate.textContent = '0 msg/s';
        setStatus('Reset - Reconnecting...', 'warn');
        dom.btn.disabled = true;
        dom.btn.textContent = 'Reconnecting...';

        // Attempt to reconnect after a brief delay
        setTimeout(() => {
          connectWS();

          // Wait a bit for connection to establish, then start sensors
          setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              startSensors();
              dom.btn.textContent = 'Sensors Running';
              setStatus('Connected', 'ok');
            } else {
              setStatus('Reconnection failed', 'err');
              dom.btn.disabled = false;
              dom.btn.textContent = 'Start Sensors';
            }
            btnReset.disabled = false;
          }, 1000);
        }, 500);
      });

      // Auto-start sensors after 1 second if connection is established
      setTimeout(() => {
        if (ws && ws.readyState === WebSocket.OPEN && dom.btn.textContent === 'Start Sensors') {
          console.log('ðŸ”„ Auto-starting sensors after 1 second delay...');
          dom.btn.click();
        }
      }, 1000);

      // Cleanup
      window.addEventListener('beforeunload', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          try { ws.close(); } catch {}
        }
        if (rafId) cancelAnimationFrame(rafId);
        if (rateTimerId) clearInterval(rateTimerId);
        window.removeEventListener('devicemotion', onDeviceMotion);
      });
    })();
  </script>
</body>
</html>
